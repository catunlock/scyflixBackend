<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <link href="http://arxiv.org/api/query?search_query%3Dall%3Acs.PL%26id_list%3D%26start%3D0%26max_results%3D500" rel="self" type="application/atom+xml"/>
  <title type="html">ArXiv Query: search_query=all:cs.PL&amp;id_list=&amp;start=0&amp;max_results=500</title>
  <id>http://arxiv.org/api/SZgJabOcFPd+A3f8Oj/4HnVhaZo</id>
  <updated>2017-10-08T00:00:00-04:00</updated>
  <opensearch:totalResults xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">3066</opensearch:totalResults>
  <opensearch:startIndex xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">0</opensearch:startIndex>
  <opensearch:itemsPerPage xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">500</opensearch:itemsPerPage>
  <entry>
    <id>http://arxiv.org/abs/cs/0402043v1</id>
    <updated>2004-02-18T06:30:12Z</updated>
    <published>2004-02-18T06:30:12Z</published>
    <title>The UPLNC Compiler: Design and Implementation</title>
    <summary>  The implementation of the compiler of the UPLNC language is presented with a
full source code listing.
</summary>
    <author>
      <name>Evgueniy Vitchev</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">134 pages, 2 figures, LaTeX</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0402043v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0402043v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0402058v1</id>
    <updated>2004-02-25T19:00:31Z</updated>
    <published>2004-02-25T19:00:31Z</published>
    <title>A Tribute to Alain Colmerauer</title>
    <summary>  The paper describes the contributions of Alain Colmerauer to the areas of
logic programs (LP) and constraint logic programs (CLP).
</summary>
    <author>
      <name>Jacques Cohen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0402058v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0402058v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D 3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0512026v1</id>
    <updated>2005-12-07T15:51:26Z</updated>
    <published>2005-12-07T15:51:26Z</published>
    <title>Checking C++ Programs for Dimensional Consistency</title>
    <summary>  I will present my implementation 'n-units' of physical units into C++
programs. It allows the compiler to check for dimensional consistency.
</summary>
    <author>
      <name>I. Josopait</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">submitted to "Computing in Science and Engineering"</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0512026v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0512026v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.2; I.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1008.1131v1</id>
    <updated>2010-08-06T07:55:16Z</updated>
    <published>2010-08-06T07:55:16Z</published>
    <title>Computing with Equations</title>
    <summary>  The intention of these notes is to give a mathematical account of how I
believe students could be taught to think about functional programming
languages and to explain how such languages work.
</summary>
    <author>
      <name>Chris Preston</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">240 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1008.1131v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1008.1131v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1102.2339v1</id>
    <updated>2011-02-11T12:53:14Z</updated>
    <published>2011-02-11T12:53:14Z</published>
    <title>A decompilation of the pi-calculus and its application to termination</title>
    <summary>  We study the correspondence between a concurrent lambda-calculus in
administrative, continuation passing style and a pi-calculus and we derive a
termination result for the latter.
</summary>
    <author>
      <name>Roberto Amadio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1102.2339v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1102.2339v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1106.3478v1</id>
    <updated>2011-06-15T08:27:04Z</updated>
    <published>2011-06-15T08:27:04Z</published>
    <title>Conditional Elimination through Code Duplication</title>
    <summary>  We propose an optimizing transformation which reduces program runtime at the
expense of program size by eliminating conditional jumps.
</summary>
    <author>
      <name>Joachim Breitner</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages, 5 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1106.3478v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1106.3478v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.3128v1</id>
    <updated>2013-09-12T12:04:49Z</updated>
    <published>2013-09-12T12:04:49Z</published>
    <title>Preliminary Notes on Termination and Non-Termination Reasoning</title>
    <summary>  In this preliminary note, we will illustrate our ideas on automated
mechanisms for termination and non-termination reasoning.
</summary>
    <author>
      <name>Ton Chanh Le</name>
    </author>
    <link href="http://arxiv.org/abs/1309.3128v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.3128v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.3072v2</id>
    <updated>2014-07-21T14:52:39Z</updated>
    <published>2014-05-13T09:10:32Z</published>
    <title>Haskell for OCaml programmers</title>
    <summary>  This introduction to Haskell is written to optimize learning by programmers
who already know OCaml.
</summary>
    <author>
      <name>Raphael Poss</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">16 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1405.3072v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.3072v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1407.5670v1</id>
    <updated>2014-07-21T21:20:31Z</updated>
    <published>2014-07-21T21:20:31Z</published>
    <title>Rust for functional programmers</title>
    <summary>  This article provides an introduction to Rust, a systems language by Mozilla,
to programmers already familiar with Haskell, OCaml or other functional
languages.
</summary>
    <author>
      <name>Raphael Poss</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1407.5670v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1407.5670v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1605.01480v1</id>
    <updated>2016-05-05T03:19:11Z</updated>
    <published>2016-05-05T03:19:11Z</published>
    <title>Towards Understanding Generics</title>
    <summary>  This article reports on steps towards building a simple and accurate
domain-theoretic model of generic nominally-typed OOP.
</summary>
    <author>
      <name>Moez A. AbdelGawad</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">29 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1605.01480v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1605.01480v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0107013v2</id>
    <updated>2001-07-12T11:34:06Z</updated>
    <published>2001-07-10T10:24:19Z</published>
    <title>The Logic Programming Paradigm and Prolog</title>
    <summary>  This is a tutorial on logic programming and Prolog appropriate for a course
on programming languages for students familiar with imperative programming.
</summary>
    <author>
      <name>Krzysztof R. Apt</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">37 pages; unpublished</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0107013v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0107013v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0110012v1</id>
    <updated>2001-10-03T09:08:25Z</updated>
    <published>2001-10-03T09:08:25Z</published>
    <title>Proceedings of the 6th Annual Workshop of the ERCIM Working Group on
  Constraints</title>
    <summary>  Homepage of the workshop proceedings, with links to all individually archived
papers
</summary>
    <author>
      <name>Krzysztof R. Apt</name>
    </author>
    <author>
      <name>Roman Bartak</name>
    </author>
    <author>
      <name>Eric Monfroy</name>
    </author>
    <author>
      <name>Francesca Rossi</name>
    </author>
    <author>
      <name>Sebastian Brand</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">2 invited talks, 17 papers</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0110012v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0110012v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0409016v1</id>
    <updated>2004-09-09T01:44:05Z</updated>
    <published>2004-09-09T01:44:05Z</published>
    <title>Using a hierarchy of Domain Specific Languages in complex software
  systems design</title>
    <summary>  A new design methodology is introduced, with some examples on building Domain
Specific Languages hierarchy on top of Scheme.
</summary>
    <author>
      <name>V. S. Lugovsky</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 pages, 1 figure</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0409016v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0409016v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1;I.2.2;D.3.2;D.2.10" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0411001v1</id>
    <updated>2004-11-01T16:00:07Z</updated>
    <published>2004-11-01T16:00:07Z</published>
    <title>Synchronization from a Categorical Perspective</title>
    <summary>  We introduce a notion of synchronization for higher-dimensional automata,
based on coskeletons of cubical sets. Categorification transports this notion
to the setting of categorical transition systems. We apply the results to study
the semantics of an imperative programming language with message-passing.
</summary>
    <author>
      <name>Krzysztof Worytkiewicz</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0411001v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0411001v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DM" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0912.2861v1</id>
    <updated>2009-12-15T12:26:02Z</updated>
    <published>2009-12-15T12:26:02Z</published>
    <title>JSC : A JavaScript Object System</title>
    <summary>  The JSC language is a superset of JavaScript designed to ease the development
of large web applications. This language extends JavaScripts own object system
by isolating code in a class declaration, simplifying multiple inheritance and
using method implementation agreements.
</summary>
    <author>
      <name>Artur Ventura</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0912.2861v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0912.2861v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1009.4020v1</id>
    <updated>2010-09-21T08:44:49Z</updated>
    <published>2010-09-21T08:44:49Z</published>
    <title>Proceedings of CICLOPS-WLPE 2010</title>
    <summary>  Online proceedings of the Joint Workshop on Implementation of Constraint
Logic Programming Systems and Logic-based Methods in Programming Environments
(CICLOPS-WLPE 2010), Edinburgh, Scotland, U.K., July 15, 2010.
</summary>
    <author>
      <name>German Vidal</name>
    </author>
    <author>
      <name>Neng-Fa Zhou</name>
    </author>
    <link href="http://arxiv.org/abs/1009.4020v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1009.4020v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.4993v1</id>
    <updated>2011-12-21T11:31:42Z</updated>
    <published>2011-12-21T11:31:42Z</published>
    <title>Online Proceedings of the 11th International Colloquium on
  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),
  Lexington, KY, U.S.A., July 10, 2011</title>
    <summary>  These are the revised versions of the papers presented at CICLOPS 2011, a
workshop colocated with ICLP 2011.
</summary>
    <author>
      <name>Salvador Abreu</name>
    </author>
    <author>
      <name>Vitor Santos Costa</name>
    </author>
    <link href="http://arxiv.org/abs/1112.4993v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.4993v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.2924v1</id>
    <updated>2012-02-14T03:02:06Z</updated>
    <published>2012-02-14T03:02:06Z</published>
    <title>From Mathematics to Abstract Machine: A formal derivation of an
  executable Krivine machine</title>
    <summary>  This paper presents the derivation of an executable Krivine abstract machine
from a small step interpreter for the simply typed lambda calculus in the
dependently typed programming language Agda.
</summary>
    <author>
      <name>Wouter Swierstra</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Radboud University Nijmegen</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.76.10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.76.10" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MSFP 2012, arXiv:1202.2407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 76, 2012, pp. 163-177</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1202.2924v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.2924v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1207.2017v1</id>
    <updated>2012-07-09T12:05:25Z</updated>
    <published>2012-07-09T12:05:25Z</published>
    <title>dup -- Explicit un-sharing in Haskell</title>
    <summary>  We propose two operations to prevent sharing in Haskell that do not require
modifying the data generating code, demonstrate their use and usefulness, and
compare them to other approaches to preventing sharing. Our claims are
supported by a formal semantics and a prototype implementation.
</summary>
    <author>
      <name>Joachim Breitner</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages, 9 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1207.2017v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1207.2017v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.3.3; E.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.5930v1</id>
    <updated>2013-06-25T11:54:48Z</updated>
    <published>2013-06-25T11:54:48Z</published>
    <title>The Green Language</title>
    <summary>  Green is a statically-typed object-oriented language that separates subtyping
from inheritance. It supports garbage collection, classes as first-class
objects, parameterized classes, introspective reflection and a kind of run-time
metaobjects called shells.
</summary>
    <author>
      <name>José de Oliveira Guimarães</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">220 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1306.5930v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.5930v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1308.3203v1</id>
    <updated>2013-08-14T18:30:37Z</updated>
    <published>2013-08-14T18:30:37Z</published>
    <title>Detecting Data Races on OpenCL Kernels with Symbolic Execution</title>
    <summary>  We present an automatic analysis technique for checking data races on OpenCL
kernels. Our method defines symbolic execution techniques based on separation
logic with suitable abstractions to automatically detect non-benign racy
behaviours on kernel
</summary>
    <author>
      <name>Dino Distefano</name>
    </author>
    <author>
      <name>Jeremy Dubreil</name>
    </author>
    <link href="http://arxiv.org/abs/1308.3203v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1308.3203v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1311.7256v1</id>
    <updated>2013-11-28T09:58:55Z</updated>
    <published>2013-11-28T09:58:55Z</published>
    <title>The ins and outs of iteration in Mezzo</title>
    <summary>  This is a talk proposal for HOPE 2013. Using iteration over a collection as a
case study, we wish to illustrate the strengths and weaknesses of the prototype
programming language Mezzo.
</summary>
    <author>
      <name>Armaël Guéneau</name>
    </author>
    <author>
      <name>François Pottier</name>
    </author>
    <author>
      <name>Jonathan Protzenko</name>
    </author>
    <link href="http://arxiv.org/abs/1311.7256v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1311.7256v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.0166v1</id>
    <updated>2014-05-01T14:22:09Z</updated>
    <published>2014-05-01T14:22:09Z</published>
    <title>Proceedings of the 6th European Conference on Python in Science
  (EuroSciPy 2013)</title>
    <summary>  These are the proceedings of the 6th European Conference on Python in
Science, EuroSciPy 2013, that was held in Brussels (21-25 August 2013).
</summary>
    <author>
      <name>Pierre de Buyl</name>
    </author>
    <author>
      <name>Nelle Varoquaux</name>
    </author>
    <link href="http://arxiv.org/abs/1405.0166v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.0166v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.1510v1</id>
    <updated>2014-06-05T20:11:27Z</updated>
    <published>2014-06-05T20:11:27Z</published>
    <title>Proceedings of the Eleventh Workshop on Constraint Handling Rules</title>
    <summary>  This volume contains the papers presented at the eleventh Workshop on
Constraint Handling Rules (CHR 2014), which will be held in Vienna at the
occasion of the Vienna Summer of Logic (VSL)
</summary>
    <author>
      <name>Rémy Haemmerlé</name>
    </author>
    <author>
      <name>Jon Sneyers</name>
    </author>
    <link href="http://arxiv.org/abs/1406.1510v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.1510v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1502.02519v2</id>
    <updated>2015-02-10T12:03:10Z</updated>
    <published>2015-02-09T15:20:03Z</published>
    <title>Kickstarting Choreographic Programming</title>
    <summary>  We present an overview of some recent efforts aimed at the development of
Choreographic Programming, a programming paradigm for the production of
concurrent software that is guaranteed to be correct by construction from
global descriptions of communication behaviour.
</summary>
    <author>
      <name>Fabrizio Montesi</name>
    </author>
    <link href="http://arxiv.org/abs/1502.02519v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1502.02519v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.03837v1</id>
    <updated>2015-08-16T15:36:30Z</updated>
    <published>2015-08-16T15:36:30Z</published>
    <title>Incorporating User Interaction into Imperative Languages</title>
    <summary>  Adding versatile interactions to imperative programming -- C, Java and
Android -- is an essential task. Unfortunately, existing languages provide
little constructs for user interaction.
  We propose a computability-logical approach to user interaction. We
illustrate our idea via C^I, an extension of the core C with a new choice
statement.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1508.03837v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.03837v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.06526v1</id>
    <updated>2015-08-26T15:09:33Z</updated>
    <published>2015-08-26T15:09:33Z</published>
    <title>A Logical Approach to Event Handling in Imperative Languages</title>
    <summary>  While event handling is a key element in modern interactive programming, it
is unfortunate that its theoretical foundation is rather weak. To solve this
problem, we propose to adopt a game-logical approach of computability logic
\cite{Jap08} to event handling.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1508.06526v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.06526v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.06459v1</id>
    <updated>2015-11-20T00:09:02Z</updated>
    <published>2015-11-20T00:09:02Z</published>
    <title>QINL: Query-integrated Languages</title>
    <summary>  We describe an alternative solution to the impedance-mismatch problem between
programming and query languages: rather than embed queries in a programming
language, as done in LINQ systems, we embed programs in a query language, and
dub the result QINL.
</summary>
    <author>
      <name>Patrick Schultz</name>
    </author>
    <author>
      <name>David I. Spivak</name>
    </author>
    <author>
      <name>Ryan Wisnesky</name>
    </author>
    <link href="http://arxiv.org/abs/1511.06459v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.06459v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1607.05707v1</id>
    <updated>2016-07-19T19:38:39Z</updated>
    <published>2016-07-19T19:38:39Z</published>
    <title>Lowering IrGL to CUDA</title>
    <summary>  The IrGL intermediate representation is an explicitly parallel representation
for irregular programs that targets GPUs. In this report, we describe IrGL
constructs, examples of their use and how IrGL is compiled to CUDA by the
Galois GPU compiler.
</summary>
    <author>
      <name>Sreepathi Pai</name>
    </author>
    <author>
      <name>Keshav Pingali</name>
    </author>
    <link href="http://arxiv.org/abs/1607.05707v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1607.05707v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.03350v1</id>
    <updated>2016-08-11T02:17:09Z</updated>
    <published>2016-08-11T02:17:09Z</published>
    <title>Close Encounters of the Higher Kind Emulating Constructor Classes in
  Standard ML</title>
    <summary>  We implement a library for encoding constructor classes in Standard ML,
including elaboration from minimal definitions, and automatic instantiation of
superclasses.
</summary>
    <author>
      <name>Yutaka Nagashima</name>
    </author>
    <author>
      <name>Liam O'Connor</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted by ACM SIGPLAN Workshop on ML, September 2016</arxiv:comment>
    <link href="http://arxiv.org/abs/1608.03350v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.03350v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.06583v1</id>
    <updated>2016-08-23T17:17:08Z</updated>
    <published>2016-08-23T17:17:08Z</published>
    <title>Syntax and analytic semantics of LISA</title>
    <summary>  We provide the syntax and semantics of the LISA (for "Litmus Instruction Set
Architecture") language. The parallel assembly language LISA is implemented in
the herd7 tool (http://virginia.cs.ucl.ac.uk/herd/) for simulating weak
consistency models.
</summary>
    <author>
      <name>Jade ALglave</name>
    </author>
    <author>
      <name>Patrick Cousot</name>
    </author>
    <link href="http://arxiv.org/abs/1608.06583v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.06583v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1702.01872v1</id>
    <updated>2017-02-07T03:55:07Z</updated>
    <published>2017-02-07T03:55:07Z</published>
    <title>Proceedings ML Family / OCaml Users and Developers workshops</title>
    <summary>  This volume contains the joint post-proceedings of the 2015 edition of the ML
Family Workshop and OCaml Users and Developers Workshop, held in Vancouver,
British Columbia, Canada, in affiliation with ICFP 2015.
</summary>
    <author>
      <name>Jeremy Yallop</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cambridge</arxiv:affiliation>
    </author>
    <author>
      <name>Damien Doligez</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.241</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.241" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 241, 2017</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1702.01872v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1702.01872v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1106.6196v2</id>
    <updated>2012-06-11T07:11:09Z</updated>
    <published>2011-06-30T11:51:25Z</published>
    <title>On the behaviours produced by instruction sequences under execution</title>
    <summary>  We study several aspects of the behaviours produced by instruction sequences
under execution in the setting of the algebraic theory of processes known as
ACP. We use ACP to describe the behaviours produced by instruction sequences
under execution and to describe two protocols implementing these behaviours in
the case where the processing of instructions takes place remotely. We also
show that all finite-state behaviours considered in ACP can be produced by
instruction sequences under execution.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.3233/FI-2012-753</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.3233/FI-2012-753" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">36 pages, consolidates material from arXiv:0811.0436 [cs.PL],
  arXiv:0902.2859 [cs.PL], and arXiv:0905.2257 [cs.PL]; abstract and
  introduction rewritten, examples and proofs added</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Fundamenta Informaticae, 120(2):111--144, 2012</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1106.6196v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1106.6196v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N19, 68N30, 68Q05, 68Q10, 68Q55, 68Q85" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.4; D.2.1; F.1.1; F.1.2; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0111037v2</id>
    <updated>2001-11-16T07:07:24Z</updated>
    <published>2001-11-14T08:43:50Z</published>
    <title>User-friendly explanations for constraint programming</title>
    <summary>  In this paper, we introduce a set of tools for providing user-friendly
explanations in an explanation-based constraint programming system. The idea is
to represent the constraints of a problem as an hierarchy (a tree). Users are
then represented as a set of understandable nodes in that tree (a cut).
Classical explanations (sets of system constraints) just need to get projected
on that representation in order to be understandable by any user. We present
here the main interests of this idea.
</summary>
    <author>
      <name>Narendra Jussien</name>
    </author>
    <author>
      <name>Samir Ouis</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In A. Kusalik (ed), proceedings of the Eleventh International
  Workshop on Logic Programming Environments (WLPE'01), December 1, 2001,
  Paphos, Cyprus. cs.PL/0111042</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0111037v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0111037v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6;D.3.3; F.4.1;D.2.5" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1702.03511v1</id>
    <updated>2017-02-12T10:32:38Z</updated>
    <published>2017-02-12T10:32:38Z</published>
    <title>Axioms for behavioural congruence of single-pass instruction sequences</title>
    <summary>  In program algebra, an algebraic theory of single-pass instruction sequences,
three congruences on instruction sequences are paid attention to: instruction
sequence congruence, structural congruence, and behavioural congruence. Sound
and complete axiom systems for the first two congruences were already given in
early papers on program algebra. The current paper is the first one that is
concerned with an axiom system for the third congruence.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">19 pages, this paper draws somewhat from the preliminaries of
  arXiv:1502.00238 [cs.PL] and some earlier papers</arxiv:comment>
    <link href="http://arxiv.org/abs/1702.03511v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1702.03511v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/9401102v1</id>
    <updated>1994-01-01T00:00:00Z</updated>
    <published>1994-01-01T00:00:00Z</published>
    <title>Mini-indexes for literate programs</title>
    <summary>  This paper describes how to implement a documentation technique that helps
readers to understand large programs or collections of programs, by providing
local indexes to all identifiers that are visible on every two-page spread. A
detailed example is given for a program that finds all Hamiltonian circuits in
an undirected graph.
</summary>
    <author>
      <name>Donald E. Knuth</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Software -- Concepts and Tools 15 (1994), 2--11</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/9401102v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/9401102v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/9911001v2</id>
    <updated>1999-11-26T12:54:51Z</updated>
    <published>1999-11-04T11:14:45Z</published>
    <title>Semantics of Programming Languages: A Tool-Oriented Approach</title>
    <summary>  By paying more attention to semantics-based tool generation, programming
language semantics can significantly increase its impact. Ultimately, this may
lead to ``Language Design Assistants'' incorporating substantial amounts of
semantic knowledge.
</summary>
    <author>
      <name>Jan Heering</name>
    </author>
    <author>
      <name>Paul Klint</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 2 figures. Submitted to ACM SIGPLAN Notices</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">ACM SIGPLAN Notices V. 35(3) March 2000 pp. 39-48</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/9911001v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/9911001v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.2; D.3.1; D.3.4; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0009029v1</id>
    <updated>2000-09-29T14:24:39Z</updated>
    <published>2000-09-29T14:24:39Z</published>
    <title>The Concurrent Language Aldwych</title>
    <summary>  Aldwych is proposed as the foundation of a general purpose language for
parallel applications. It works on a rule-based principle, and has aspects
variously of concurrent functional, logic and object-oriented languages, yet it
forms an integrated whole. It is intended to be applicable both for small-scale
parallel programming, and for large-scale open systems.
</summary>
    <author>
      <name>Matthew Huntbach</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented at RULE 2000, First International Workshop on Rule-Based
  Programming, Montreal, Canada</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0009029v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0009029v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0010008v1</id>
    <updated>2000-10-03T15:38:46Z</updated>
    <published>2000-10-03T15:38:46Z</published>
    <title>The Light Lexicographic path Ordering</title>
    <summary>  We introduce syntactic restrictions of the lexicographic path ordering to
obtain the Light Lexicographic Path Ordering. We show that the light
lexicographic path ordering leads to a characterisation of the functions
computable in space bounded by a polynomial in the size of the inputs.
</summary>
    <author>
      <name>E. A. Cichon</name>
    </author>
    <author>
      <name>J-Y. Marion</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0010008v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0010008v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.3; I.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0105015v1</id>
    <updated>2001-05-08T13:13:04Z</updated>
    <published>2001-05-08T13:13:04Z</published>
    <title>The alldifferent Constraint: A Survey</title>
    <summary>  The constraint of difference is known to the constraint programming community
since Lauriere introduced Alice in 1978. Since then, several solving strategies
have been designed for this constraint. In this paper we give both a practical
overview and an abstract comparison of these different strategies.
</summary>
    <author>
      <name>W. J. van Hoeve</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 3 figures, paper accepted at the 6th Annual workshop of the
  ERCIM Working Group on Constraints</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0105015v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0105015v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0109066v1</id>
    <updated>2001-09-24T15:39:57Z</updated>
    <published>2001-09-24T15:39:57Z</published>
    <title>CLP Approaches to 2D Angle Placements</title>
    <summary>  The paper presents two CLP approaches to 2D angle placements, implemented in
CHIP v.5.3. The first is based on the classical (rectangular) cumulative global
constraint, the second on the new trapezoidal cumulative global constraint.
Both approaches are applied to a specific presented.
</summary>
    <author>
      <name>Tomasz Szczygiel</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented at the 6th Annual Workshop of the ERCIM Working Group on
  Constraints, 2001</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0109066v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0109066v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0310020v1</id>
    <updated>2003-10-10T18:46:15Z</updated>
    <published>2003-10-10T18:46:15Z</published>
    <title>Pure Prolog Execution in 21 Rules</title>
    <summary>  A simple mathematical definition of the 4-port model for pure Prolog is
given. The model combines the intuition of ports with a compact representation
of execution state. Forward and backward derivation steps are possible. The
model satisfies a modularity claim, making it suitable for formal reasoning.
</summary>
    <author>
      <name>Marija Kulas</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages. Appeared in Proc. of the 5th Workshop on Rule-Based
  Constraint Reasoning and Programming (RCoRP'03), within CP'03, Kinsale,
  September 2003</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0310020v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0310020v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; F.3.1; D.2.5; I.2.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0311002v1</id>
    <updated>2003-11-04T12:43:54Z</updated>
    <published>2003-11-04T12:43:54Z</published>
    <title>Computing Convex Hulls with a Linear Solver</title>
    <summary>  A programming tactic involving polyhedra is reported that has been widely
applied in the polyhedral analysis of (constraint) logic programs. The method
enables the computations of convex hulls that are required for polyhedral
analysis to be coded with linear constraint solving machinery that is available
in many Prolog systems.
  To appear in Theory and Practice of Logic Programming (TPLP)
</summary>
    <author>
      <name>Florence Benoy</name>
    </author>
    <author>
      <name>Andy King</name>
    </author>
    <author>
      <name>Fred Mesnard</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">13 pages, 1 figure</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0311002v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0311002v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0311032v1</id>
    <updated>2003-11-21T06:18:19Z</updated>
    <published>2003-11-21T06:18:19Z</published>
    <title>A Very Short Self-Interpreter</title>
    <summary>  In this paper we would like to present a very short (possibly the shortest)
self-interpreter, based on a simplistic Turing-complete imperative language.
This interpreter explicitly processes the statements of the language, which
means the interpreter constitutes a description of the language inside that
same language. The paper does not require any specific knowledge; however,
experience in programming and a vivid imagination are beneficial.
</summary>
    <author>
      <name>Oleg Mazonka</name>
    </author>
    <author>
      <name>Daniel B. Cristofani</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0311032v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0311032v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0408045v1</id>
    <updated>2004-08-19T17:24:49Z</updated>
    <published>2004-08-19T17:24:49Z</published>
    <title>On computing the fixpoint of a set of boolean equations</title>
    <summary>  This paper presents a method for computing a least fixpoint of a system of
equations over booleans. The resulting computation can be significantly shorter
than the result of iteratively evaluating the entire system until a fixpoint is
reached.
</summary>
    <author>
      <name>Viktor Kuncak</name>
    </author>
    <author>
      <name>K. Rustan M. Leino</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0408045v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0408045v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; D.3.1; F.3.1; F.3.2; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0412043v1</id>
    <updated>2004-12-10T15:52:29Z</updated>
    <published>2004-12-10T15:52:29Z</published>
    <title>Widening Operators for Weakly-Relational Numeric Abstractions (Extended
  Abstract)</title>
    <summary>  We discuss the divergence problems recently identified in some extrapolation
operators for weakly-relational numeric domains. We identify the cause of the
divergences and point out that resorting to more concrete, syntactic domains
can be avoided by researching suitable algorithms for the elimination of
redundant constraints in the chosen representation.
</summary>
    <author>
      <name>Roberto Bagnara</name>
    </author>
    <author>
      <name>Patricia M. Hill</name>
    </author>
    <author>
      <name>Elena Mazzi</name>
    </author>
    <author>
      <name>Enea Zaffanella</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0412043v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0412043v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0511092v1</id>
    <updated>2005-11-28T07:20:43Z</updated>
    <published>2005-11-28T07:20:43Z</published>
    <title>The SL synchronous language, revisited</title>
    <summary>  We revisit the SL synchronous programming model introduced by Boussinot and
De Simone (IEEE, Trans. on Soft. Eng., 1996). We discuss an alternative design
of the model including thread spawning and recursive definitions and we explore
some basic properties of the revised model: determinism, reactivity, CPS
translation to a tail recursive form, computational expressivity, and a
compositional notion of program equivalence.
</summary>
    <author>
      <name>Roberto Amadio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Logic and Algebraic Programming 70 (15/02/2007) 121-150</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0511092v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0511092v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0512058v1</id>
    <updated>2005-12-14T13:42:17Z</updated>
    <published>2005-12-14T13:42:17Z</published>
    <title>Reactive concurrent programming revisited</title>
    <summary>  In this note we revisit the so-called reactive programming style, which
evolves from the synchronous programming model of the Esterel language by
weakening the assumption that the absence of an event can be detected
instantaneously. We review some research directions that have been explored
since the emergence of the reactive model ten years ago. We shall also outline
some questions that remain to be investigated.
</summary>
    <author>
      <name>Roberto Amadio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Gerard Boudol</name>
    </author>
    <author>
      <name>Ilaria Castellani</name>
    </author>
    <author>
      <name>Frederic Boussinot</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Workshop on Process Algebra (29/09/2006) 49-60</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0512058v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0512058v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701082v1</id>
    <updated>2007-01-12T18:43:48Z</updated>
    <published>2007-01-12T18:43:48Z</published>
    <title>Recurrence with affine level mappings is P-time decidable for CLP(R)</title>
    <summary>  In this paper we introduce a class of constraint logic programs such that
their termination can be proved by using affine level mappings. We show that
membership to this class is decidable in polynomial time.
</summary>
    <author>
      <name>Fred Mesnard</name>
    </author>
    <author>
      <name>Alexander Serebrenik</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Theory and Practice of Logic Programming (TPLP)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0701082v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701082v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701148v1</id>
    <updated>2007-01-24T07:03:17Z</updated>
    <published>2007-01-24T07:03:17Z</published>
    <title>Proceedings of the 16th Workshop in Logic-based Methods in Programming
  Environments (WLPE2006)</title>
    <summary>  This volume contains the papers presented at WLPE'06: the 16th Workshop on
Logic-based Methods in Programming Environments held on August 16, 2006 in the
Seattle Sheraton Hotel and Towers, Seattle, Washington (USA). It was organised
as a satellite workshop of ICLP'06, the 22th International Conference on Logic
Programming.
</summary>
    <author>
      <name>Wim Vanhoof</name>
    </author>
    <author>
      <name>Susana Munoz-Hernandez</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0701148v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701148v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6; D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701191v1</id>
    <updated>2007-01-30T15:20:07Z</updated>
    <published>2007-01-30T15:20:07Z</published>
    <title>The parallel implementation of the Astrée static analyzer</title>
    <summary>  The Astr\'{e}e static analyzer is a specialized tool that can prove the
absence of runtime errors, including arithmetic overflows, in large critical
programs. Keeping analysis times reasonable for industrial use is one of the
design objectives. In this paper, we discuss the parallel implementation of the
analysis.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIENS</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/11575467_7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/11575467_7" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">APLAS: Programming languages and systems (2005) 86-96</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0701191v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701191v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0705.2145v2</id>
    <updated>2007-05-22T09:52:57Z</updated>
    <published>2007-05-15T13:44:35Z</published>
    <title>Elementary transformation analysis for Array-OL</title>
    <summary>  Array-OL is a high-level specification language dedicated to the definition
of intensive signal processing applications. Several tools exist for
implementing an Array-OL specification as a data parallel program. While
Array-OL can be used directly, it is often convenient to be able to deduce part
of the specification from a sequential version of the application. This paper
proposes such an analysis and examines its feasibility and its limits.
</summary>
    <author>
      <name>Paul Feautrier</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIP, INRIA Rhône-Alpes</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/0705.2145v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0705.2145v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0706.0252v1</id>
    <updated>2007-06-02T06:18:48Z</updated>
    <published>2007-06-02T06:18:48Z</published>
    <title>Applying the Z-transform for the static analysis of floating-point
  numerical filters</title>
    <summary>  Digital linear filters are used in a variety of applications (sound
treatment, control/command, etc.), implemented in software, in hardware, or a
combination thereof. For safety-critical applications, it is necessary to bound
all variables and outputs of all filters. We give a compositional, effective
abstraction for digital linear filters expressed as block diagrams, yielding
sound, precise bounds for fixed-point or floating-point implementations of the
filters.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIENS</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/0706.0252v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0706.0252v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.NA" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0707.1059v1</id>
    <updated>2007-07-06T23:58:45Z</updated>
    <published>2007-07-06T23:58:45Z</published>
    <title>Projection semantics for rigid loops</title>
    <summary>  A rigid loop is a for-loop with a counter not accessible to the loop body or
any other part of a program. Special instructions for rigid loops are
introduced on top of the syntax of the program algebra PGA. Two different
semantic projections are provided and proven equivalent. One of these is taken
to have definitional status on the basis of two criteria: `normative semantic
adequacy' and `indicative algorithmic adequacy'.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <author>
      <name>Alban Ponse</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">20 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0707.1059v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0707.1059v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; D.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0710.4683v1</id>
    <updated>2007-10-25T09:07:39Z</updated>
    <published>2007-10-25T09:07:39Z</published>
    <title>The Challenges of Hardware Synthesis from C-Like Languages</title>
    <summary>  MANY TECHNIQUES for synthesizing digital hardware from C-like languages have
been proposed, but none have emerged as successful as Verilog or VHDL for
register-transfer-level design. This paper looks at two of the fundamental
challenges: concurrency and timing control.
</summary>
    <author>
      <name>Stephen A. Edwards</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted on behalf of EDAA (http://www.edaa.com/)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Dans Design, Automation and Test in Europe - DATE'05, Munich :
  Allemagne (2005)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0710.4683v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0710.4683v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0712.3116v1</id>
    <updated>2007-12-19T08:28:12Z</updated>
    <published>2007-12-19T08:28:12Z</published>
    <title>Proceedings of the 17th Workshop on Logic-based methods in Programming
  Environments (WLPE 2007)</title>
    <summary>  This volume contains the papers presented at WLPE 2007: the 17th Workshop on
Logic-based Methods in Programming Environments on 13th September, 2007 in
Porto, Portugal. It was held as a satellite workshop of ICLP 2007, the 23th
International Conference on Logic Programming.
</summary>
    <author>
      <name>Patricia Hill</name>
    </author>
    <author>
      <name>Wim Vanhoof</name>
    </author>
    <link href="http://arxiv.org/abs/0712.3116v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0712.3116v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6; D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0812.4973v1</id>
    <updated>2008-12-29T21:07:52Z</updated>
    <published>2008-12-29T21:07:52Z</published>
    <title>A Simple, Linear-Time Algorithm for x86 Jump Encoding</title>
    <summary>  The problem of space-optimal jump encoding in the x86 instruction set, also
known as branch displacement optimization, is described, and a linear-time
algorithm is given that uses no complicated data structures, no recursion, and
no randomization. The only assumption is that there are no array declarations
whose size depends on the negative of the size of a section of code (Hyde
2006), which is reasonable for real code.
</summary>
    <author>
      <name>Neil G. Dickson</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0812.4973v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0812.4973v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0906.3920v1</id>
    <updated>2009-06-22T05:49:12Z</updated>
    <published>2009-06-22T05:49:12Z</published>
    <title>Reasoning About a Service-oriented Programming Paradigm</title>
    <summary>  This paper is about a new way for programming distributed applications: the
service-oriented one. It is a concept paper based upon our experience in
developing a theory and a language for programming services. Both the
theoretical formalization and the language interpreter showed us the evidence
that a new programming paradigm exists. In this paper we illustrate the basic
features it is characterized by.
</summary>
    <author>
      <name>Claudio Guidi</name>
    </author>
    <author>
      <name>Fabrizio Montesi</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.2.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.2.6" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 2, 2009, pp. 67-81</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0906.3920v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0906.3920v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0907.5162v1</id>
    <updated>2009-07-29T15:38:02Z</updated>
    <published>2009-07-29T15:38:02Z</published>
    <title>Programming with Quantum Communication</title>
    <summary>  This work develops a formal framework for specifying, implementing, and
analysing quantum communication protocols. We provide tools for developing
simple proofs and analysing programs which involve communication, both via
quantum channels and exhibiting the LOCC (local operations, classical
communication) paradigm.
</summary>
    <author>
      <name>Anya Tafliovich</name>
    </author>
    <author>
      <name>Eric C. R. Hehner</name>
    </author>
    <link href="http://arxiv.org/abs/0907.5162v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0907.5162v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0908.4005v1</id>
    <updated>2009-08-27T13:02:23Z</updated>
    <published>2009-08-27T13:02:23Z</published>
    <title>jYang : A YANG parser in java</title>
    <summary>  The NETCONF configuration protocol of the IETF Network Work- ing Group
provides mechanisms to manipulate the configuration of network devices. YANG is
the language currently under consideration within the IETF to specify the data
models to be used in NETCONF . This report describes the design and development
of a syntax and semantics parser for YANG in java.
</summary>
    <author>
      <name>Emmanuel Nataf</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Lorraine - LORIA</arxiv:affiliation>
    </author>
    <author>
      <name>Olivier Festor</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Lorraine - LORIA</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/0908.4005v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0908.4005v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.NI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0910.3321v1</id>
    <updated>2009-10-17T18:52:53Z</updated>
    <published>2009-10-17T18:52:53Z</published>
    <title>Iterators, Recursors and Interaction Nets</title>
    <summary>  We propose a method for encoding iterators (and recursion operators in
general) using interaction nets (INs). There are two main applications for
this: the method can be used to obtain a visual nota- tion for functional
programs; and it can be used to extend the existing translations of the
lambda-calculus into INs to languages with recursive types.
</summary>
    <author>
      <name>Ian Mackie</name>
    </author>
    <author>
      <name>Jorge Sousa Pinto</name>
    </author>
    <author>
      <name>Miguel Vilaca</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">ISBN: 978-972-9348-18-1</arxiv:comment>
    <link href="http://arxiv.org/abs/0910.3321v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0910.3321v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0912.3583v1</id>
    <updated>2009-12-18T04:35:24Z</updated>
    <published>2009-12-18T04:35:24Z</published>
    <title>A Metamodel of Unit Testing for Object-Oriented Programming Languages</title>
    <summary>  A unit test is a method for verifying the accuracy and the proper functioning
of a portion of a program. This work consists to study the relation and the
approaches to test Object-Oriented Programming (OOP) programs and to propose a
metamodel that enables the programmer to write the tests while writing the
source code to be tested by exploiting the key features of OOP programming
languages such as inheritance, polymorphism, etc.
</summary>
    <author>
      <name>Martin Levesque</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0912.3583v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0912.3583v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1001.1022v1</id>
    <updated>2010-01-07T04:18:02Z</updated>
    <published>2010-01-07T04:18:02Z</published>
    <title>LXG Compiler - Design and Implementation</title>
    <summary>  LXG is a simple Pascal-like language. It is a functional programming language
developed for studying compiler design and implementation. The language
supports procedure and variable declarations, but no classes. This paper
reports the design and implementation of an LXG compiler. Test results are
presented as well.
</summary>
    <author>
      <name>Emil Vassev</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">37 pages, 2 figures, grammar in BNF</arxiv:comment>
    <link href="http://arxiv.org/abs/1001.1022v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1001.1022v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1003.5758v1</id>
    <updated>2010-03-30T08:11:40Z</updated>
    <published>2010-03-30T08:11:40Z</published>
    <title>Proceedings Tenth International Workshop on Rule-Based Programming</title>
    <summary>  This volume contains the proceedings of RULE 2009: the tenth International
Workshop on Rule-Based Programming. It took place in June 28th 2009, Brasilia,
Brazil, as a satellite event of RDP 2009. The first Rule workshop was held in
Montreal in 2000, and subsequent editions took place in Firenze, Pittsburgh,
Valencia, Aachen, Nara, Seattle, Paris, and Hagenberg.
</summary>
    <author>
      <name>Ian Mackie</name>
    </author>
    <author>
      <name>Anamaria Martins Moreira</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.21</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.21" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 21, 2010</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1003.5758v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1003.5758v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1004.4109v1</id>
    <updated>2010-04-23T12:02:51Z</updated>
    <published>2010-04-23T12:02:51Z</published>
    <title>Operator-oriented programming: a new paradigm for implementing window
  interfaces and parallel algorithms</title>
    <summary>  We present a new programming paradigm which can be useful, in particular, for
implementing window interfaces and parallel algorithms. This paradigm allows a
user to define operators which can contain nested operators. The new paradigm
is called operator-oriented. One of the goals of this paradigm is to escape the
complexity of objects definitions inherent in many object-oriented languages
and to move to transparent algorithms definitions.
</summary>
    <author>
      <name>Pavel Ruzankin</name>
    </author>
    <link href="http://arxiv.org/abs/1004.4109v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1004.4109v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.1.0" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1007.0159v1</id>
    <updated>2010-07-01T13:14:39Z</updated>
    <published>2010-07-01T13:14:39Z</published>
    <title>Empowering Collections with Swarm Behavior</title>
    <summary>  Often, when modelling a system there are properties and operations that are
related to a group of objects rather than to a single object. In this paper we
extend Java with Swarm Behavior, a new composition operator that associates
behavior with a collection of instances. The lookup resolution of swarm
behavior is based on the element type of a collection and is thus orthogonal to
the collection hierarchy.
</summary>
    <author>
      <name>Adrian Kuhn</name>
    </author>
    <author>
      <name>David Erni</name>
    </author>
    <author>
      <name>Marcus Denker</name>
    </author>
    <link href="http://arxiv.org/abs/1007.0159v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1007.0159v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.2850v1</id>
    <updated>2010-10-14T08:14:10Z</updated>
    <published>2010-10-14T08:14:10Z</published>
    <title>Steering Fragments of Instruction Sequences</title>
    <summary>  A steering fragment of an instruction sequence consists of a sequence of
steering instructions. These are decision points involving the check of a
propositional statement in sequential logic. The question is addressed why
composed propositional statements occur in steering fragments given the fact
that a straightforward transformation allows their elimination. A survey is
provided of constraints that may be implicitly assumed when composed
propositional statements occur in a meaningful instruction sequence.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <link href="http://arxiv.org/abs/1010.2850v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.2850v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.5569v1</id>
    <updated>2010-10-27T05:04:27Z</updated>
    <published>2010-10-27T05:04:27Z</published>
    <title>Static vs Dynamic SAGAs</title>
    <summary>  SAGAs calculi (or simply SAGAs) have been proposed by Bruni et al. as a model
for long-running transactions. The approach therein can be considered static,
while a dynamic approach has been proposed by Lanese and Zavattaro. In this
paper we first extend both static SAGAs (in the centralized interruption
policy) and dynamic SAGAs to deal with nesting, then we compare the two
approaches.
</summary>
    <author>
      <name>Ivan Lanese</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Focus Team, University of Bologna/INRIA</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.38.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.38.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2010, arXiv:1010.5308</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 38, 2010, pp. 51-65</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1010.5569v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.5569v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.5694v1</id>
    <updated>2010-10-27T14:20:46Z</updated>
    <published>2010-10-27T14:20:46Z</published>
    <title>Events! (Reactivity in urbiscript)</title>
    <summary>  Urbi SDK is a software platform for the development of portable robotic
applications. It features the Urbi UObject C++ middleware, to manage hardware
drivers and/or possibly remote software components, and urbiscript, a domain
specific programming language to orchestrate them. Reactivity is a key feature
of Urbi SDK, embodied in events in urbiscript. This paper presents the support
for events in urbiscript.
</summary>
    <author>
      <name>Jean-Christophe Baillie</name>
    </author>
    <author>
      <name>Akim Demaille</name>
    </author>
    <author>
      <name>Quentin Hocquet</name>
    </author>
    <author>
      <name>Matthieu Nottale</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">DSLRob'10</arxiv:comment>
    <link href="http://arxiv.org/abs/1010.5694v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.5694v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.RO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1011.1783v3</id>
    <updated>2011-09-27T14:12:46Z</updated>
    <published>2010-11-08T12:16:37Z</published>
    <title>OCamlJIT 2.0 - Faster Objective Caml</title>
    <summary>  This paper presents the current state of an ongoing research project to
improve the performance of the OCaml byte-code interpreter using Just-In-Time
native code generation. Our JIT engine OCamlJIT2 currently runs on x86-64
processors, mimicing precisely the behavior of the OCaml virtual machine. Its
design and implementation is described, and performance measures are given.
</summary>
    <author>
      <name>Benedikt Meurer</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">23 pages, 12 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1011.1783v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1011.1783v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1012.5560v1</id>
    <updated>2010-12-27T06:30:03Z</updated>
    <published>2010-12-27T06:30:03Z</published>
    <title>Strategic programming on graph rewriting systems</title>
    <summary>  We describe a strategy language to control the application of graph rewriting
rules, and show how this language can be used to write high-level declarative
programs in several application areas. This language is part of a graph-based
programming tool built within the port-graph transformation and visualisation
environment PORGY.
</summary>
    <author>
      <name>Maribel Fernández</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">King's College London</arxiv:affiliation>
    </author>
    <author>
      <name>Olivier Namet</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">King's College London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.44.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.44.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings IWS 2010, arXiv:1012.5337</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 44, 2010, pp. 1-20</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1012.5560v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1012.5560v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.0363v1</id>
    <updated>2011-07-28T17:46:20Z</updated>
    <published>2011-07-28T17:46:20Z</published>
    <title>Typesafe Modeling in Text Mining</title>
    <summary>  Based on the concept of annotation-based agents, this report introduces tools
and a formal notation for defining and running text mining experiments using a
statically typed domain-specific language embedded in Scala. Using machine
learning for classification as an example, the framework is used to develop and
document text mining experiments, and to show how the concept of generic,
typesafe annotation corresponds to a general information model that goes beyond
text processing.
</summary>
    <author>
      <name>Fabian Steeg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">63 pages, in German</arxiv:comment>
    <link href="http://arxiv.org/abs/1108.0363v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.0363v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.IR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.2.4; I.2.5; I.2.7" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.0323v1</id>
    <updated>2011-09-01T22:59:50Z</updated>
    <published>2011-09-01T22:59:50Z</published>
    <title>Proceedings IFIP Working Conference on Domain-Specific Languages</title>
    <summary>  This volume is the proceedings of the second IFIP Working Conference on
Domain-Specific Languages (DSL 2011). It contains 2 abstracts of invited
presentations, 7 peer-reviewed articles selected by the program committee from
14 submissions, and 6 lecture notes for the distilled tutorials that we
solicited.
</summary>
    <author>
      <name>Olivier Danvy</name>
    </author>
    <author>
      <name>Chung-chieh Shan</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.66</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.66" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This volume is dedicated to the memory of Anne-Fran\c{c}oise Le Meur
  (1972--2011)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 66, 2011</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1109.0323v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.0323v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.4048v1</id>
    <updated>2011-09-19T14:51:27Z</updated>
    <published>2011-09-19T14:51:27Z</published>
    <title>Implementing Continuation based language in GCC</title>
    <summary>  We have implemented C like Continuation based programming language.
Continuation based C, CbC was implemented using micro-C on various
architecture, and we have tried several CbC programming experiments. Here we
report new implementation of CbC compiler based on GCC 4.2.3. Since it contains
full C capability, we can use CbC and C in a mixture.
</summary>
    <author>
      <name>Shinji Kono</name>
    </author>
    <author>
      <name>Kento Yogi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Continuation Festa 2008 Tokyo</arxiv:comment>
    <link href="http://arxiv.org/abs/1109.4048v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.4048v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1110.1866v1</id>
    <updated>2011-10-09T18:46:04Z</updated>
    <published>2011-10-09T18:46:04Z</published>
    <title>Putting Instruction Sequences into Effect</title>
    <summary>  An attempt is made to define the concept of execution of an instruction
sequence. It is found to be a special case of directly putting into effect of
an instruction sequence. Directly putting into effect of an instruction
sequences comprises interpretation as well as execution. Directly putting into
effect is a special case of putting into effect with other special cases
classified as indirectly putting into effect.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <link href="http://arxiv.org/abs/1110.1866v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1110.1866v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1110.2350v2</id>
    <updated>2013-01-16T13:40:51Z</updated>
    <published>2011-10-11T12:35:00Z</published>
    <title>Certifying and reasoning about cost annotations of functional programs</title>
    <summary>  We present a so-called labelling method to insert cost annotations in a
higher-order functional program, to certify their correctness with respect to a
standard compilation chain to assembly code including safe memory management,
and to reason on them in a higher-order Hoare logic.
</summary>
    <author>
      <name>Roberto M. Amadio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Yann Regis-Gianas</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS, INRIA Paris - Rocquencourt</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Higher-Order and Symbolic Computation (2013)</arxiv:comment>
    <link href="http://arxiv.org/abs/1110.2350v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1110.2350v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1111.4742v1</id>
    <updated>2011-11-21T05:24:59Z</updated>
    <published>2011-11-21T05:24:59Z</published>
    <title>Solving the TTC 2011 Compiler Optimization Case with GrGen.NET</title>
    <summary>  The challenge of the Compiler Optimization Case is to perform local
optimizations and instruction selection on the graph-based intermediate
representation of a compiler. The case is designed to compare participating
tools regarding their performance. We tackle this task employing the general
purpose graph rewrite system GrGen.NET (www.grgen.net).
</summary>
    <author>
      <name>Sebastian Buchwald</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <author>
      <name>Edgar Jakumeit</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.74.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.74.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TTC 2011, arXiv:1111.4407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 74, 2011, pp. 42-53</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1111.4742v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1111.4742v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1111.4757v1</id>
    <updated>2011-11-21T05:27:20Z</updated>
    <published>2011-11-21T05:27:20Z</published>
    <title>Saying Hello World with GrGen.NET - A Solution to the TTC 2011
  Instructive Case</title>
    <summary>  We introduce the graph transformation tool GrGen.NET (www.grgen.net) by
solving the Hello World Case of the Transformation Tool Contest 2011 which
consists of a collection of small transformation tasks; for each task a section
is given explaining our implementation.
</summary>
    <author>
      <name>Sebastian Buchwald</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <author>
      <name>Edgar Jakumeit</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.74.23</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.74.23" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TTC 2011, arXiv:1111.4407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 74, 2011, pp. 281-294</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1111.4757v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1111.4757v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.3247v1</id>
    <updated>2012-02-15T09:41:45Z</updated>
    <published>2012-02-15T09:41:45Z</published>
    <title>Lambda-lifting and CPS conversion in an imperative language</title>
    <summary>  This paper is a companion technical report to the article
"Continuation-Passing C: from threads to events through continuations". It
contains the complete version of the proofs of correctness of lambda-lifting
and CPS-conversion presented in the article.
</summary>
    <author>
      <name>Gabriel Kerneis</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Juliusz Chroboczek</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: substantial text overlap with arXiv:1011.4558</arxiv:comment>
    <link href="http://arxiv.org/abs/1202.3247v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.3247v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.4269v1</id>
    <updated>2012-02-20T09:44:47Z</updated>
    <published>2012-02-20T09:44:47Z</published>
    <title>Live-Musikprogrammierung in Haskell</title>
    <summary>  We aim to compose algorithmic music in an interactive way with multiple
participants. To this end we develop an interpreter for a sub-language of the
non-strict functional programming language Haskell that allows to modify the
program during its execution. Our system can be used both for musical
live-coding and for demonstration and education of functional programming.
</summary>
    <author>
      <name>Henning Thielemann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 2 figures, 5. Arbeitstagung Programmiersprachen 2012,
  ATPS'12</arxiv:comment>
    <link href="http://arxiv.org/abs/1202.4269v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.4269v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SD" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1204.2566v1</id>
    <updated>2012-04-11T20:52:29Z</updated>
    <published>2012-04-11T20:52:29Z</published>
    <title>Synthesising Choreographies from Local Session Types (extended version)</title>
    <summary>  Designing and analysing multiparty distributed interactions can be achieved
either by means of a global view (e.g. in choreography-based approaches) or by
composing available computational entities (e.g. in service orchestration).
This paper proposes a typing systems which allows, under some conditions, to
synthesise a choreography (i.e. a multiparty global type) from a set of local
session types which describe end-point behaviours (i.e. local types).
</summary>
    <author>
      <name>Julien Lange</name>
    </author>
    <author>
      <name>Emilio Tuosto</name>
    </author>
    <link href="http://arxiv.org/abs/1204.2566v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1204.2566v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1211.3476v1</id>
    <updated>2012-11-15T01:33:41Z</updated>
    <published>2012-11-15T01:33:41Z</published>
    <title>Proceedings 6th Workshop on Membrane Computing and Biologically Inspired
  Process Calculi</title>
    <summary>  This volume contains the papers presented at the 6th Membrane Computing and
Biologically Inspired Process Calculi (MeCBIC 2012), a satellite workshop of
the 23rd International Conference on Concurrency Theory (CONCUR) held on 8th
September 2012 in Newcastle upon Tyne, UK.
</summary>
    <author>
      <name>Gabriel Ciobanu</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Romanian Academy, Institute of Computer Science</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.100</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.100" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 100, 2012</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1211.3476v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1211.3476v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.ET" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.2; F.3.2; G.3; J.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1301.6836v1</id>
    <updated>2013-01-29T06:02:21Z</updated>
    <published>2013-01-29T06:02:21Z</published>
    <title>Towards Interactive Object-Oriented Programming</title>
    <summary>  To represent interactive objects, we propose a choice-disjunctive declaration
statement of the form S R where S;R are the (procedure or field) declaration
statements within a class. This statement has the following semantics: request
the user to choose one between S and R when an object of this class is created.
This statement is useful for representing interactive objects that require
interactions with the user.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <author>
      <name>Kyunghwan Park</name>
    </author>
    <author>
      <name>Mi-Young Park</name>
    </author>
    <link href="http://arxiv.org/abs/1301.6836v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1301.6836v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1302.5586v1</id>
    <updated>2013-02-22T13:43:12Z</updated>
    <published>2013-02-22T13:43:12Z</published>
    <title>PENCIL: Towards a Platform-Neutral Compute Intermediate Language for
  DSLs</title>
    <summary>  We motivate the design and implementation of a platform-neutral compute
intermediate language (PENCIL) for productive and performance-portable
accelerator programming.
</summary>
    <author>
      <name>Riyadh Baghdadi</name>
    </author>
    <author>
      <name>Albert Cohen</name>
    </author>
    <author>
      <name>Serge Guelton</name>
    </author>
    <author>
      <name>Sven Verdoolaege</name>
    </author>
    <author>
      <name>Jun Inoue</name>
    </author>
    <author>
      <name>Tobias Grosser</name>
    </author>
    <author>
      <name>Georgia Kouveli</name>
    </author>
    <author>
      <name>Alexey Kravets</name>
    </author>
    <author>
      <name>Anton Lokhmotov</name>
    </author>
    <author>
      <name>Cedric Nugteren</name>
    </author>
    <author>
      <name>Fraser Waters</name>
    </author>
    <author>
      <name>Alastair F. Donaldson</name>
    </author>
    <link href="http://arxiv.org/abs/1302.5586v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1302.5586v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1303.5768v1</id>
    <updated>2013-03-22T20:02:38Z</updated>
    <published>2013-03-22T20:02:38Z</published>
    <title>Live music programming in Haskell</title>
    <summary>  We aim for composing algorithmic music in an interactive way with multiple
participants. To this end we have developed an interpreter for a sub-language
of the non-strict functional programming language Haskell that allows the
modification of a program during its execution. Our system can be used both for
musical live-coding and for demonstration and education of functional
programming.
</summary>
    <author>
      <name>Henning Thielemann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages, 2 figures, Linux Audio Conference 2013. This is a
  translation and update of the ATPS-2012 paper</arxiv:comment>
    <link href="http://arxiv.org/abs/1303.5768v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1303.5768v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SD" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1305.4957v1</id>
    <updated>2013-05-21T20:35:20Z</updated>
    <published>2013-05-21T20:35:20Z</published>
    <title>Propositional Encoding of Constraints over Tree-Shaped Data</title>
    <summary>  We present a functional programming language for specifying constraints over
tree-shaped data. The language allows for Haskell-like algebraic data types and
pattern matching. Our constraint compiler CO4 translates these programs into
satisfiability problems in propositional logic. We present an application from
the area of automated analysis of (non-)termination of rewrite systems.
</summary>
    <author>
      <name>Alexander Bau</name>
    </author>
    <author>
      <name>Johannes Waldmann</name>
    </author>
    <link href="http://arxiv.org/abs/1305.4957v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1305.4957v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1305.6108v2</id>
    <updated>2013-08-03T12:18:41Z</updated>
    <published>2013-05-27T05:22:24Z</published>
    <title>Bounded Choice Queries for Logic Programming</title>
    <summary>  Adding versatile interactions to goals and queries in logic programming is an
essential task. Unfortunately, existing logic languages can take input from the
user only via the $read$ construct.
  We propose to add a new interactive goal to allow for more controlled and
more guided participation from the user. We illustrate our idea via \muprolog,
an extension of Prolog with bounded choice goals.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1305.6108v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1305.6108v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.2328v1</id>
    <updated>2013-07-09T03:45:41Z</updated>
    <published>2013-07-09T03:45:41Z</published>
    <title>A Haskell Library for Term Rewriting</title>
    <summary>  We present a Haskell library for first-order term rewriting covering basic
operations on positions, terms, contexts, substitutions and rewrite rules. This
effort is motivated by the increasing number of term rewriting tools that are
written in Haskell.
</summary>
    <author>
      <name>Bertram Felgenhauer</name>
    </author>
    <author>
      <name>Martin Avanzini</name>
    </author>
    <author>
      <name>Christian Sternagel</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">1st International Workshop on Haskell And Rewriting Techniques, HART
  2013, 6 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.2328v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.2328v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4655v1</id>
    <updated>2013-07-17T14:42:55Z</updated>
    <published>2013-07-17T14:42:55Z</published>
    <title>Compilation for QCSP</title>
    <summary>  We propose in this article a framework for compilation of quantified
constraint satisfaction problems (QCSP). We establish the semantics of this
formalism by an interpretation to a QCSP. We specify an algorithm to compile a
QCSP embedded into a search algorithm and based on the inductive semantics of
QCSP. We introduce an optimality property and demonstrate the optimality of the
interpretation of the compiled QCSP.
</summary>
    <author>
      <name>Igor Stéphan</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the 13th International Colloquium on Implementation of
  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August
  25, 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.4655v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4655v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1308.2055v3</id>
    <updated>2013-08-22T06:21:25Z</updated>
    <published>2013-08-09T09:03:57Z</published>
    <title>Proceedings of the 23rd Workshop on Logic-based methods in Programming
  Environments (WLPE 2013)</title>
    <summary>  This volume contains the papers presented at the 23rd Workshop on Logic-based
Methods in Programming Environments (WLPE 2013), which was held in Istanbul,
Turkey, on August 24 &amp; 25 2013 as a satellite event of the 29th International
Conference on Logic Programming, (ICLP 2013).
</summary>
    <author>
      <name>Rémy Haemmerlé</name>
    </author>
    <author>
      <name>Jose Morales</name>
    </author>
    <link href="http://arxiv.org/abs/1308.2055v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1308.2055v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.1251v1</id>
    <updated>2013-09-05T07:45:00Z</updated>
    <published>2013-09-05T07:45:00Z</published>
    <title>Pattern Matching via Choice Existential Quantifications in Imperative
  Languages</title>
    <summary>  Selection statements -- if-then-else, switch and try-catch -- are commonly
used in modern imperative programming languages. We propose another selection
statement called a {\it choice existentially quantified statement}. This
statement turns out to be quite useful for pattern matching among several
merits. Examples will be provided for this statement.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1309.1251v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.1251v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5500v1</id>
    <updated>2013-09-21T16:48:22Z</updated>
    <published>2013-09-21T16:48:22Z</published>
    <title>PRoMoTo 2013 proceedings</title>
    <summary>  Programming for Mobile and Touch (PRoMoTo'13) was held at the 2013 ACM
SIGPLAN conference on Systems, Programming, Languages and Applications (SPLASH
2013), October 2013 in Indianapolis, USA. Submissions for this event were
invited in the general area of mobile and touch-oriented programming languages
and programming environments, and teaching of programming for mobile devices.
These are proceedings of the PRoMoTo'13.
</summary>
    <author>
      <name>Judith Bishop</name>
    </author>
    <author>
      <name>Nikolai Tillmann</name>
    </author>
    <author>
      <name>Arno Puder</name>
    </author>
    <author>
      <name>Vinayak Naik</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Published in PRoMoTo'13</arxiv:comment>
    <link href="http://arxiv.org/abs/1309.5500v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5500v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.3; D.2.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1310.4283v2</id>
    <updated>2014-06-13T12:28:39Z</updated>
    <published>2013-10-16T07:16:49Z</published>
    <title>Abstract interpretation as anti-refinement</title>
    <summary>  This article shows a correspondence between abstract interpretation of
imperative programs and the refinement calculus: in the refinement calculus, an
abstract interpretation of a program is a specification which is a function.
  This correspondence can be used to guide the design of mechanically verified
static analyses, keeping the correctness proof well separated from the
heuristic parts of the algorithms.
</summary>
    <author>
      <name>Arnaud Spiwack</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Working paper</arxiv:comment>
    <link href="http://arxiv.org/abs/1310.4283v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1310.4283v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.4454v2</id>
    <updated>2013-12-19T07:39:12Z</updated>
    <published>2013-12-16T18:39:55Z</published>
    <title>Exploiting Parallelism in Coalgebraic Logic Programming</title>
    <summary>  We present a parallel implementation of Coalgebraic Logic Programming (CoALP)
in the programming language Go. CoALP was initially introduced to reflect
coalgebraic semantics of logic programming, with coalgebraic derivation
algorithm featuring both corecursion and parallelism. Here, we discuss how the
coalgebraic semantics influenced our parallel implementation of logic
programming.
</summary>
    <author>
      <name>Ekaterina Komendantskaya</name>
    </author>
    <author>
      <name>Martin Schmidt</name>
    </author>
    <author>
      <name>Jónathan Heras</name>
    </author>
    <link href="http://arxiv.org/abs/1312.4454v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.4454v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1404.0076v1</id>
    <updated>2014-04-01T00:37:24Z</updated>
    <published>2014-04-01T00:37:24Z</published>
    <title>Towards a GPU-based implementation of interaction nets</title>
    <summary>  We present ingpu, a GPU-based evaluator for interaction nets that heavily
utilizes their potential for parallel evaluation. We discuss advantages and
challenges of the ongoing implementation of ingpu and compare its performance
to existing interaction nets evaluators.
</summary>
    <author>
      <name>Eugen Jiresch</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Technische Universität Wien</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.143.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.143.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings DCM 2012, arXiv:1403.7579</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 143, 2014, pp. 41-53</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1404.0076v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1404.0076v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1404.4666v1</id>
    <updated>2014-04-17T22:36:44Z</updated>
    <published>2014-04-17T22:36:44Z</published>
    <title>Object-Oriented Parallel Programming</title>
    <summary>  We introduce an object-oriented framework for parallel programming, which is
based on the observation that programming objects can be naturally interpreted
as processes. A parallel program consists of a collection of persistent
processes that communicate by executing remote methods. We discuss code
parallelization and process persistence, and explain the main ideas in the
context of computations with very large data objects.
</summary>
    <author>
      <name>Edward Givelberg</name>
    </author>
    <link href="http://arxiv.org/abs/1404.4666v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1404.4666v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.3099v1</id>
    <updated>2014-05-13T10:47:12Z</updated>
    <published>2014-05-13T10:47:12Z</published>
    <title>The Correctness of Launchbury's Natural Semantics for Lazy Evaluation</title>
    <summary>  In his seminal paper "A Natural Semantics for Lazy Evaluation", John
Launchbury proves his semantics correct with respect to a denotational
semantics. We machine-checked the proof and found it to fail, and provide two
ways to fix it: One by taking a detour via a modified natural semantics with an
explicit stack, and one by adjusting the denotational semantics of heaps.
</summary>
    <author>
      <name>Joachim Breitner</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">22 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1405.3099v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.3099v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.4078v1</id>
    <updated>2014-09-14T17:26:34Z</updated>
    <published>2014-09-14T17:26:34Z</published>
    <title>The distributed Language Hello White Paper</title>
    <summary>  Hello is a general-purpose, object-oriented, protocol-agnostic distributed
programming language. This paper explains the ideas that guided design of
Hello. It shows the spirit of Hello using two brief expressive programs and
provides a summary of language features. In addition, it explores historical
parallels between the binary programming of early computers and the distributed
programming of modern networks.
</summary>
    <author>
      <name>Boris Burshteyn</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1409.4078v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.4078v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.7514v3</id>
    <updated>2014-10-06T12:18:11Z</updated>
    <published>2014-09-26T09:29:09Z</published>
    <title>Coffman deadlocks in SCOOP</title>
    <summary>  In this paper we address the deadlock detection problem in the context of
SCOOP - an OO-programming model for concurrency, recently formalized in Maude.
We present the integration of a deadlock detection mechanism on top of the
aforementioned formalization and analyze how an abstract semantics of SCOOP
based on a notion of "may alias expressions" can contribute to improving the
deadlock detection procedure.
</summary>
    <author>
      <name>Georgiana Caltais</name>
    </author>
    <author>
      <name>Bertrand Meyer</name>
    </author>
    <link href="http://arxiv.org/abs/1409.7514v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.7514v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1410.7472v1</id>
    <updated>2014-10-28T00:41:47Z</updated>
    <published>2014-10-28T00:41:47Z</published>
    <title>A note on two notions of compliance</title>
    <summary>  We establish a relation between two models of contracts: binary session
types, and a model based on event structures and game-theoretic notions. In
particular, we show that compliance in session types corresponds to the
existence of certain winning strategies in game-based contracts.
</summary>
    <author>
      <name>Massimo Bartoletti</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cagliari</arxiv:affiliation>
    </author>
    <author>
      <name>Tiziana Cimoli</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cagliari</arxiv:affiliation>
    </author>
    <author>
      <name>G. Michele Pinna</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cagliari</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.166.9</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.166.9" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2014, arXiv:1410.7013</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 166, 2014, pp. 86-93</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1410.7472v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1410.7472v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.GT" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1411.5110v1</id>
    <updated>2014-11-19T04:34:35Z</updated>
    <published>2014-11-19T04:34:35Z</published>
    <title>Mutually Exclusive Procedures in Imperative Languages</title>
    <summary>  To represent mutually exclusive procedures, we propose a choice-conjunctive
declaration statement of the form $uchoo(S,R)$ where $S, R$ are the procedure
declaration statements within a module. This statement has the following
semantics: request the machine to choose a successful one between $S$ and $R$.
This statement is useful for representing objects with mutually exclusive
procedures. We illustrate our idea via C^uchoo, an extension of the core C with
a new statement.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">3 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1411.5110v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1411.5110v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.1393v1</id>
    <updated>2014-12-03T16:34:11Z</updated>
    <published>2014-12-03T16:34:11Z</published>
    <title>CLAZY: Lazy Calling for Common Lisp</title>
    <summary>  This document contains a description of a Common Lisp extension that allows a
programmer to write functional programs that use "normal order" evaluation, as
in "non-strict" languages like Haskell. The extension is relatively
straightforward, and it appears to be the first one such that is integrated in
the overall Common Lisp framework.
</summary>
    <author>
      <name>Marco Antoniotti</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">A version of this note was presented at the 1st European Lisp
  Symposium 2008, Bordeaux, France</arxiv:comment>
    <link href="http://arxiv.org/abs/1412.1393v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.1393v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.3729v1</id>
    <updated>2014-12-10T12:20:13Z</updated>
    <published>2014-12-10T12:20:13Z</published>
    <title>Non-termination of Dalvik bytecode via compilation to CLP</title>
    <summary>  We present a set of rules for compiling a Dalvik bytecode program into a
logic program with array constraints. Non-termination of the resulting program
entails that of the original one, hence the techniques we have presented before
for proving non-termination of constraint logic programs can be used for
proving non-termination of Dalvik programs.
</summary>
    <author>
      <name>Etienne Payet</name>
    </author>
    <author>
      <name>Fred Mesnard</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages, presented at the 13th International Workshop on Termination
  (WST) 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1412.3729v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.3729v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; F.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.4184v1</id>
    <updated>2014-12-13T02:39:20Z</updated>
    <published>2014-12-13T02:39:20Z</published>
    <title>Procedural and Non-Procedural Implementation of Search Strategies in
  Control Network Programming</title>
    <summary>  This report presents the general picture of how Control Network Programming
can be effectively used for implementing various search strategies, both blind
and informed. An interesting possibility is non - procedural solutions that can
be developed for most local search algorithms. A generic solution is described
for procedural implementations.
</summary>
    <author>
      <name>Kostadin Kratchanov</name>
    </author>
    <author>
      <name>Emilia Golemanova</name>
    </author>
    <author>
      <name>Tzanko Golemanov</name>
    </author>
    <author>
      <name>Tuncay Ercan</name>
    </author>
    <author>
      <name>Burak Ekici</name>
    </author>
    <link href="http://arxiv.org/abs/1412.4184v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.4184v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.4550v1</id>
    <updated>2014-12-15T11:32:54Z</updated>
    <published>2014-12-15T11:32:54Z</published>
    <title>Modeling Hybrid Systems in Hy-tccp</title>
    <summary>  Concurrent,reactive and hybrid systems require quality modeling languages to
be described and analyzed. The Timed Concurrent Constraint Language (tccp) was
introduced as a simple but powerful model for reactive systems. In this paper,
we present hybrid tccp (hy-tccp), an extension of tccp over continuous time
which includes new con- structs to model the continuous dynamics of hybrid
systems.
</summary>
    <author>
      <name>Damian Adalid</name>
    </author>
    <author>
      <name>Maria del Mar Gallardo</name>
    </author>
    <author>
      <name>Laura Titolo</name>
    </author>
    <link href="http://arxiv.org/abs/1412.4550v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.4550v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1501.00720v1</id>
    <updated>2015-01-04T21:02:34Z</updated>
    <published>2015-01-04T21:02:34Z</published>
    <title>Concept-oriented programming: from classes to concepts and from
  inheritance to inclusion</title>
    <summary>  For the past several decades, programmers have been modeling things in the
world with trees using hierarchies of classes and object-oriented programming
(OOP) languages. In this paper, we describe a novel approach to programming,
called concept-oriented programming (COP), which generalizes classes and
inheritance by introducing concepts and inclusion, respectively.
</summary>
    <author>
      <name>Alexandr Savinov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 2 figures. arXiv admin note: text overlap with
  arXiv:1409.3947</arxiv:comment>
    <link href="http://arxiv.org/abs/1501.00720v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1501.00720v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1503.04906v1</id>
    <updated>2015-03-17T03:58:23Z</updated>
    <published>2015-03-17T03:58:23Z</published>
    <title>A Finite Model Property for Intersection Types</title>
    <summary>  We show that the relational theory of intersection types known as BCD has the
finite model property; that is, BCD is complete for its finite models. Our
proof uses rewriting techniques which have as an immediate by-product the
polynomial time decidability of the preorder &lt;= (although this also follows
from the so called beta soundness of BCD).
</summary>
    <author>
      <name>Rick Statman</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Carnegie Mellon University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.177.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.177.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ITRS 2014, arXiv:1503.04377</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 177, 2015, pp. 1-9</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1503.04906v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1503.04906v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.00527v1</id>
    <updated>2015-04-02T12:40:18Z</updated>
    <published>2015-04-02T12:40:18Z</published>
    <title>Functional Programming is Free</title>
    <summary>  A paper has recently been published in SIAM-JC. This paper is faulty: 1) The
standard requirements about the definition of an algorithm are not respected,
2) The main point in the complexity study, namely the functional programming
component, is absent. The Editorial Board of the SIAM JC had been warned a
confirmed publication would be openly commented, it is the role of this text.
</summary>
    <author>
      <name>Francis Sergeraert</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">26 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1504.00527v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.00527v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="14Q20, 55-04" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.00977v1</id>
    <updated>2015-04-04T03:30:22Z</updated>
    <published>2015-04-04T03:30:22Z</published>
    <title>Declaratively solving Google Code Jam problems with Picat</title>
    <summary>  In this paper we present several examples of solving algorithmic problems
from the Google Code Jam programming contest with Picat programming language
using declarative techniques: constraint logic programming and tabled logic
programming. In some cases the use of Picat simplifies the implementation
compared to conventional imperative programming languages, while in others it
allows to directly convert the problem statement into an efficiently solvable
declarative problem specification without inventing an imperative algorithm.
</summary>
    <author>
      <name>Sergii Dymchenko</name>
    </author>
    <author>
      <name>Mariia Mykhailova</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-319-19686-2_4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-319-19686-2_4" rel="related"/>
    <link href="http://arxiv.org/abs/1504.00977v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.00977v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.02603v1</id>
    <updated>2015-04-10T09:31:32Z</updated>
    <published>2015-04-10T09:31:32Z</published>
    <title>A Simple Parallel Implementation of Interaction Nets in Haskell</title>
    <summary>  Due to their "inherent parallelism", interaction nets have since their
introduction been considered as an attractive implementation mechanism for
functional programming. We show that a simple highly-concurrent implementation
in Haskell can achieve promising speed-ups on multiple cores.
</summary>
    <author>
      <name>Wolfram Kahl</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">McMaster University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.179.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.179.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings DCM 2014, arXiv:1504.01927</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 179, 2015, pp. 33-47</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1504.02603v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.02603v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1505.02642v1</id>
    <updated>2015-05-11T14:40:29Z</updated>
    <published>2015-05-11T14:40:29Z</published>
    <title>Featherweight PINQ</title>
    <summary>  Differentially private mechanisms enjoy a variety of composition properties.
Leveraging these, McSherry introduced PINQ (SIGMOD 2009), a system empowering
non-experts to construct new differentially private analyses. PINQ is an
LINQ-like API which provides automatic privacy guarantees for all programs
which use it to mediate sensitive data manipulation. In this work we introduce
featherweight PINQ, a formal model capturing the essence of PINQ. We prove that
any program interacting with featherweight PINQ's API is differentially
private.
</summary>
    <author>
      <name>Hamid Ebadi</name>
    </author>
    <author>
      <name>David Sands</name>
    </author>
    <link href="http://arxiv.org/abs/1505.02642v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1505.02642v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.00723v3</id>
    <updated>2015-12-07T16:26:15Z</updated>
    <published>2015-07-02T12:34:20Z</published>
    <title>Theory of Programs</title>
    <summary>  A general theory of programs, programming and programming languages built up
from a few concepts of elementary set theory. Derives, as theorems, properties
treated as axioms by classic approaches to programming. Covers sequential and
concurrent computation.
</summary>
    <author>
      <name>Bertrand Meyer</name>
    </author>
    <link href="http://arxiv.org/abs/1507.00723v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.00723v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.4; D.1.5; D.1.3; D.2.1; D.2.4; D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.08093v1</id>
    <updated>2015-07-29T10:24:33Z</updated>
    <published>2015-07-29T10:24:33Z</published>
    <title>Property irrelevant predicates</title>
    <summary>  Although slicing removes code which has no bearing on property checking.
However even after that, our study has found that there are predicates in
program which have no bearing on property validation, although slicing could
not eliminate them. We have cope up with a criteria to identify such predicates
and then give a process to leverage them in scale up of property checking.
</summary>
    <author>
      <name>Shrawan Kumar</name>
    </author>
    <link href="http://arxiv.org/abs/1507.08093v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.08093v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.03263v3</id>
    <updated>2017-07-02T09:35:05Z</updated>
    <published>2015-08-13T16:34:22Z</published>
    <title>Logic Programming with Macro Connectives</title>
    <summary>  Logic programming such as Prolog is often sequential and slow because each
execution step processes only a single, $micro$ connective. To fix this
problem, we propose to use $macro$ connectives as the means of improving both
readability and performance.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">3 pages, some detailed explanations are added to version 2</arxiv:comment>
    <link href="http://arxiv.org/abs/1508.03263v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.03263v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1509.04315v1</id>
    <updated>2015-09-14T20:46:49Z</updated>
    <published>2015-09-14T20:46:49Z</published>
    <title>Implementing a teleo-reactive programming system</title>
    <summary>  This thesis explores the teleo-reactive programming paradigm for controlling
autonomous agents, such as robots. Teleo-reactive programming provides a
robust, opportunistic method for goal-directed programming that continuously
reacts to the sensed environment. In particular, the TR and TeleoR systems are
investigated. They influence the design of a teleo-reactive system programming
in Python, for controlling autonomous agents via the Pedro communications
architecture. To demonstrate the system, it is used as a controller in a simple
game.
</summary>
    <author>
      <name>Robert Webb</name>
    </author>
    <link href="http://arxiv.org/abs/1509.04315v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1509.04315v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1512.04013v1</id>
    <updated>2015-12-13T07:32:01Z</updated>
    <published>2015-12-13T07:32:01Z</published>
    <title>Comparing Weakest Precondition and Weakest Liberal Precondition</title>
    <summary>  In this article we investigate the relationships between the classical
notions of weakest precondition and weakest liberal precondition, and provide
several results, namely that in general, weakest liberal precondition is
neither stronger nor weaker than weakest precondition, however, given a
deterministic and terminating sequential while program and a postcondition,
they are equivalent. Hence, in such situation, it does not matter which
definition is used.
</summary>
    <author>
      <name>Andrew E. Santosa</name>
    </author>
    <link href="http://arxiv.org/abs/1512.04013v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1512.04013v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1603.08949v2</id>
    <updated>2016-04-12T10:49:48Z</updated>
    <published>2016-03-29T20:30:27Z</published>
    <title>The While language</title>
    <summary>  This article presents a formalisation of a simple imperative programming
language. The objective is to study and develop "hands-on" a formal
specifcation of a programming language, namely its syntax, operational
semantics and type system. To have an executable version of the language, we
implemented in Racket its operational semantics and type system.
</summary>
    <author>
      <name>Cláudio Vasconcelos</name>
    </author>
    <author>
      <name>António Ravara</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 21 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1603.08949v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1603.08949v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1604.02480v1</id>
    <updated>2016-04-08T20:50:15Z</updated>
    <published>2016-04-08T20:50:15Z</published>
    <title>Refinement Types for TypeScript</title>
    <summary>  We present Refined TypeScript (RSC), a lightweight refinement type system for
TypeScript, that enables static verification of higher-order, imperative
programs. We develop a formal core of RSC that delineates the interaction
between refinement types and mutability. Next, we extend the core to account
for the imperative and dynamic features of TypeScript. Finally, we evaluate RSC
on a set of real world benchmarks, including parts of the Octane benchmarks,
D3, Transducers, and the TypeScript compiler.
</summary>
    <author>
      <name>Panagiotis Vekris</name>
    </author>
    <author>
      <name>Benjamin Cosman</name>
    </author>
    <author>
      <name>Ranjit Jhala</name>
    </author>
    <link href="http://arxiv.org/abs/1604.02480v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1604.02480v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1605.05274v2</id>
    <updated>2016-11-07T14:13:28Z</updated>
    <published>2016-05-17T18:13:37Z</published>
    <title>Java Generics are Turing Complete</title>
    <summary>  This paper describes a reduction from the halting problem of Turing machines
to subtype checking in Java. It follows that subtype checking in Java is
undecidable, which answers a question posed by Kennedy and Pierce in 2007. It
also follows that Java's type checker can recognize any recursive language,
which improves a result of Gil and Levy from 2016. The latter point is
illustrated by a parser generator for fluent interfaces.
</summary>
    <author>
      <name>Radu Grigore</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">POPL2017</arxiv:comment>
    <link href="http://arxiv.org/abs/1605.05274v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1605.05274v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1606.06381v1</id>
    <updated>2016-06-21T00:46:13Z</updated>
    <published>2016-06-21T00:46:13Z</published>
    <title>A Modular Structural Operational Semantics for Delimited Continuations</title>
    <summary>  It has been an open question as to whether the Modular Structural Operational
Semantics framework can express the dynamic semantics of call/cc. This paper
shows that it can, and furthermore, demonstrates that it can express the more
general delimited control operators control and shift.
</summary>
    <author>
      <name>Neil Sculthorpe</name>
    </author>
    <author>
      <name>Paolo Torrini</name>
    </author>
    <author>
      <name>Peter D. Mosses</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.212.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.212.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings WoC 2015, arXiv:1606.05839</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 212, 2016, pp. 63-80</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1606.06381v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1606.06381v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1607.03733v1</id>
    <updated>2016-07-08T05:36:18Z</updated>
    <published>2016-07-08T05:36:18Z</published>
    <title>Data as processes: introducing measurement data into CARMA models</title>
    <summary>  Measurement data provides a precise and detailed description of components
within a complex system but it is rarely used directly as a component of a
system model. In this paper we introduce a model-based representation of
measurement data and use it together with modeller-defined components expressed
in the CARMA modelling language. We assess both liveness and safety properties
of these models with embedded data.
</summary>
    <author>
      <name>Stephen Gilmore</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.217.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.217.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings FORECAST 2016, arXiv:1607.02001</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 217, 2016, pp. 31-42</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1607.03733v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1607.03733v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.07161v1</id>
    <updated>2016-08-23T06:51:27Z</updated>
    <published>2016-08-23T06:51:27Z</published>
    <title>A Simple Guide to S3 Methods</title>
    <summary>  Writing functions in R is an important skill for anyone using R. S3 methods
allow for functions to be generalised across different classes and are easy to
implement. Whilst many R users are be adept at creating their own functions, it
seems that there is room for many more to take advantage of R's S3 methods.
This paper provides a simple and targeted guide to explain what S3 methods are,
why people should them, and how they can do it.
</summary>
    <author>
      <name>Nicholas Tierney</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1608.07161v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.07161v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.07531v2</id>
    <updated>2016-08-30T15:32:33Z</updated>
    <published>2016-08-26T17:28:06Z</published>
    <title>Syntax and semantics of the weak consistency model specification
  language cat</title>
    <summary>  We provide the syntax and semantics of the cat language, a domain specific
language to describe consistency properties of parallel/distributed programs.
The language is implemented in the herd7 too
(http://diy.inria.fr/doc/herd.html)l.
</summary>
    <author>
      <name>Jade Alglave</name>
    </author>
    <author>
      <name>Patrick Cousot</name>
    </author>
    <author>
      <name>Luc Maranget</name>
    </author>
    <link href="http://arxiv.org/abs/1608.07531v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.07531v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.06067v1</id>
    <updated>2016-10-19T15:31:34Z</updated>
    <published>2016-10-19T15:31:34Z</published>
    <title>Fairness as a Program Property</title>
    <summary>  We explore the following question: Is a decision-making program fair, for
some useful definition of fairness? First, we describe how several algorithmic
fairness questions can be phrased as program verification problems. Second, we
discuss an automated verification technique for proving or disproving fairness
of decision-making programs with respect to a probabilistic model of the
population.
</summary>
    <author>
      <name>Aws Albarghouthi</name>
    </author>
    <author>
      <name>Loris D'Antoni</name>
    </author>
    <author>
      <name>Samuel Drews</name>
    </author>
    <author>
      <name>Aditya Nori</name>
    </author>
    <link href="http://arxiv.org/abs/1610.06067v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.06067v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.07696v1</id>
    <updated>2016-10-25T01:00:47Z</updated>
    <published>2016-10-25T01:00:47Z</published>
    <title>Proceedings 14th International Workshop Quantitative Aspects of
  Programming Languages and Systems</title>
    <summary>  This volume contains the post-proceedings of the 14th International Workshop
on Quantitative Aspects of Programming Languages and Systems (QAPL), held as a
satellite workshop of ETAPS 2016 in Eindhoven, The Netherlands, on 2-3 April
2016.
</summary>
    <author>
      <name>Mirco Tribastone</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IMT School for Advanced Studies Lucca, Italy</arxiv:affiliation>
    </author>
    <author>
      <name>Herbert Wiklicky</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Imperial College London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.227</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.227" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 227, 2016</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1610.07696v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.07696v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1611.08651v1</id>
    <updated>2016-11-26T02:45:35Z</updated>
    <published>2016-11-26T02:45:35Z</published>
    <title>Proceedings of the 4th and 5th International Workshop on Trends in
  Functional Programming in Education</title>
    <summary>  This volume contains the proceedings of the Fourth and Fifth International
Workshops on Trends in Functional Programming in Education, TFPIE 2015 and
TFPIE 2016, which were held on June 2, 2015 in Sophia-Antipolis, France, and on
June 7, 2016 at the University of Maryland College Park in the USA,
respectively.
</summary>
    <author>
      <name>Johan Jeuring</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Utrecht University and Open University, The Netherlands</arxiv:affiliation>
    </author>
    <author>
      <name>Jay McCarthy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Massachusetts Lowell</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.230</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.230" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 230, 2016</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1611.08651v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1611.08651v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CY" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1702.08154v1</id>
    <updated>2017-02-27T06:01:12Z</updated>
    <published>2017-02-27T06:01:12Z</published>
    <title>Beyond-Regular Typestate</title>
    <summary>  We present an extension for regular typestates, called Beyond- Regular
Typestate(BR-Typestate), which is expressive enough to model non-regular
properties of programs and protocols over data. We model the BR-Typestate
system over a dependently typed, state based, impera- tive core language, and
we prove its soundness and tractability. We have implemented a prototype
typechecker for the language, and we show how several important, real world
non-regular properties of programs and protocols can be verified.
</summary>
    <author>
      <name>Ashish Mishra</name>
    </author>
    <author>
      <name>Y. N. Srikant</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">submitted to CAV'17</arxiv:comment>
    <link href="http://arxiv.org/abs/1702.08154v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1702.08154v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1703.05185v1</id>
    <updated>2017-03-15T14:40:21Z</updated>
    <published>2017-03-15T14:40:21Z</published>
    <title>Designing a pi-based Programming Language in the .NET framework: CLR
  interoperability from the Programmer's point of view</title>
    <summary>  Interoperability is the ability of a programming language to work with
systems based on different languages and paradigms. These days, many widely
used high-level language impementations provide access to external
functionalities. In this paper, we present some ideas on CLR interoperability
focusing on the kind of constructs desirable by a programmer to this regard.
</summary>
    <author>
      <name>Manuel Mazzara</name>
    </author>
    <link href="http://arxiv.org/abs/1703.05185v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1703.05185v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1703.05227v2</id>
    <updated>2017-03-16T08:09:52Z</updated>
    <published>2017-03-15T16:07:38Z</published>
    <title>Compiling Purely Functional Structured Programs</title>
    <summary>  We present a marriage of functional and structured imperative programming
that embeds in pure lambda calculus. We describe how we implement the core of
this language in a monadic DSL which is structurally equivalent to our intended
source language and which, when evaluated, generates pure lambda terms in
continuation-passing-style.
</summary>
    <author>
      <name>Phil Scott</name>
    </author>
    <author>
      <name>Steven Obua</name>
    </author>
    <author>
      <name>Jacques Fleuriot</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1703.05227v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1703.05227v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1705.08801v1</id>
    <updated>2017-05-24T14:49:25Z</updated>
    <published>2017-05-24T14:49:25Z</published>
    <title>Properties of Normalization for a math based intermediate representation</title>
    <summary>  The Normalization transformation plays a key role in the compilation of
Diderot programs. The transformations are complicated and it would be easy for
a bug to go undetected. To increase our confidence in normalization part of the
compiler we provide a formal analysis on the rewriting system. We proof that
the rewrite system is type preserving, value preserving (for tensor-valued
expressions), and terminating.
</summary>
    <author>
      <name>Charisee Chiw</name>
    </author>
    <author>
      <name>John Reppy</name>
    </author>
    <link href="http://arxiv.org/abs/1705.08801v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1705.08801v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1706.06497v1</id>
    <updated>2017-06-20T14:50:03Z</updated>
    <published>2017-06-20T14:50:03Z</published>
    <title>Alignment Elimination from Adams' Grammars</title>
    <summary>  Adams' extension of parsing expression grammars enables specifying
indentation sensitivity using two non-standard grammar constructs ---
indentation by a binary relation and alignment. This paper proposes a
step-by-step transformation of well-formed Adams' grammars for elimination of
the alignment construct from the grammar. The idea that alignment could be
avoided was suggested by Adams but no process for achieving this aim has been
described before.
</summary>
    <author>
      <name>Härmel Nestra</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1706.06497v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1706.06497v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; D.3.4; F.4.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1709.04619v1</id>
    <updated>2017-09-14T05:39:55Z</updated>
    <published>2017-09-14T05:39:55Z</published>
    <title>Extending Functional Languages with High-Level Exception Handling</title>
    <summary>  We extend functional languages with high-level exception handling. To be
specific, we allow sequential-choice expressions of the form $E_0
\bigtriangledown E_1$ where $E_0, E_1$ are expressions. These expressions have
the following intended semantics: sequentially $choose$ the first successful
$E_i$ and evaluate $E_i$ where $i$ = 0 or 1. These expressions thus allow us to
specify an expression $E_0$ with the failure-handling (exception handling)
routine, i.e., expression $E_1$.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">2 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1709.04619v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1709.04619v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1709.08193v1</id>
    <updated>2017-09-24T13:04:34Z</updated>
    <published>2017-09-24T13:04:34Z</published>
    <title>Anonymous Variables in Imperative Languages</title>
    <summary>  In this paper, we bring anonymous variables into imperative languages.
Anonymous variables represent don't-care values and have proven useful in logic
programming. To bring the same level of benefits into imperative languages, we
describe an extension to C wth anonymous variables.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages, We describe some usage of blind universal/existential
  quantifiers in imperative languages</arxiv:comment>
    <link href="http://arxiv.org/abs/1709.08193v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1709.08193v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0302013v1</id>
    <updated>2003-02-12T05:16:12Z</updated>
    <published>2003-02-12T05:16:12Z</published>
    <title>Cg in Two Pages</title>
    <summary>  Cg is a language for programming GPUs. This paper describes Cg briefly.
</summary>
    <author>
      <name>Mark J. Kilgard</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">2 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0302013v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0302013v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.GR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.GR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.3.6; C.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.1812v3</id>
    <updated>2014-04-06T14:56:30Z</updated>
    <published>2013-12-06T09:41:06Z</published>
    <title>Long multiplication by instruction sequences with backward jump
  instructions</title>
    <summary>  For each function on bit strings, its restriction to bit strings of any given
length can be computed by a finite instruction sequence that contains only
instructions to set and get the content of Boolean registers, forward jump
instructions, and a termination instruction. Backward jump instructions are not
necessary for this, but instruction sequences can be significantly shorter with
them. We take the function on bit strings that models the multiplication of
natural numbers on their representation in the binary number system to
demonstrate this by means of a concrete example. The example is reason to
discuss points concerning the halting problem and the concept of an algorithm.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages, the preliminaries are about the same as the preliminaries
  in arXiv:1308.0219 [cs.PL] and arXiv:1312.1529 [cs.PL]; minor errors
  corrected, references added; section on indirect addressing added</arxiv:comment>
    <link href="http://arxiv.org/abs/1312.1812v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.1812v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; F.2.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/9810010v2</id>
    <updated>1998-11-02T21:39:47Z</updated>
    <published>1998-10-09T20:29:43Z</published>
    <title>C++ Templates as Partial Evaluation</title>
    <summary>  This paper explores the relationship between C++ templates and partial
evaluation. Templates were designed to support generic programming, but
unintentionally provided the ability to perform compile-time computations and
code generation. These features are completely accidental, and as a result
their syntax is awkward. By recasting these features in terms of partial
evaluation, a much simpler syntax can be achieved. C++ may be regarded as a
two-level language in which types are first-class values. Template
instantiation resembles an offline partial evaluator. This paper describes
preliminary work toward a single mechanism based on Partial Evaluation which
unifies generic programming, compile-time computation and code generation. The
language Catat is introduced to illustrate these ideas.
</summary>
    <author>
      <name>Todd L. Veldhuizen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">13 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/9810010v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/9810010v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; D.3.3; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/9811001v1</id>
    <updated>1998-10-31T07:20:37Z</updated>
    <published>1998-10-31T07:20:37Z</published>
    <title>A Polymorphic Groundness Analysis of Logic Programs</title>
    <summary>  A polymorphic analysis is an analysis whose input and output contain
parameters which serve as placeholders for information that is unknown before
analysis but provided after analysis. In this paper, we present a polymorphic
groundness analysis that infers parameterised groundness descriptions of the
variables of interest at a program point. The polymorphic groundness analysis
is designed by replacing two primitive operators used in a monomorphic
groundness analysis and is shown to be as precise as the monomorphic groundness
analysis for any possible values for mode parameters. Experimental results of a
prototype implementation of the polymorphic groundness analysis are given.
</summary>
    <author>
      <name>Lunjin Lu</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Waikato</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">30 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/9811001v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/9811001v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2;D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/9811021v1</id>
    <updated>1998-11-12T09:49:57Z</updated>
    <published>1998-11-12T09:49:57Z</published>
    <title>Automatic Hardware Synthesis for a Hybrid Reconfigurable CPU Featuring
  Philips CPLDs</title>
    <summary>  A high-level architecture of a Hybrid Reconfigurable CPU, based on a
Philips-supported core processor, is introduced. It features the Philips XPLA2
CPLD as a reconfigurable functional unit. A compilation chain is presented, in
which automatic implementation of time-critical program segments in custom
hardware is performed. The entire process is transparent from the programmer's
point of view. The hardware synthesis module of the chain, which translates
segments of assembly code into a hardware netlist, is discussed in details.
Application examples are also presented.
</summary>
    <author>
      <name>Bernardo Kastrup</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages, 7 figures, PACT '98 Workshop on Reconfigurable Computing</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/9811021v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/9811021v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4; C.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0003010v1</id>
    <updated>2000-03-06T12:16:00Z</updated>
    <published>2000-03-06T12:16:00Z</published>
    <title>TSIA: A Dataflow Model</title>
    <summary>  The Task System and Item Architecture (TSIA) is a model for transparent
application execution. In many real-world projects, a TSIA provides a simple
application with a transparent reliable, distributed, heterogeneous, adaptive,
dynamic, real-time, parallel, secure or other execution. TSIA is suitable for
many applications, not just for the simple applications served to date. This
presentation shows that TSIA is a dataflow model - a long-standing model for
transparent parallel execution. The advances to the dataflow model include a
simple semantics, as well as support for input/output, for modifiable items and
for other such effects.
</summary>
    <author>
      <name>Burkhard D. Steinmacher-Burow</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0003010v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0003010v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2;D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0004011v1</id>
    <updated>2000-04-19T12:22:36Z</updated>
    <published>2000-04-19T12:22:36Z</published>
    <title>Task Frames</title>
    <summary>  Forty years ago Dijkstra introduced the current conventional execution of
routines. It places activation frames onto a stack. Each frame is the internal
state of an executing routine. The resulting application execution is not
easily helped by an external system. This presentation proposes an alternative
execution of routines. It places task frames onto the stack. A task frame is
the call of a routine to be executed. The feasibility of the alternative
execution is demonstrated by a crude implementation. As described elsewhere, an
application which executes in terms of tasks can be provided by an external
system with a transparent reliable, distributed, heterogeneous, adaptive,
dynamic, real-time, parallel, secure or other execution. By extending the crude
implementation, this presentation outlines a simple transparent parallel
execution.
</summary>
    <author>
      <name>Burkhard D. Steinmacher-Burow</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0004011v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0004011v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3;D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0005023v1</id>
    <updated>2000-05-19T10:19:51Z</updated>
    <published>2000-05-19T10:19:51Z</published>
    <title>C++ programming language for an abstract massively parallel SIMD
  architecture</title>
    <summary>  The aim of this work is to define and implement an extended C++ language to
support the SIMD programming paradigm. The C++ programming language has been
extended to express all the potentiality of an abstract SIMD machine consisting
of a central Control Processor and a N-dimensional toroidal array of Numeric
Processors. Very few extensions have been added to the standard C++ with the
goal of minimising the effort for the programmer in learning a new language and
to keep very high the performance of the compiled code. The proposed language
has been implemented as a porting of the GNU C++ Compiler on a SIMD
supercomputer.
</summary>
    <author>
      <name>Alessandro Lonardo</name>
    </author>
    <author>
      <name>Emanuele Panizzi</name>
    </author>
    <author>
      <name>Benedetto Proietti</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0005023v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0005023v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.2.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0009030v1</id>
    <updated>2000-09-29T20:29:41Z</updated>
    <published>2000-09-29T20:29:41Z</published>
    <title>From Syntactic Theories to Interpreters: A Specification Language and
  Its Compilation</title>
    <summary>  Recent years have seen an increasing need of high-level specification
languages and tools generating code from specifications. In this paper, we
introduce a specification language, {\splname}, which is tailored to the
writing of syntactic theories of language semantics. More specifically, the
language supports specifying primitive notions such as dynamic constraints,
contexts, axioms, and inference rules. We also introduce a system which
generates interpreters from {\splname} specifications. A prototype system is
implemented and has been tested on a number of examples, including a syntactic
theory for Verilog.
</summary>
    <author>
      <name>Yong Xiao</name>
    </author>
    <author>
      <name>Zena M. Ariola</name>
    </author>
    <author>
      <name>Michel Mauny</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted in Rule-based Programming Workshop, 2000, 16 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0009030v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0009030v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.1; D.1.2; D.3.1; F.3.1; F.3.2; I.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0010009v1</id>
    <updated>2000-10-03T17:00:42Z</updated>
    <published>2000-10-03T17:00:42Z</published>
    <title>An Approach to the Implementation of Overlapping Rules in Standard ML</title>
    <summary>  We describe an approach to programming rule-based systems in Standard ML,
with a focus on so-called overlapping rules, that is rules that can still be
active when other rules are fired. Such rules are useful when implementing
rule-based reactive systems, and to that effect we show a simple implementation
of Loyall's Active Behavior Trees, used to control goal-directed agents in the
Oz virtual environment. We discuss an implementation of our framework using a
reactive library geared towards implementing those kind of systems.
</summary>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">13 pages. Presented at RULE 2000, First International Workshop on
  Rule-Based Programming, Montreal, Canada</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0010009v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0010009v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0010016v1</id>
    <updated>2000-10-10T10:32:00Z</updated>
    <published>2000-10-10T10:32:00Z</published>
    <title>Towards rule-based visual programming of generic visual systems</title>
    <summary>  This paper illustrates how the diagram programming language DiaPlan can be
used to program visual systems. DiaPlan is a visual rule-based language that is
founded on the computational model of graph transformation. The language
supports object-oriented programming since its graphs are hierarchically
structured. Typing allows the shape of these graphs to be specified recursively
in order to increase program security. Thanks to its genericity, DiaPlan allows
to implement systems that represent and manipulate data in arbitrary diagram
notations. The environment for the language exploits the diagram editor
generator DiaGen for providing genericity, and for implementing its user
interface and type checker.
</summary>
    <author>
      <name>Berthold Hoffmann</name>
    </author>
    <author>
      <name>Mark Minas</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 16 figures contribution to the First International Workshop
  on Rule-Based Programming (RULE'2000), September 19, 2000, Montreal, Canada</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0010016v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0010016v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.7; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0101023v1</id>
    <updated>2001-01-23T13:35:27Z</updated>
    <published>2001-01-23T13:35:27Z</published>
    <title>Properties of Input-Consuming Derivations</title>
    <summary>  We study the properties of input-consuming derivations of moded logic
programs. Input-consuming derivations can be used to model the behavior of
logic programs using dynamic scheduling and employing constructs such as delay
declarations.
  We consider the class of nicely-moded programs and queries. We show that for
these programs a weak version of the well-known switching lemma holds also for
input-consuming derivations. Furthermore, we show that, under suitable
conditions, there exists an algebraic characterization of termination of
input-consuming derivations.
</summary>
    <author>
      <name>Annalisa Bossi</name>
    </author>
    <author>
      <name>Sandro Etalle</name>
    </author>
    <author>
      <name>Sabina Rossi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">33 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0101023v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0101023v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6;D.3.1;F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0105011v1</id>
    <updated>2001-05-07T12:56:11Z</updated>
    <published>2001-05-07T12:56:11Z</published>
    <title>Component Programming and Interoperability in Constraint Solver Design</title>
    <summary>  Prolog was once the main host for implementing constraint solvers.
  It seems that it is no longer so. To be useful, constraint solvers have to be
integrable into industrial applications written in imperative or
object-oriented languages; to be efficient, they have to interact with other
solvers. To meet these requirements, many solvers are now implemented in the
form of extensible object-oriented libraries. Following Pfister and Szyperski,
we argue that ``objects are not enough,'' and we propose to design solvers as
component-oriented libraries. We illustrate our approach by the description of
the architecture of a prototype, and we assess its strong points and
weaknesses.
</summary>
    <author>
      <name>Frederic Goualard</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages, 1 figure, paper accepted at the 6th Annual workshop of the
  ERCIM Working Group on Constraints</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0105011v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0105011v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0105024v1</id>
    <updated>2001-05-14T13:35:03Z</updated>
    <published>2001-05-14T13:35:03Z</published>
    <title>Constraint Propagation in Presence of Arrays</title>
    <summary>  We describe the use of array expressions as constraints, which represents a
consequent generalisation of the "element" constraint. Constraint propagation
for array constraints is studied theoretically, and for a set of domain
reduction rules the local consistency they enforce, arc-consistency, is proved.
An efficient algorithm is described that encapsulates the rule set and so
inherits the capability to enforce arc-consistency from the rules.
</summary>
    <author>
      <name>Sebastian Brand</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages. Accepted at the 6th Annual Workshop of the ERCIM Working
  Group on Constraints, 2001</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0105024v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0105024v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; E.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0106059v1</id>
    <updated>2001-06-29T08:41:02Z</updated>
    <published>2001-06-29T08:41:02Z</published>
    <title>CHR as grammar formalism. A first report</title>
    <summary>  Grammars written as Constraint Handling Rules (CHR) can be executed as
efficient and robust bottom-up parsers that provide a straightforward,
non-backtracking treatment of ambiguity. Abduction with integrity constraints
as well as other dynamic hypothesis generation techniques fit naturally into
such grammars and are exemplified for anaphora resolution, coordination and
text interpretation.
</summary>
    <author>
      <name>Henning Christiansen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages. Presented at ERCIM Workshop on Constraints, Prague, Czech
  Republic, June 18-20, 2001</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proc. of ERCIM Workshop on Constraints, Prague, Czech Republic,
  June 18-20, 2001</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0106059v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0106059v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.2.7;D.3.2;F.4.1;F.4.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0109003v1</id>
    <updated>2001-09-03T05:37:48Z</updated>
    <published>2001-09-03T05:37:48Z</published>
    <title>On the generalized dining philosophers problem</title>
    <summary>  We consider a generalization of the dining philosophers problem to arbitrary
connection topologies. We focus on symmetric, fully distributed systems, and we
address the problem of guaranteeing progress and lockout-freedom, even in
presence of adversary schedulers, by using randomized algorithms. We show that
the well-known algorithms of Lehmann and Rabin do not work in the generalized
case, and we propose an alternative algorithm based on the idea of letting the
philosophers assign a random priority to their adjacent forks.
</summary>
    <author>
      <name>Oltea Mihaela Herescu</name>
    </author>
    <author>
      <name>Catuscia Palamidessi</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proc. of the 20th ACM Symposium on Principles of Distributed
  Computing (PODC), pages 81-89, ACM, 2001</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0109003v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0109003v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.4.1;C.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0109024v1</id>
    <updated>2001-09-17T15:43:17Z</updated>
    <published>2001-09-17T15:43:17Z</published>
    <title>Verification of Timed Automata Using Rewrite Rules and Strategies</title>
    <summary>  ELAN is a powerful language and environment for specifying and prototyping
deduction systems in a language based on rewrite rules controlled by
strategies. Timed automata is a class of continuous real-time models of
reactive systems for which efficient model-checking algorithms have been
devised. In this paper, we show that these algorithms can very easily be
prototyped in the ELAN system. This paper argues through this example that
rewriting based systems relying on rules and strategies are a good framework to
prototype, study and test rather efficiently symbolic model-checking
algorithms, i.e. algorithms which involve combination of graph exploration
rules, deduction rules, constraint solving techniques and decision procedures.
</summary>
    <author>
      <name>Emmanuel Beffara</name>
    </author>
    <author>
      <name>Olivier Bournez</name>
    </author>
    <author>
      <name>Hassen Kacem</name>
    </author>
    <author>
      <name>Claude Kirchner</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0109024v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0109024v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.2.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0109060v1</id>
    <updated>2001-09-24T11:33:39Z</updated>
    <published>2001-09-24T11:33:39Z</published>
    <title>Branching: the Essence of Constraint Solving</title>
    <summary>  This paper focuses on the branching process for solving any constraint
satisfaction problem (CSP). A parametrised schema is proposed that (with
suitable instantiations of the parameters) can solve CSP's on both finite and
infinite domains. The paper presents a formal specification of the schema and a
statement of a number of interesting properties that, subject to certain
conditions, are satisfied by any instances of the schema.
  It is also shown that the operational procedures of many constraint systems
including cooperative systems) satisfy these conditions.
  Moreover, the schema is also used to solve the same CSP in different ways by
means of different instantiations of its parameters.
</summary>
    <author>
      <name>Antonio J. Fernandez</name>
    </author>
    <author>
      <name>Patricia M. Hill</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">18 pages, 2 figures, Proceedings ERCIM Workshop on Constraints
  (Prague, June 2001)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0109060v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0109060v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0110007v1</id>
    <updated>2001-10-02T14:10:58Z</updated>
    <published>2001-10-02T14:10:58Z</published>
    <title>Variable and Value Ordering When Solving Balanced Academic Curriculum
  Problems</title>
    <summary>  In this paper we present the use of Constraint Programming for solving
balanced academic curriculum problems. We discuss the important role that
heuristics play when solving a problem using a constraint-based approach. We
also show how constraint solving techniques allow to very efficiently solve
combinatorial optimization problems that are too hard for integer programming
techniques.
</summary>
    <author>
      <name>Carlos Castro</name>
    </author>
    <author>
      <name>Sebastian Manzano</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 4 figures</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of 6th Workshop of the ERCIM WG on Constraints
  (Prague, June 2001)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0110007v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0110007v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0111042v2</id>
    <updated>2001-11-22T17:19:32Z</updated>
    <published>2001-11-16T14:40:57Z</published>
    <title>Proceedings of the Eleventh Workshop on Logic Programming Environments
  (WLPE'01)</title>
    <summary>  The Eleventh Workshop on Logic Programming Environments (WLPE'01) was one in
a series of international workshops in the topic area. It was held on December
1, 2001 in Paphos, Cyprus as a post-conference workshop at ICLP 2001. Eight
refereed papers were presented at the conference. A majority of the papers
involved, in some way, constraint logic programming and tools for software
development. Other topics areas addressed include execution visualization,
instructional aids (for learning users), software maintenance (including
debugging), and provisions for new paradigms.
</summary>
    <author>
      <name>Anthony Kusalik</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 refereed papers; Anthony Kusalik, editor; 11WLPE, WLPE 2001</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0111042v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0111042v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.2.5; D.2.6; F.4.1; I.2.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0203001v1</id>
    <updated>2002-03-01T11:58:56Z</updated>
    <published>2002-03-01T11:58:56Z</published>
    <title>Towards Generic Refactoring</title>
    <summary>  We study program refactoring while considering the language or even the
programming paradigm as a parameter. We use typed functional programs, namely
Haskell programs, as the specification medium for a corresponding refactoring
framework. In order to detach ourselves from language syntax, our
specifications adhere to the following style. (I) As for primitive algorithms
for program analysis and transformation, we employ generic function combinators
supporting generic traversal and polymorphic functions refined by ad-hoc cases.
(II) As for the language abstractions involved in refactorings, we design a
dedicated multi-parameter class. This class can be instantiated for
abstractions as present in various languages, e.g., Java, Prolog or Haskell.
</summary>
    <author>
      <name>Ralf Laemmel</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0203001v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0203001v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.1.2; D.2.1; D.2.3; D.2.13; D.3.1; I.1.1; I.1.2; I.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0203022v1</id>
    <updated>2002-03-18T13:22:30Z</updated>
    <published>2002-03-18T13:22:30Z</published>
    <title>Three Optimisations for Sharing</title>
    <summary>  In order to improve precision and efficiency sharing analysis should track
both freeness and linearity. The abstract unification algorithms for these
combined domains are suboptimal, hence there is scope for improving precision.
This paper proposes three optimisations for tracing sharing in combination with
freeness and linearity. A novel connection between equations and sharing
abstractions is used to establish correctness of these optimisations even in
the presence of rational trees. A method for pruning intermediate sharing
abstractions to improve efficiency is also proposed. The optimisations are
lightweight and therefore some, if not all, of these optimisations will be of
interest to the implementor.
</summary>
    <author>
      <name>Jacob M. Howe</name>
    </author>
    <author>
      <name>Andy King</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Theiry and Practice of Logic Programming</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0203022v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0203022v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; f.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0204015v1</id>
    <updated>2002-04-09T12:44:43Z</updated>
    <published>2002-04-09T12:44:43Z</published>
    <title>Design Patterns for Functional Strategic Programming</title>
    <summary>  In previous work, we introduced the fundamentals and a supporting combinator
library for \emph{strategic programming}. This an idiom for generic programming
based on the notion of a \emph{functional strategy}: a first-class generic
function that cannot only be applied to terms of any type, but which also
allows generic traversal into subterms and can be customized with type-specific
behaviour.
  This paper seeks to provide practicing functional programmers with pragmatic
guidance in crafting their own strategic programs. We present the fundamentals
and the support from a user's perspective, and we initiate a catalogue of
\emph{strategy design patterns}. These design patterns aim at consolidating
strategic programming expertise in accessible form.
</summary>
    <author>
      <name>Ralf Laemmel</name>
    </author>
    <author>
      <name>Joost Visser</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0204015v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0204015v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.2.3; D.2.10" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0204018v3</id>
    <updated>2003-02-24T12:30:59Z</updated>
    <published>2002-04-09T18:32:40Z</published>
    <title>A Framework for Datatype Transformation</title>
    <summary>  We study one dimension in program evolution, namely the evolution of the
datatype declarations in a program. To this end, a suite of basic
transformation operators is designed. We cover structure-preserving
refactorings, but also structure-extending and -reducing adaptations. Both the
object programs that are subject to datatype transformations, and the meta
programs that encode datatype transformations are functional programs.
</summary>
    <author>
      <name>Jan Kort</name>
    </author>
    <author>
      <name>Ralf Laemmel</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Minor revision; now accepted at LDTA 2003</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0204018v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0204018v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.2.3; D.2.6; D.2.7; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0302004v1</id>
    <updated>2003-02-03T15:52:17Z</updated>
    <published>2003-02-03T15:52:17Z</published>
    <title>Unique Pattern Matching in Strings</title>
    <summary>  Regular expression patterns are a key feature of document processing
languages like Perl and XDuce. It is in this context that the first and longest
match policies have been proposed to disambiguate the pattern matching process.
We formally define a matching semantics with these policies and show that the
generally accepted method of simulating longest match by first match and
recursion is incorrect. We continue by solving the associated type inference
problem, which consists in calculating for every subexpression the set of words
the subexpression can still match when these policies are in effect, and show
how this algorithm can be used to efficiently implement the matching process.
</summary>
    <author>
      <name>Stijn Vansummeren</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">22 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0302004v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0302004v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; F.1.1; H.2.3; H.3.3; H.2.4; I.5.5" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0312023v1</id>
    <updated>2003-12-12T16:14:20Z</updated>
    <published>2003-12-12T16:14:20Z</published>
    <title>Inferring Termination Conditions for Logic Programs using Backwards
  Analysis</title>
    <summary>  This paper focuses on the inference of modes for which a logic program is
guaranteed to terminate. This generalises traditional termination analysis
where an analyser tries to verify termination for a specified mode. Our
contribution is a methodology in which components of traditional termination
analysis are combined with backwards analysis to obtain an analyser for
termination inference. We identify a condition on the components of the
analyser which guarantees that termination inference will infer all modes which
can be checked to terminate. The application of this methodology to enhance a
traditional termination analyser to perform also termination inference is
demonstrated.
</summary>
    <author>
      <name>Samir Genaim</name>
    </author>
    <author>
      <name>Michael Codish</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0312023v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0312023v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6,F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0312027v1</id>
    <updated>2003-12-15T13:43:37Z</updated>
    <published>2003-12-15T13:43:37Z</published>
    <title>An Open Ended Tree</title>
    <summary>  An open ended list is a well known data structure in Prolog programs. It is
frequently used to represent a value changing over time, while this value is
referred to from several places in the data structure of the application. A
weak point in this technique is that the time complexity is linear in the
number of updates to the value represented by the open ended list. In this
programming pearl we present a variant of the open ended list, namely an open
ended tree, with an update and access time complexity logarithmic in the number
of updates to the value.
</summary>
    <author>
      <name>Henk Vandecasteele</name>
    </author>
    <author>
      <name>Gerda Janssens</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">TPLP Vol 3(3) 2003 pp 377-385</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0312027v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0312027v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6;D.3.3;.E.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0402048v1</id>
    <updated>2004-02-20T14:09:02Z</updated>
    <published>2004-02-20T14:09:02Z</published>
    <title>Transformation Rules for Locally Stratified Constraint Logic Programs</title>
    <summary>  We propose a set of transformation rules for constraint logic programs with
negation. We assume that every program is locally stratified and, thus, it has
a unique perfect model. We give sufficient conditions which ensure that the
proposed set of transformation rules preserves the perfect model of the
programs. Our rules extend in some respects the rules for logic programs and
constraint logic programs already considered in the literature and, in
particular, they include a rule for unfolding a clause with respect to a
negative literal.
</summary>
    <author>
      <name>Fabio Fioravanti</name>
    </author>
    <author>
      <name>Alberto Pettorossi</name>
    </author>
    <author>
      <name>Maurizio Proietti</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in: M. Bruynooghe, K.-K. Lau (Eds.) Program Development in
  Computational Logic, Lecture Notes in Computer Science, Springer</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0402048v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0402048v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.2;D.1.6;I.2.2;F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0403016v1</id>
    <updated>2004-03-12T08:37:54Z</updated>
    <published>2004-03-12T08:37:54Z</published>
    <title>A Comparative Study of Arithmetic Constraints on Integer Intervals</title>
    <summary>  We propose here a number of approaches to implement constraint propagation
for arithmetic constraints on integer intervals. To this end we introduce
integer interval arithmetic. Each approach is explained using appropriate proof
rules that reduce the variable domains. We compare these approaches using a set
of benchmarks.
</summary>
    <author>
      <name>Krzysztof R. Apt</name>
    </author>
    <author>
      <name>Peter Zoeteweij</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">24 pages. To appear in "Recent Advances in Constraints, 2003" K.R.
  Apt, F. Fages, F. Rossi, P. Szeredi and J. Vancza, eds, LNAI 3010,
  Springer-Verlag, 2004</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0403016v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0403016v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0404052v1</id>
    <updated>2004-04-25T03:49:44Z</updated>
    <published>2004-04-25T03:49:44Z</published>
    <title>Multi-Threading And Message Communication In Qu-Prolog</title>
    <summary>  This paper presents the multi-threading and internet message communication
capabilities of Qu-Prolog. Message addresses are symbolic and the
communications package provides high-level support that completely hides
details of IP addresses and port numbers as well as the underlying TCP/IP
transport layer. The combination of the multi-threads and the high level
inter-thread message communications provide simple, powerful support for
implementing internet distributed intelligent applications.
</summary>
    <author>
      <name>Keith L. Clark</name>
    </author>
    <author>
      <name>Peter J. Robinson</name>
    </author>
    <author>
      <name>Richard Hagen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in Theory and Practice of Logic Programming, vol. 1, no. 3,
  2001</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, vol. 1, no. 3, 2001</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0404052v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0404052v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0405079v1</id>
    <updated>2004-05-23T18:56:57Z</updated>
    <published>2004-05-23T18:56:57Z</published>
    <title>Higher-Order Concurrent Win32 Programming</title>
    <summary>  We present a concurrent framework for Win32 programming based on Concurrent
ML, a concurrent language with higher-order functions, static typing,
lightweight threads and synchronous communication channels. The key points of
the framework are the move from an event loop model to a threaded model for the
processing of window messages, and the decoupling of controls notifications
from the system messages. This last point allows us to derive a general way of
writing controls that leads to easy composition, and can accommodate ActiveX
Controls in a transparent way.
</summary>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages; appeared in Proceedings of the 3rd Usenix Windows NT
  Symposium, Seattle, pp. 113-122, 1999</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0405079v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0405079v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1;D.3.3;H.5.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0405080v1</id>
    <updated>2004-05-23T19:09:11Z</updated>
    <published>2004-05-23T19:09:11Z</published>
    <title>Reactive Programming in Standard ML</title>
    <summary>  Reactive systems are systems that maintain an ongoing interaction with their
environment, activated by receiving input events from the environment and
producing output events in response. Modern programming languages designed to
program such systems use a paradigm based on the notions of instants and
activations. We describe a library for Standard ML that provides basic
primitives for programming reactive systems. The library is a low-level system
upon which more sophisticated reactive behaviors can be built, which provides a
convenient framework for prototyping extensions to existing reactive languages.
</summary>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1109/ICCL.1998.674156</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1109/ICCL.1998.674156" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages; appeared in Proceedings of the IEEE International
  Conference on Computer Languages (ICCL'98), pp. 48-57, 1998</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0405080v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0405080v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1;D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0405082v1</id>
    <updated>2004-05-23T19:35:49Z</updated>
    <published>2004-05-23T19:35:49Z</published>
    <title>Aspects de la Programmation d'Applications Win32 avec un Langage
  Fonctionnel</title>
    <summary>  A useful programming language needs to support writing programs that take
advantage of services and communication mechanisms supplied by the operating
system. We examine the problem of programming native Win32 applications under
Windows with Standard ML. We introduce an framework based on the IDL interface
language et a minimal foreign-functions interface to explore the Win32 API et
COM in the context of Standard ML.
</summary>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <author>
      <name>Erik Meijer</name>
    </author>
    <author>
      <name>Dino Oliva</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In french, 25 pages, 3 figures. Appeared in the Proceedings of the
  "Journees Francophones des Langages Applicatifs" (JFLA'99), 1999</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0405082v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0405082v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1;D.3.3;H.5.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0405083v1</id>
    <updated>2004-05-23T19:51:01Z</updated>
    <published>2004-05-23T19:51:01Z</published>
    <title>The Design of a COM-Oriented Module System</title>
    <summary>  We present in this paper the preliminary design of a module system based on a
notion of components such as they are found in COM. This module system is
inspired from that of Standard ML, and features first-class instances of
components, first-class interfaces, and interface-polymorphic functions, as
well as allowing components to be both imported from the environment and
exported to the environment using simple mechanisms. The module system
automates the memory management of interfaces and hides the IUnknown interface
and QueryInterface mechanisms from the programmer, favoring instead a
higher-level approach to handling interfaces.
</summary>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages; appeared in Proceedings of the Joint Modular Languages
  Conference (JMLC'00). LNCS 1897, pp. 104-118, 2000</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0405083v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0405083v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.2;D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0405085v1</id>
    <updated>2004-05-24T05:16:33Z</updated>
    <published>2004-05-24T05:16:33Z</published>
    <title>On the Expressive Power of First-Order Boolean Functions in PCF</title>
    <summary>  Recent results of Bucciarelli show that the semilattice of degrees of
parallelism of first-order boolean functions in PCF has both infinite chains
and infinite antichains. By considering a simple subclass of Sieber's
sequentiality relations, we identify levels in the semilattice and derive
inexpressibility results concerning functions on different levels. This allows
us to further explore the structure of the semilattice of degrees of
parallelism: we identify semilattices characterized by simple level properties,
and show the existence of new infinite hierarchies which are in a certain sense
natural with respect to the levels.
</summary>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <author>
      <name>Prakash Panangaden</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">23 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theoretical Computer Science 266(1-2), pp. 543-567, 2001</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0405085v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0405085v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0405102v1</id>
    <updated>2004-05-27T03:08:30Z</updated>
    <published>2004-05-27T03:08:30Z</published>
    <title>A Proof Theoretic Approach to Failure in Functional Logic Programming</title>
    <summary>  How to extract negative information from programs is an important issue in
logic programming. Here we address the problem for functional logic programs,
from a proof-theoretic perspective. The starting point of our work is CRWL
(Constructor based ReWriting Logic), a well established theoretical framework
for functional logic programming, whose fundamental notion is that of
non-strict non-deterministic function. We present a proof calculus, CRWLF,
which is able to deduce negative information from CRWL-programs. In particular,
CRWLF is able to prove finite failure of reduction within CRWL.
</summary>
    <author>
      <name>Francisco Javier Lopez-Fraguas</name>
    </author>
    <author>
      <name>Jaime Sanchez-Hernandez</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in Theory and Practice of Logic Programming, vol. 4, no.
  1&amp;2, 2004</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, vol. 4, no. 1&amp;2, 2004</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0405102v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0405102v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0406012v1</id>
    <updated>2004-06-07T07:01:53Z</updated>
    <published>2004-06-07T07:01:53Z</published>
    <title>Secure Prolog-Based Mobile Code</title>
    <summary>  LogicWeb mobile code consists of Prolog-like rules embedded in Web pages,
thereby adding logic programming behaviour to those pages. Since LogicWeb
programs are downloaded from foreign hosts and executed locally, there is a
need to protect the client from buggy or malicious code. A security model is
crucial for making LogicWeb mobile code safe to execute. This paper presents
such a model, which supports programs of varying trust levels by using
different resource access policies. The implementation of the model derives
from an extended operational semantics for the LogicWeb language, which
provides a precise meaning of safety.
</summary>
    <author>
      <name>Seng Wai Loke</name>
    </author>
    <author>
      <name>Andrew Davison</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in Theory and Practice of Logic Programming, vol. 1, no. 3,
  2001</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, vol. 1, no. 3, 2001</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0406012v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0406012v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0406014v1</id>
    <updated>2004-06-07T14:04:48Z</updated>
    <published>2004-06-07T14:04:48Z</published>
    <title>O(1) Reversible Tree Navigation Without Cycles</title>
    <summary>  Imperative programmers often use cyclically linked trees in order to achieve
O(1) navigation time to neighbours. Some logic programmers believe that cyclic
terms are necessary to achieve the same in logic-based languages. An old but
little-known technique provides O(1) time and space navigation without cyclic
links, in the form of reversible predicates. A small modification provides O(1)
amortised time and space editing.
</summary>
    <author>
      <name>Richard A. O'Keefe</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in Theory and Practice of Logic Programming, vol. 1, no. 5,
  2001</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, vol. 1, no. 5, 2001</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0406014v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0406014v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0407043v1</id>
    <updated>2004-07-16T14:44:21Z</updated>
    <published>2004-07-16T14:44:21Z</published>
    <title>A Hyper-Arc Consistency Algorithm for the Soft Alldifferent Constraint</title>
    <summary>  This paper presents an algorithm that achieves hyper-arc consistency for the
soft alldifferent constraint. To this end, we prove and exploit the equivalence
with a minimum-cost flow problem. Consistency of the constraint can be checked
in O(nm) time, and hyper-arc consistency is achieved in O(m) time, where n is
the number of variables involved and m is the sum of the cardinalities of the
domains. It improves a previous method that did not ensure hyper-arc
consistency.
</summary>
    <author>
      <name>Willem Jan van Hoeve</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages, 1 figure</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0407043v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0407043v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2; D.3.3; G.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0409009v1</id>
    <updated>2004-09-07T09:44:18Z</updated>
    <published>2004-09-07T09:44:18Z</published>
    <title>CrocoPat 2.1 Introduction and Reference Manual</title>
    <summary>  CrocoPat is an efficient, powerful and easy-to-use tool for manipulating
relations of arbitrary arity, including directed graphs. This manual provides
an introduction to and a reference for CrocoPat and its programming language
RML. It includes several application examples, in particular from the analysis
of structural models of software systems.
</summary>
    <author>
      <name>Dirk Beyer</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of California, Berkeley</arxiv:affiliation>
    </author>
    <author>
      <name>Andreas Noack</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Brandenburg University of Technology</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">19 pages + cover, 2 eps figures, uses llncs.cls and
  cs_techrpt_cover.sty, for downloading the source code, binaries, and RML
  examples, see http://www.software-systemtechnik.de/CrocoPat/</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0409009v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0409009v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DM" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; G.2.2.a; E.1.d; D.2.7m" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0501073v1</id>
    <updated>2005-01-25T13:28:38Z</updated>
    <published>2005-01-25T13:28:38Z</published>
    <title>Optimal Union-Find in Constraint Handling Rules</title>
    <summary>  Constraint Handling Rules (CHR) is a committed-choice rule-based language
that was originally intended for writing constraint solvers. In this paper we
show that it is also possible to write the classic union-find algorithm and
variants in CHR. The programs neither compromise in declarativeness nor
efficiency. We study the time complexity of our programs: they match the
almost-linear complexity of the best known imperative implementations. This
fact is illustrated with experimental results.
</summary>
    <author>
      <name>Tom Schrijvers</name>
    </author>
    <author>
      <name>Thom Fruehwirth</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 3 figures, to appear in Theory and Practice of Logic
  Programming (TPLP)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0501073v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0501073v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0504008v10</id>
    <updated>2009-08-25T15:36:19Z</updated>
    <published>2005-04-04T06:19:43Z</published>
    <title>Super Object Oriented Programming</title>
    <summary>  This submission has been withdrawn at the request of the author.
</summary>
    <author>
      <name>Raju Renjit. G</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0504008v10" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0504008v10" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0504025v15</id>
    <updated>2009-08-25T15:34:49Z</updated>
    <published>2005-04-07T13:21:15Z</published>
    <title>Incorporating LINQ, State Diagrams Templating and Package Extension Into
  Java</title>
    <summary>  This submission has been withdrawn at the request of the author.
</summary>
    <author>
      <name>Raju Renjit. G</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0504025v15" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0504025v15" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0506035v1</id>
    <updated>2005-06-10T15:28:00Z</updated>
    <published>2005-06-10T15:28:00Z</published>
    <title>Fast Recompilation of Object Oriented Modules</title>
    <summary>  Once a program file is modified, the recompilation time should be minimized,
without sacrificing execution speed or high level object oriented features. The
recompilation time is often a problem for the large graphical interactive
distributed applications tackled by modern OO languages. A compilation server
and fast code generator were developed and integrated with the SRC Modula-3
compiler and Linux ELF dynamic linker. The resulting compilation and
recompilation speedups are impressive. The impact of different language
features, processor speed, and application size are discussed.
</summary>
    <author>
      <name>Jerome Collin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Computer Engineering, Ecole Polytechnique de Montreal</arxiv:affiliation>
    </author>
    <author>
      <name>Michel Dagenais</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Computer Engineering, Ecole Polytechnique de Montreal</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/cs/0506035v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0506035v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0507036v1</id>
    <updated>2005-07-14T08:47:45Z</updated>
    <published>2005-07-14T08:47:45Z</published>
    <title>Improved Inference for Checking Annotations</title>
    <summary>  We consider type inference in the Hindley/Milner system extended with type
annotations and constraints with a particular focus on Haskell-style type
classes. We observe that standard inference algorithms are incomplete in the
presence of nested type annotations. To improve the situation we introduce a
novel inference scheme for checking type annotations. Our inference scheme is
also incomplete in general but improves over existing implementations as found
e.g. in the Glasgow Haskell Compiler (GHC). For certain cases (e.g. Haskell 98)
our inference scheme is complete. Our approach has been fully implemented as
part of the Chameleon system (experimental version of Haskell).
</summary>
    <author>
      <name>Peter J Stuckey</name>
    </author>
    <author>
      <name>Martin Sulzmann</name>
    </author>
    <author>
      <name>Jeremy Wazny</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0507036v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0507036v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0507037v1</id>
    <updated>2005-07-14T08:58:31Z</updated>
    <published>2005-07-14T08:58:31Z</published>
    <title>Type Inference for Guarded Recursive Data Types</title>
    <summary>  We consider type inference for guarded recursive data types (GRDTs) -- a
recent generalization of algebraic data types. We reduce type inference for
GRDTs to unification under a mixed prefix. Thus, we obtain efficient type
inference. Inference is incomplete because the set of type constraints allowed
to appear in the type system is only a subset of those type constraints
generated by type inference. Hence, inference only succeeds if the program is
sufficiently type annotated. We present refined procedures to infer types
incrementally and to assist the user in identifying which pieces of type
information are missing. Additionally, we introduce procedures to test if a
type is not principal and to find a principal type if one exists.
</summary>
    <author>
      <name>Peter J. Stuckey</name>
    </author>
    <author>
      <name>Martin Sulzmann</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0507037v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0507037v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0507043v3</id>
    <updated>2006-03-16T08:24:17Z</updated>
    <published>2005-07-18T13:06:13Z</published>
    <title>Proof rules for purely quantum programs</title>
    <summary>  We apply the notion of quantum predicate proposed by D'Hondt and Panangaden
to analyze a purely quantum language fragment which describes the quantum part
of a future quantum computer in Knill's architecture. The denotational
semantics, weakest precondition semantics, and weakest liberal precondition
semantics of this language fragment are introduced. To help reasoning about
quantum programs involving quantum loops, we extend proof rules for classical
probabilistic programs to our purely quantum programs.
</summary>
    <author>
      <name>Yuan Feng</name>
    </author>
    <author>
      <name>Runyao Duan</name>
    </author>
    <author>
      <name>Zhengfeng Ji</name>
    </author>
    <author>
      <name>Mingsheng Ying</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Now 12 pages, introduction and Section 3 rewritten, some errors
  corrected</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0507043v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0507043v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0509057v1</id>
    <updated>2005-09-19T15:30:10Z</updated>
    <published>2005-09-19T15:30:10Z</published>
    <title>Language embeddings that preserve staging and safety</title>
    <summary>  We study embeddings of programming languages into one another that preserve
what reductions take place at compile-time, i.e., staging. A certain condition
-- what we call a `Turing complete kernel' -- is sufficient for a language to
be stage-universal in the sense that any language may be embedded in it while
preserving staging. A similar line of reasoning yields the notion of
safety-preserving embeddings, and a useful characterization of
safety-universality. Languages universal with respect to staging and safety are
good candidates for realizing domain-specific embedded languages (DSELs) and
`active libraries' that provide domain-specific optimizations and safety
checks.
</summary>
    <author>
      <name>Todd L. Veldhuizen</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0509057v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0509057v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0510074v1</id>
    <updated>2005-10-24T16:27:00Z</updated>
    <published>2005-10-24T16:27:00Z</published>
    <title>Practical Datatype Specializations with Phantom Types and Recursion
  Schemes</title>
    <summary>  Datatype specialization is a form of subtyping that captures program
invariants on data structures that are expressed using the convenient and
intuitive datatype notation. Of particular interest are structural invariants
such as well-formedness. We investigate the use of phantom types for describing
datatype specializations. We show that it is possible to express
statically-checked specializations within the type system of Standard ML. We
also show that this can be done in a way that does not lose useful programming
facilities such as pattern matching in case expressions.
</summary>
    <author>
      <name>Matthew Fluet</name>
    </author>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">25 pages. Appeared in the Proc. of the 2005 ACM SIGPLAN Workshop on
  ML</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0510074v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0510074v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.3.3; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0511090v2</id>
    <updated>2006-01-14T15:48:00Z</updated>
    <published>2005-11-27T14:58:22Z</published>
    <title>Integration of Declarative and Constraint Programming</title>
    <summary>  Combining a set of existing constraint solvers into an integrated system of
cooperating solvers is a useful and economic principle to solve hybrid
constraint problems. In this paper we show that this approach can also be used
to integrate different language paradigms into a unified framework.
Furthermore, we study the syntactic, semantic and operational impacts of this
idea for the amalgamation of declarative and constraint programming.
</summary>
    <author>
      <name>Petra Hofstedt</name>
    </author>
    <author>
      <name>Peter Pepper</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">30 pages, 9 figures, To appear in Theory and Practice of Logic
  Programming (TPLP)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0511090v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0511090v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0601019v2</id>
    <updated>2006-11-21T13:02:37Z</updated>
    <published>2006-01-06T19:50:29Z</published>
    <title>Canonical Abstract Syntax Trees</title>
    <summary>  This paper presents Gom, a language for describing abstract syntax trees and
generating a Java implementation for those trees. Gom includes features
allowing the user to specify and modify the interface of the data structure.
These features provide in particular the capability to maintain the internal
representation of data in canonical form with respect to a rewrite system. This
explicitly guarantees that the client program only manipulates normal forms for
this rewrite system, a feature which is only implicitly used in many
implementations.
</summary>
    <author>
      <name>Antoine Reilles</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Lorraine - LORIA</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Dans Workshop on Rewriting Techniques and Applications (2006)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0601019v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0601019v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0602027v1</id>
    <updated>2006-02-07T15:19:53Z</updated>
    <published>2006-02-07T15:19:53Z</published>
    <title>Explaining Constraint Programming</title>
    <summary>  We discuss here constraint programming (CP) by using a proof-theoretic
perspective. To this end we identify three levels of abstraction. Each level
sheds light on the essence of CP.
  In particular, the highest level allows us to bring CP closer to the
computation as deduction paradigm. At the middle level we can explain various
constraint propagation algorithms. Finally, at the lowest level we can address
the issue of automatic generation and optimization of the constraint
propagation algorithms.
</summary>
    <author>
      <name>Krzysztof R. Apt</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, appeared in "Processes, Terms and Cycles: Steps on the Road
  to Infinity", (A. Middeldorp, V. van Oostrom, F. van Raamsdonk, R. de Vrijer,
  eds.), LNCS 3838, pp. 55-69. (2005)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0602027v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0602027v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0603100v1</id>
    <updated>2006-03-26T20:27:40Z</updated>
    <published>2006-03-26T20:27:40Z</published>
    <title>Efficient Compression of Prolog Programs</title>
    <summary>  We propose a special-purpose class of compression algorithms for efficient
compression of Prolog programs. It is a dictionary-based compression method,
specially designed for the compression of Prolog code, and therefore we name it
PCA (Prolog Compression Algorithm). According to the experimental results this
method provides better compression than state-of-the-art general-purpose
compression algorithms. Since the algorithm works with Prolog syntactic
entities (e.g. atoms, terms, etc.) the implementation of a Prolog prototype is
straightforward and very easy to use in any Prolog application that needs
compression. Although the algorithm is designed for Prolog programs, the idea
can be easily applied for the compression of programs written in other (logic)
languages.
</summary>
    <author>
      <name>Alin Suciu</name>
    </author>
    <author>
      <name>Kalman Pusztai</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0603100v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0603100v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0606102v3</id>
    <updated>2011-02-18T00:41:26Z</updated>
    <published>2006-06-24T18:51:54Z</published>
    <title>Toward Functionality Oriented Programming</title>
    <summary>  The concept of functionality oriented programming is proposed, and some of
its aspects are discussed, such as: (1) implementation independent basic types
and generic collection types; (2) syntax requirements and recommendations for
implementation independence; (3) unified documentation and code; (4)
cross-module interface; and (5) cross-language program making scheme. A
prototype example is given to demonstrate functionality oriented programming.
</summary>
    <author>
      <name>Chengpu Wang</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This paper has been withdrawn by the author. 21 Pages, 7 Figures</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0606102v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0606102v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.HC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0607016v2</id>
    <updated>2007-03-21T13:51:00Z</updated>
    <published>2006-07-06T10:09:43Z</published>
    <title>An Analysis of Arithmetic Constraints on Integer Intervals</title>
    <summary>  Arithmetic constraints on integer intervals are supported in many constraint
programming systems. We study here a number of approaches to implement
constraint propagation for these constraints. To describe them we introduce
integer interval arithmetic. Each approach is explained using appropriate proof
rules that reduce the variable domains. We compare these approaches using a set
of benchmarks. For the most promising approach we provide results that
characterize the effect of constraint propagation. This is a full version of
our earlier paper, cs.PL/0403016.
</summary>
    <author>
      <name>Krzysztof R. Apt</name>
    </author>
    <author>
      <name>Peter Zoeteweij</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">44 pages, to appear in 'Constraints' journal</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0607016v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0607016v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0608015v1</id>
    <updated>2006-08-03T02:41:20Z</updated>
    <published>2006-08-03T02:41:20Z</published>
    <title>Towards "Propagation = Logic + Control"</title>
    <summary>  Constraint propagation algorithms implement logical inference. For
efficiency, it is essential to control whether and in what order basic
inference steps are taken. We provide a high-level framework that clearly
differentiates between information needed for controlling propagation versus
that needed for the logical semantics of complex constraints composed from
primitive ones. We argue for the appropriateness of our controlled propagation
framework by showing that it captures the underlying principles of manually
designed propagation algorithms, such as literal watching for unit clause
propagation and the lexicographic ordering constraint. We provide an
implementation and benchmark results that demonstrate the practicality and
efficiency of our framework.
</summary>
    <author>
      <name>Sebastian Brand</name>
    </author>
    <author>
      <name>Roland H. C. Yap</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages; 22nd International Conference on Logic Programming
  (ICLP'06)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0608015v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0608015v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0609092v1</id>
    <updated>2006-09-16T12:22:15Z</updated>
    <published>2006-09-16T12:22:15Z</published>
    <title>Analysis of Equality Relationships for Imperative Programs</title>
    <summary>  In this article, we discuss a flow--sensitive analysis of equality
relationships for imperative programs. We describe its semantic domains,
general purpose operations over abstract computational states (term evaluation
and identification, semantic completion, widening operator, etc.) and semantic
transformers corresponding to program constructs. We summarize our experiences
from the last few years concerning this analysis and give attention to
applications of analysis of automatically generated code. Among other
illustrating examples, we consider a program for which the analysis diverges
without a widening operator and results of analyzing residual programs produced
by some automatic partial evaluator. An example of analysis of a program
generated by this evaluator is given.
</summary>
    <author>
      <name>P. Emelyanov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">31 pages, 10 figures, 2 tables, 1 appendix</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0609092v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0609092v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0610164v2</id>
    <updated>2006-10-31T09:09:11Z</updated>
    <published>2006-10-30T08:39:04Z</published>
    <title>Complexity of Data Flow Analysis for Non-Separable Frameworks</title>
    <summary>  The complexity of round robin method of intraprocedural data flow analysis is
measured in number of iterations over the control flow graph. Existing
complexity bounds realistically explain the complexity of only Bit-vector
frameworks which are separable. In this paper we define the complexity bounds
for non-separable frameworks by quantifying the interdependences among the data
flow information of program entities using an Entity Dependence Graph.
</summary>
    <author>
      <name>Bageshri Karkare</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Sathe</arxiv:affiliation>
    </author>
    <author>
      <name>Uday Khedker</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Published in the International Conference on Programming Languages
  and Compilers (PLC) 2006, Las Vegas, U.S.A</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0610164v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0610164v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701081v1</id>
    <updated>2007-01-12T15:39:29Z</updated>
    <published>2007-01-12T15:39:29Z</published>
    <title>Fingerprinting Logic Programs</title>
    <summary>  In this work we present work in progress on functionality duplication
detection in logic programs. Eliminating duplicated functionality recently
became prominent in context of refactoring. We describe a quantitative approach
that allows to measure the ``similarity'' between two predicate definitions.
Moreover, we show how to compute a so-called ``fingerprint'' for every
predicate. Fingerprints capture those characteristics of the predicate that are
significant when searching for duplicated functionality. Since reasoning on
fingerprints is much easier than reasoning on predicate definitions, comparing
the fingerprints is a promising direction in automated code duplication in
logic programs.
</summary>
    <author>
      <name>Alexander Serebrenik</name>
    </author>
    <author>
      <name>Wim Vanhoof</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 16th Workshop on Logic-based methods in
  Programming Languages (WLPE2006)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0701081v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701081v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701147v1</id>
    <updated>2007-01-24T06:55:34Z</updated>
    <published>2007-01-24T06:55:34Z</published>
    <title>A Generic Analysis Environment for Curry Programs</title>
    <summary>  We present CurryBrowser, a generic analysis environment for the declarative
multi-paradigm language Curry. CurryBrowser supports browsing through the
program code of an application written in Curry, i.e., the main module and all
directly or indirectly imported modules. Each module can be shown in different
formats (e.g., source code, interface, intermediate code) and, inside each
module, various properties of functions defined in this module can be analyzed.
In order to support the integration of various program analyses, CurryBrowser
has a generic interface to connect local and global analyses implemented in
Curry. CurryBrowser is completely implemented in Curry using libraries for GUI
programming and meta-programming.
</summary>
    <author>
      <name>Michael Hanus</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 16th Workshop on Logic-based Methods in
  Programming Environments</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0701147v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701147v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701192v5</id>
    <updated>2008-05-22T09:35:12Z</updated>
    <published>2007-01-30T16:26:50Z</published>
    <title>The pitfalls of verifying floating-point computations</title>
    <summary>  Current critical systems commonly use a lot of floating-point computations,
and thus the testing or static analysis of programs containing floating-point
operators has become a priority. However, correctly defining the semantics of
common implementations of floating-point is tricky, because semantics may
change with many factors beyond source-code level, such as choices made by
compilers. We here give concrete examples of problems that can appear and
solutions to implement in analysis software.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIENS, Verimag - Imag</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/1353445.1353446</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/1353445.1353446" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">ACM Transactions on Programming Languages and Systems 30, 3 (2008)
  12</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0701192v5" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701192v5" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.NA" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; D.3.1; F.3.1; G.1.0; G.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701195v1</id>
    <updated>2007-01-30T17:14:52Z</updated>
    <published>2007-01-30T17:14:52Z</published>
    <title>An Abstract Monte-Carlo Method for the Analysis of Probabilistic
  Programs</title>
    <summary>  We introduce a new method, combination of random testing and abstract
interpretation, for the analysis of programs featuring both probabilistic and
non-probabilistic nondeterminism. After introducing "ordinary" testing, we show
how to combine testing and abstract interpretation and give formulas linking
the precision of the results to the number of iterations. We then discuss
complexity and optimization issues and end with some experimental results.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIENS</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/360204.360211</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/360204.360211" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">POPL: Annual Symposium on Principles of Programming Languages
  (2001) 93 - 101</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0701195v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701195v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0702072v1</id>
    <updated>2007-02-13T03:10:02Z</updated>
    <published>2007-02-13T03:10:02Z</published>
    <title>Logic Programming with Satisfiability</title>
    <summary>  This paper presents a Prolog interface to the MiniSat satisfiability solver.
Logic program- ming with satisfiability combines the strengths of the two
paradigms: logic programming for encoding search problems into satisfiability
on the one hand and efficient SAT solving on the other. This synergy between
these two exposes a programming paradigm which we propose here as a logic
programming pearl. To illustrate logic programming with SAT solving we give an
example Prolog program which solves instances of Partial MAXSAT.
</summary>
    <author>
      <name>Michael Codish</name>
    </author>
    <author>
      <name>Vitaly Lagoon</name>
    </author>
    <author>
      <name>Peter J. Stuckey</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 pages, 3 figures, 1 table</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming: 8(1):121-128, 2008</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0702072v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0702072v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0703077v2</id>
    <updated>2007-03-16T08:51:01Z</updated>
    <published>2007-03-15T06:07:02Z</published>
    <title>Relational Abstract Domains for the Detection of Floating-Point Run-Time
  Errors</title>
    <summary>  We present a new idea to adapt relational abstract domains to the analysis of
IEEE 754-compliant floating-point numbers in order to statically detect,
through abstract Interpretation-based static analyses, potential floating-point
run-time exceptions such as overflows or invalid operations. In order to take
the non-linearity of rounding into account, expressions are modeled as linear
forms with interval coefficients. We show how to extend already existing
numerical abstract domains, such as the octagon abstract domain, to efficiently
abstract transfer functions based on interval linear forms. We discuss specific
fixpoint stabilization techniques and give some experimental results.
</summary>
    <author>
      <name>Antoine Miné</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIENS</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">(update: reversed author first and last names)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">European Symposium on Programming (ESOP) (03/2004) 3-17</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0703077v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0703077v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0703084v2</id>
    <updated>2007-03-16T08:47:24Z</updated>
    <published>2007-03-15T18:16:32Z</published>
    <title>The Octagon Abstract Domain</title>
    <summary>  This article presents a new numerical abstract domain for static analysis by
abstract interpretation. It extends a former numerical abstract domain based on
Difference-Bound Matrices and allows us to represent invariants of the form
(+/-x+/-y&lt;=c), where x and y are program variables and c is a real constant. We
focus on giving an efficient representation based on Difference-Bound Matrices
- O(n2) memory cost, where n is the number of variables - and graph-based
algorithms for all common abstract operators - O(n3) time cost. This includes a
normal form algorithm to test equivalence of representation and a widening
operator to compute least fixpoint approximations.
</summary>
    <author>
      <name>Antoine Miné</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIENS</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">(update: reversed author first and last names)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Analysis, Slicing and Transformation (AST) (10/2001) 310-319</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0703084v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0703084v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0705.1452v1</id>
    <updated>2007-05-10T12:19:51Z</updated>
    <published>2007-05-10T12:19:51Z</published>
    <title>Typer la dé-sérialisation sans sérialiser les types</title>
    <summary>  In this paper, we propose a way of assigning static type information to
unmarshalling functions and we describe a verification technique for
unmarshalled data that preserves the execution safety provided by static type
checking. This technique, whose correctness is proven, relies on singleton
types whose values are transmitted to unmarshalling routines at runtime, and on
an efficient checking algorithm able to deal with sharing and cycles.
</summary>
    <author>
      <name>Grégoire Henry</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Michel Mauny</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt, ENSTA-UMA</arxiv:affiliation>
    </author>
    <author>
      <name>Emmanuel Chailloux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journ\'ee francophone des langages applicatifs (JFLA) 2006
  (01/2006)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0705.1452v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0705.1452v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0705.1458v1</id>
    <updated>2007-05-10T12:31:17Z</updated>
    <published>2007-05-10T12:31:17Z</published>
    <title>Mixing the Objective Caml and C# Programming Models in the .Net
  Framework</title>
    <summary>  We present a new code generator, called O'Jacare.net, to inter-operate
between C# and Objective Caml through their object models. O'Jacare.net defines
a basic IDL (Interface Definition Language) that describes classes and
interfaces in order to communicate between Objective Caml and C#. O'Jacare.net
generates all needed wrapper classes and takes advantage of static type
checking in both worlds. Although the IDL intersects these two object models,
O'Jacare.net allows to combine features from both.
</summary>
    <author>
      <name>Emmanuel Chailloux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Grégoire Henry</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Raphaël Montelatici</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Workshop on MULTIPARADIGM PROGRAMMING WITH OO LANGUAGES (MPOOL),
  Norv\`ege (06/2004)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0705.1458v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0705.1458v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0705.2126v1</id>
    <updated>2007-05-15T12:06:32Z</updated>
    <published>2007-05-15T12:06:32Z</published>
    <title>Improvements to the Psi-SSA representation</title>
    <summary>  Modern compiler implementations use the Static Single Assignment
representation as a way to efficiently implement optimizing algorithms. However
this representation is not well adapted to architectures with a predicated
instruction set. The Psi-SSA representation extends the SSA representation such
that standard SSA algorithms can be easily adapted to an architecture with a
fully predicated instruction set. A new pseudo operation, the Psi operation, is
introduced to merge several conditional definitions into a unique definition.
</summary>
    <author>
      <name>Francois De Ferriere</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Published in proceedings for the workshop "Software and Compilers
  for Embedded Systems (SCOPES) 2007" (20/04/2007)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0705.2126v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0705.2126v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0706.2293v1</id>
    <updated>2007-06-15T13:39:12Z</updated>
    <published>2007-06-15T13:39:12Z</published>
    <title>Resource control of object-oriented programs</title>
    <summary>  A sup-interpretation is a tool which provides an upper bound on the size of a
value computed by some symbol of a program. Sup-interpretations have shown
their interest to deal with the complexity of first order functional programs.
For instance, they allow to characterize all the functions bitwise computable
in Alogtime. This paper is an attempt to adapt the framework of
sup-interpretations to a fragment of oriented-object programs, including
distinct encodings of numbers through the use of constructor symbols, loop and
while constructs and non recursive methods with side effects. We give a
criterion, called brotherly criterion, which ensures that each brotherly
program computes objects whose size is polynomially bounded by the inputs
sizes.
</summary>
    <author>
      <name>Jean-Yves Marion</name>
    </author>
    <author>
      <name>Romain Pechoux</name>
    </author>
    <link href="http://arxiv.org/abs/0706.2293v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0706.2293v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0711.0344v1</id>
    <updated>2007-11-02T16:53:34Z</updated>
    <published>2007-11-02T16:53:34Z</published>
    <title>Automatic Coding Rule Conformance Checking Using Logic Programs</title>
    <summary>  Some approaches to increasing program reliability involve a disciplined use
of programming languages so as to minimise the hazards introduced by
error-prone features. This is realised by writing code that is constrained to a
subset of the a priori admissible programs, and that, moreover, may use only a
subset of the language. These subsets are determined by a collection of
so-called coding rules.
</summary>
    <author>
      <name>Guillem Marpons-Ucero</name>
    </author>
    <author>
      <name>Julio Mariño</name>
    </author>
    <author>
      <name>Ángel Herranz</name>
    </author>
    <author>
      <name>Lars-Åke Fredlund</name>
    </author>
    <author>
      <name>Manuel Carro</name>
    </author>
    <author>
      <name>Juan José Moreno-Navarro</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 17th Workshop on Logic-based Methods in
  Programming Environments (WLPE2007)</arxiv:comment>
    <link href="http://arxiv.org/abs/0711.0344v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0711.0344v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6; D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0711.0345v1</id>
    <updated>2007-11-02T16:40:10Z</updated>
    <published>2007-11-02T16:40:10Z</published>
    <title>A Prolog-based Environment for Reasoning about Programming Languages
  (Extended abstract)</title>
    <summary>  ECLAIR is a Prolog-based prototype system aiming to provide a functionally
complete environment for the study, development and evaluation of programming
language analysis and implementation tools. In this paper, we sketch the
overall structure of the system, outlining the main methodologies and
technologies underlying its components. We also discuss the appropriateness of
Prolog as the implementation language for the system: besides highlighting its
strengths, we also point out a few potential weaknesses, hinting at possible
solutions.
</summary>
    <author>
      <name>Roberto Bagnara</name>
    </author>
    <author>
      <name>Patricia Hill</name>
    </author>
    <author>
      <name>Enea Zaffanella</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 17th Workshop on Logic-based Methods in
  Programming Environments (WLPE2007)</arxiv:comment>
    <link href="http://arxiv.org/abs/0711.0345v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0711.0345v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6; D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0711.0348v1</id>
    <updated>2007-11-02T16:49:30Z</updated>
    <published>2007-11-02T16:49:30Z</published>
    <title>Compiling ER Specifications into Declarative Programs</title>
    <summary>  This paper proposes an environment to support high-level database programming
in a declarative programming language. In order to ensure safe database
updates, all access and update operations related to the database are generated
from high-level descriptions in the entity- relationship (ER) model. We propose
a representation of ER diagrams in the declarative language Curry so that they
can be constructed by various tools and then translated into this
representation. Furthermore, we have implemented a compiler from this
representation into a Curry program that provides access and update operations
based on a high-level API for database programming.
</summary>
    <author>
      <name>Bernd Braßel</name>
    </author>
    <author>
      <name>Michael Hanus</name>
    </author>
    <author>
      <name>Marion Muller</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 17th Workshop on Logic-based Methods in
  Programming Environments (WLPE2007)</arxiv:comment>
    <link href="http://arxiv.org/abs/0711.0348v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0711.0348v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6; D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0711.0618v1</id>
    <updated>2007-11-05T12:13:12Z</updated>
    <published>2007-11-05T12:13:12Z</published>
    <title>PIDoc: Wiki style Literate Programming for Prolog</title>
    <summary>  This document introduces PlDoc, a literate programming system for Prolog.
Starting point for PlDoc was minimal distraction from the programming task and
maximal immediate reward, attempting to seduce the programmer to use the
system. Minimal distraction is achieved using structured comments that are as
closely as possible related to common Prolog documentation practices. Immediate
reward is provided by a web interface powered from the Prolog development
environment that integrates searching and browsing application and system
documentation. When accessed from localhost, it is possible to go from
documentation shown in a browser to the source code displayed in the user's
editor of choice.
</summary>
    <author>
      <name>Jan Wielemaker</name>
    </author>
    <author>
      <name>Anjo Anjewierden</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 17th Workshop on Logic-based Methods in
  Programming Environments (WLPE2007)</arxiv:comment>
    <link href="http://arxiv.org/abs/0711.0618v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0711.0618v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0801.0133v1</id>
    <updated>2007-12-30T14:43:27Z</updated>
    <published>2007-12-30T14:43:27Z</published>
    <title>An Approach to Programming Based on Concepts</title>
    <summary>  In this paper we describe a new approach to programming which generalizes
object-oriented programming. It is based on using a new programming construct,
called concept, which generalizes classes. Concept is defined as a pair of two
classes: one reference class and one object class. Each concept has a parent
concept which is specified using inclusion relation generalizing inheritance.
We describe several important mechanisms such as reference resolution, context
stack, dual methods and life-cycle management, inheritance and polymorphism.
This approach to programming is positioned as a new programming paradigm and
therefore we formulate its main principles and rules.
</summary>
    <author>
      <name>Alexandr Savinov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">49 pages. Related papers: http://conceptoriented.com</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Institute of Mathematics and Computer Science, Academy of Sciences
  of Moldova, Technical Report RT0005, 2007</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0801.0133v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0801.0133v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0801.1219v1</id>
    <updated>2008-01-08T12:28:18Z</updated>
    <published>2008-01-08T12:28:18Z</published>
    <title>DSL development based on target meta-models. Using AST transformations
  for automating semantic analysis in a textual DSL framework</title>
    <summary>  This paper describes an approach to creating textual syntax for Do-
main-Specific Languages (DSL). We consider target meta-model to be the main
artifact and hence to be developed first. The key idea is to represent analysis
of textual syntax as a sequence of transformations. This is made by explicit
opera- tions on abstract syntax trees (ATS), for which a simple language is
proposed. Text-to-model transformation is divided into two parts: text-to-AST
(developed by openArchitectureWare [1]) and AST-to-model (proposed by this
paper). Our approach simplifies semantic analysis and helps to generate as much
as possi- ble.
</summary>
    <author>
      <name>Andrey Breslav</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 3 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/0801.1219v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0801.1219v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0802.3492v2</id>
    <updated>2010-03-25T19:06:42Z</updated>
    <published>2008-02-24T05:28:52Z</published>
    <title>The RDF Virtual Machine</title>
    <summary>  The Resource Description Framework (RDF) is a semantic network data model
that is used to create machine-understandable descriptions of the world and is
the basis of the Semantic Web. This article discusses the application of RDF to
the representation of computer software and virtual computing machines. The
Semantic Web is posited as not only a web of data, but also as a web of
programs and processes.
</summary>
    <author>
      <name>Marko A. Rodriguez</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/j.knosys.2011.04.004</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/j.knosys.2011.04.004" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">keywords: Resource Description Framework, Virtual Machines,
  Distributed Computing, Semantic Web</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Knowledge-Based Systems, 24(6), 890-903, August 2011</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0802.3492v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0802.3492v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.2; I.2.4; E.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0802.4018v2</id>
    <updated>2008-03-21T11:22:39Z</updated>
    <published>2008-02-27T13:21:51Z</published>
    <title>Algebraic Pattern Matching in Join Calculus</title>
    <summary>  We propose an extension of the join calculus with pattern matching on
algebraic data types. Our initial motivation is twofold: to provide an
intuitive semantics of the interaction between concurrency and pattern
matching; to define a practical compilation scheme from extended join
definitions into ordinary ones plus ML pattern matching. To assess the
correctness of our compilation scheme, we develop a theory of the applied join
calculus, a calculus with value passing and value matching. We implement this
calculus as an extension of the current JoCaml system.
</summary>
    <author>
      <name>Qin Ma</name>
    </author>
    <author>
      <name>Luc Maranget</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-4(1:7)2008</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-4(1:7)2008" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 4, Issue 1 (March 21,
  2008) lmcs:770</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0802.4018v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0802.4018v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.3; D.3.3; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0804.1118v1</id>
    <updated>2008-04-07T19:48:31Z</updated>
    <published>2008-04-07T19:48:31Z</published>
    <title>A Survey of Quantum Programming Languages: History, Methods, and Tools</title>
    <summary>  Quantum computer programming is emerging as a new subject domain from
multidisciplinary research in quantum computing, computer science, mathematics
(especially quantum logic, lambda calculi, and linear logic), and engineering
attempts to build the first non-trivial quantum computer. This paper briefly
surveys the history, methods, and proposed tools for programming quantum
computers circa late 2007. It is intended to provide an extensive but
non-exhaustive look at work leading up to the current state-of-the-art in
quantum computer programming. Further, it is an attempt to analyze the needed
programming tools for quantum programmers, to use this analysis to predict the
direction in which the field is moving, and to make recommendations for further
development of quantum programming language tools.
</summary>
    <author>
      <name>Donald A. Sofge</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0804.1118v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0804.1118v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0804.1696v2</id>
    <updated>2008-04-24T15:46:28Z</updated>
    <published>2008-04-10T13:21:32Z</published>
    <title>A classification of invasive patterns in AOP</title>
    <summary>  Aspect-Oriented Programming (AOP) improves modularity by encapsulating
crosscutting concerns into aspects. Some mechanisms to compose aspects allow
invasiveness as a mean to integrate concerns. Invasiveness means that AOP
languages have unrestricted access to program properties. Such kind of
languages are interesting because they allow performing complex operations and
better introduce functionalities. In this report we present a classification of
invasive patterns in AOP. This classification characterizes the aspects
invasive behavior and allows developers to abstract about the aspect incidence
over the program they crosscut.
</summary>
    <author>
      <name>Freddy Munoz</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IRISA</arxiv:affiliation>
    </author>
    <author>
      <name>Benoit Baudry</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IRISA</arxiv:affiliation>
    </author>
    <author>
      <name>Olivier Barais</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IRISA</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/0804.1696v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0804.1696v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0805.4029v1</id>
    <updated>2008-05-27T01:31:05Z</updated>
    <published>2008-05-27T01:31:05Z</published>
    <title>Event Synchronization by Lightweight Message Passing</title>
    <summary>  Concurrent ML's events and event combinators facilitate modular concurrent
programming with first-class synchronization abstractions. A standard
implementation of these abstractions relies on fairly complex manipulations of
first-class continuations in the underlying language. In this paper, we present
a lightweight implementation of these abstractions in Concurrent Haskell, a
language that already provides first-order message passing. At the heart of our
implementation is a new distributed synchronization protocol. In contrast with
several previous translations of event abstractions in concurrent languages, we
remain faithful to the standard semantics for events and event combinators; for
example, we retain the symmetry of $\mathtt{choose}$ for expressing selective
communication.
</summary>
    <author>
      <name>Avik Chaudhuri</name>
    </author>
    <link href="http://arxiv.org/abs/0805.4029v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0805.4029v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.1.3; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0809.1437v1</id>
    <updated>2008-09-09T14:39:57Z</updated>
    <published>2008-09-09T14:39:57Z</published>
    <title>How applicable is Python as first computer language for teaching
  programming in a pre-university educational environment, from a teacher's
  point of view?</title>
    <summary>  This project report attempts to evaluate the educational properties of the
Python computer language, in practice. This is done by examining computer
language evolution history, related scientific background work, the existing
educational research on computer languages and Python's experimental
application in higher secondary education in Greece, during first half of year
2002. This Thesis Report was delivered in advance of a thesis defense for a
Masters/Doctorandus (MSc/Drs) title with the Amstel Institute/Universiteit van
Amsterdam, during the same year.
</summary>
    <author>
      <name>Fotis Georgatos</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">135 pages, 20 tables, 10 figures (incl. evolution of computer
  languages)</arxiv:comment>
    <link href="http://arxiv.org/abs/0809.1437v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0809.1437v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CY" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3; K.3.2; I.2.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0809.4635v1</id>
    <updated>2008-09-26T13:57:36Z</updated>
    <published>2008-09-26T13:57:36Z</published>
    <title>Mechanistic Behavior of Single-Pass Instruction Sequences</title>
    <summary>  Earlier work on program and thread algebra detailed the functional,
observable behavior of programs under execution. In this article we add the
modeling of unobservable, mechanistic processing, in particular processing due
to jump instructions. We model mechanistic processing preceding some further
behavior as a delay of that behavior; we borrow a unary delay operator from
discrete time process algebra. We define a mechanistic improvement ordering on
threads and observe that some threads do not have an optimal implementation.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <author>
      <name>Mark B. van der Zwaag</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0809.4635v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0809.4635v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.4; F.3.2; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0810.0372v1</id>
    <updated>2008-10-02T09:41:52Z</updated>
    <published>2008-10-02T09:41:52Z</published>
    <title>Optimizing Binary Code Produced by Valgrind (Project Report on Virtual
  Execution Environments Course - AVExe)</title>
    <summary>  Valgrind is a widely used framework for dynamic binary instrumentation and
its mostly known by its memcheck tool. Valgrind's code generation module is far
from producing optimal code. In addition it has many backends for different CPU
architectures, which difficults code optimization in an architecture
independent way. Our work focused on identifying sub-optimal code produced by
Valgrind and optimizing it.
</summary>
    <author>
      <name>Filipe Cabecinhas</name>
    </author>
    <author>
      <name>Nuno Lopes</name>
    </author>
    <author>
      <name>Renato Crisostomo</name>
    </author>
    <author>
      <name>Luis Veiga</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Technical report from INESC-ID Lisboa describing optimizations to
  code generation of the Valgring execution environment. Work developed in the
  context of a Virtual Execution Environments course (AVExe) at IST/Technical
  university of Lisbon</arxiv:comment>
    <link href="http://arxiv.org/abs/0810.0372v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0810.0372v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.OS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0810.1151v2</id>
    <updated>2013-04-16T12:11:12Z</updated>
    <published>2008-10-07T13:55:21Z</published>
    <title>Periodic Single-Pass Instruction Sequences</title>
    <summary>  A program is a finite piece of data that produces a (possibly infinite)
sequence of primitive instructions. From scratch we develop a linear notation
for sequential, imperative programs, using a familiar class of primitive
instructions and so-called repeat instructions, a particular type of control
instructions. The resulting mathematical structure is a semigroup. We relate
this set of programs to program algebra (PGA) and show that a particular
subsemigroup is a carrier for PGA by providing axioms for single-pass
congruence, structural congruence, and thread extraction. This subsemigroup
characterizes periodic single-pass instruction sequences and provides a direct
basis for PGA's toolset.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <author>
      <name>Alban Ponse</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">16 pages, 3 tables, New title</arxiv:comment>
    <link href="http://arxiv.org/abs/0810.1151v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0810.1151v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0811.0436v2</id>
    <updated>2008-11-18T10:08:03Z</updated>
    <published>2008-11-04T07:24:12Z</published>
    <title>Instruction sequences for the production of processes</title>
    <summary>  Single-pass instruction sequences under execution are considered to produce
behaviours to be controlled by some execution environment. Threads as
considered in thread algebra model such behaviours: upon each action performed
by a thread, a reply from its execution environment determines how the thread
proceeds. Threads in turn can be looked upon as producing processes as
considered in process algebra. We show that, by apposite choice of basic
instructions, all processes that can only be in a finite number of states can
be produced by single-pass instruction sequences.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">23 pages; acknowledgement corrected, reference updated</arxiv:comment>
    <link href="http://arxiv.org/abs/0811.0436v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0811.0436v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.4; F.1.1; F.1.2; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0811.0819v1</id>
    <updated>2008-11-05T21:10:33Z</updated>
    <published>2008-11-05T21:10:33Z</published>
    <title>Persistent Queries</title>
    <summary>  We propose a syntax and semantics for interactive abstract state machines to
deal with the following situation. A query is issued during a certain step, but
the step ends before any reply is received. Later, a reply arrives, and later
yet the algorithm makes use of this reply. By a persistent query, we mean a
query for which a late reply might be used. Syntactically, our proposal
involves issuing, along with a persistent query, a location where a late reply
is to be stored. Semantically, it involves only a minor modification of the
existing theory of interactive small-step abstract state machines.
</summary>
    <author>
      <name>Andreas Blass</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Michigan</arxiv:affiliation>
    </author>
    <author>
      <name>Yuri Gurevich</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Microsoft Research</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/0811.0819v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0811.0819v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0812.3550v1</id>
    <updated>2008-12-18T15:22:46Z</updated>
    <published>2008-12-18T15:22:46Z</published>
    <title>XML Static Analyzer User Manual</title>
    <summary>  This document describes how to use the XML static analyzer in practice. It
provides informal documentation for using the XML reasoning solver
implementation. The solver allows automated verification of properties that are
expressed as logical formulas over trees. A logical formula may for instance
express structural constraints or navigation properties (like e.g. path
existence and node selection) in finite trees. Logical formulas can be
expressed using the syntax of XPath expressions, DTD, XML Schemas, and Relax NG
definitions.
</summary>
    <author>
      <name>Pierre Geneves</name>
    </author>
    <author>
      <name>Nabil Layaida</name>
    </author>
    <link href="http://arxiv.org/abs/0812.3550v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0812.3550v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.0; D.3.1; D.3.4; E.1; F.3.1; F.3.2; F.4.1; F.4.3; H.2.3; I.2.4;&#10;  I.7.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0901.2461v1</id>
    <updated>2009-01-16T11:45:40Z</updated>
    <published>2009-01-16T11:45:40Z</published>
    <title>Grammatic -- a tool for grammar definition reuse and modularity</title>
    <summary>  Grammatic is a tool for grammar definition and manipulation aimed to improve
modularity and reuse of grammars and related development artifacts. It is
independent from parsing technology and any other details of target system
implementation. Grammatic provides a way for annotating grammars with arbitrary
metadata (like associativity attributes, semantic actions or anything else). It
might be used as a front-end for external tools like parser generators to make
their input grammars modular and reusable. This paper describes main principles
behind Grammatic and gives an overview of languages it provides and their
ability to separate concerns and define reusable modules. Also it presents
sketches of possible use cases for the tool.
</summary>
    <author>
      <name>Andrey Breslav</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted to DSL'09</arxiv:comment>
    <link href="http://arxiv.org/abs/0901.2461v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0901.2461v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0901.3619v1</id>
    <updated>2009-01-23T08:40:31Z</updated>
    <published>2009-01-23T08:40:31Z</published>
    <title>Mechanized semantics for the Clight subset of the C language</title>
    <summary>  This article presents the formal semantics of a large subset of the C
language called Clight. Clight includes pointer arithmetic, "struct" and
"union" types, C loops and structured "switch" statements. Clight is the source
language of the CompCert verified compiler. The formal semantics of Clight is a
big-step operational semantics that observes both terminating and diverging
executions and produces traces of input/output events. The formal semantics of
Clight is mechanized using the Coq proof assistant. In addition to the
semantics of Clight, this article describes its integration in the CompCert
verified compiler and several ways by which the semantics was validated.
</summary>
    <author>
      <name>Sandrine Blazy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CEDRIC, INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>Xavier Leroy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/s10817-009-9148-3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/s10817-009-9148-3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Automated Reasoning (2009)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Automated Reasoning 43, 3 (2009) 263-288</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0901.3619v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0901.3619v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0902.1257v1</id>
    <updated>2009-02-07T18:00:30Z</updated>
    <published>2009-02-07T18:00:30Z</published>
    <title>Compilation of extended recursion in call-by-value functional languages</title>
    <summary>  This paper formalizes and proves correct a compilation scheme for
mutually-recursive definitions in call-by-value functional languages. This
scheme supports a wider range of recursive definitions than previous methods.
We formalize our technique as a translation scheme to a lambda-calculus
featuring in-place update of memory blocks, and prove the translation to be
correct.
</summary>
    <author>
      <name>Tom Hirschowitz</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LM-Savoie</arxiv:affiliation>
    </author>
    <author>
      <name>Xavier Leroy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>J. B. Wells</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/s10990-009-9042-z</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/s10990-009-9042-z" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">62 pages, uses pic</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Higher-Order and Symbolic Computation 22, 1 (2009) 3-66</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0902.1257v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0902.1257v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0902.2621v1</id>
    <updated>2009-02-16T07:55:16Z</updated>
    <published>2009-02-16T07:55:16Z</published>
    <title>Creating modular and reusable DSL textual syntax definitions with
  Grammatic/ANTLR</title>
    <summary>  In this paper we present Grammatic -- a tool for textual syntax definition.
Grammatic serves as a front-end for parser generators (and other tools) and
brings modularity and reuse to their development artifacts. It adapts
techniques for separation of concerns from Apsect-Oriented Programming to
grammars and uses templates for grammar reuse. We illustrate usage of Grammatic
by describing a case study: bringing separation of concerns to ANTLR parser
generator, which is achieved without a common time- and memory-consuming
technique of building an AST to separate semantic actions from a grammar
definition.
</summary>
    <author>
      <name>Andrey Breslav</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted to PSI'09</arxiv:comment>
    <link href="http://arxiv.org/abs/0902.2621v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0902.2621v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0902.2859v1</id>
    <updated>2009-02-17T08:41:22Z</updated>
    <published>2009-02-17T08:41:22Z</published>
    <title>Transmission protocols for instruction streams</title>
    <summary>  Threads as considered in thread algebra model behaviours to be controlled by
some execution environment: upon each action performed by a thread, a reply
from its execution environment -- which takes the action as an instruction to
be processed -- determines how the thread proceeds. In this paper, we are
concerned with the case where the execution environment is remote: we describe
and analyse some transmission protocols for passing instructions from a thread
to a remote execution environment.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-642-03466-4_8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-642-03466-4_8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">13 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">In ICTAC 2009, pages 127--139. Springer-Verlag, LNCS 5684, 2009</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0902.2859v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0902.2859v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.1; D.2.4; F.1.1; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0903.1352v2</id>
    <updated>2009-11-07T13:19:57Z</updated>
    <published>2009-03-07T17:14:44Z</published>
    <title>An Instruction Sequence Semigroup with Involutive Anti-Automorphisms</title>
    <summary>  We introduce an algebra of instruction sequences by presenting a semigroup C
in which programs can be represented without directional bias: in terms of the
next instruction to be executed, C has both forward and backward instructions
and a C-expression can be interpreted starting from any instruction. We provide
equations for thread extraction, i.e., C's program semantics. Then we consider
thread extraction compatible (anti-)homomorphisms and (anti-)automorphisms.
Finally we discuss some expressiveness results.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <author>
      <name>Alban Ponse</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">36 pages, 1 table</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Scientific Annals of Computer Science, 19:57-92, 2009</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0903.1352v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0903.1352v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.RA" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.2; I.1.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0903.1598v6</id>
    <updated>2009-03-26T17:11:37Z</updated>
    <published>2009-03-09T17:26:36Z</published>
    <title>18th Workshop on Logic-based methods in Programming Environments (WLPE
  2008)</title>
    <summary>  This volume contains the papers presented at WLPE 2008: the 18th Workshop on
Logic-based Methods in Programming Environments held on 12th December, 2008 in
Udine, Italy. It was held as a satellite workshop of ICLP 2008, the 24th
International Conference on Logic Programming.
</summary>
    <author>
      <name>Puri Arenas</name>
    </author>
    <author>
      <name>Damiano Zanardini</name>
    </author>
    <link href="http://arxiv.org/abs/0903.1598v6" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0903.1598v6" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6; D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0903.2202v1</id>
    <updated>2009-03-12T15:54:13Z</updated>
    <published>2009-03-12T15:54:13Z</published>
    <title>Improving Size-Change Analysis in Offline Partial Evaluation</title>
    <summary>  Some recent approaches for scalable offline partial evaluation of logic
programs include a size-change analysis for ensuring both so called local and
global termination. In this work|inspired by experimental evaluation|we
introduce several improvements that may increase the accuracy of the analysis
and, thus, the quality of the associated specialized programs. We aim to
achieve this while maintaining the same complexity and scalability of the
recent works.
</summary>
    <author>
      <name>Michael Leuschel</name>
    </author>
    <author>
      <name>Salvador Tamarit</name>
    </author>
    <author>
      <name>German Vidal</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 18th Workshop on Logic-based Methods in
  Programming Environments (WLPE2008) (Report-No: WLPE/2008). Paper submitted
  by a co-editor of the Workshop proceedings</arxiv:comment>
    <link href="http://arxiv.org/abs/0903.2202v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0903.2202v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0903.2252v1</id>
    <updated>2009-03-12T15:42:24Z</updated>
    <published>2009-03-12T15:42:24Z</published>
    <title>A Semantics-Aware Editing Environment for Prolog in Eclipse</title>
    <summary>  In this paper we present a Prolog plugin for Eclipse based upon BE4, and
providing many features such as semantic-aware syntax highlighting, outline
view, error marking, content assist, hover information, documentation
generation, and quick fixes. The plugin makes use of a Java parser for full
Prolog with an integrated Prolog engine, and can be extended with further
semantic analyses, e.g., based on abstract interpretation.
</summary>
    <author>
      <name>Jens Bendisposto</name>
    </author>
    <author>
      <name>Ian Endrijautzki</name>
    </author>
    <author>
      <name>Michael Leuschel</name>
    </author>
    <author>
      <name>David Schneider</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 18th Workshop on Logic-based Methods in
  Programming Environments (WLPE2008) (Report-No: WLPE/2008). Paper submitted
  by a co-editor of the Workshop proceedings</arxiv:comment>
    <link href="http://arxiv.org/abs/0903.2252v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0903.2252v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.HC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0903.2353v1</id>
    <updated>2009-03-13T10:46:39Z</updated>
    <published>2009-03-13T10:46:39Z</published>
    <title>Relations, Constraints and Abstractions: Using the Tools of Logic
  Programming in the Security Industry</title>
    <summary>  Logic programming is sometimes described as relational programming: a
paradigm in which the programmer specifies and composes n-ary relations using
systems of constraints. An advanced logic programming environment will provide
tools that abstract these relations to transform, optimise, or even verify the
correctness of a logic program. This talk will show that these concepts, namely
relations, constraints and abstractions, turn out to also be important in the
reverse engineer process that underpins the discovery of bugs within the
security industry.
</summary>
    <author>
      <name>Andy King</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented as an invited talk at the 18th Workshop on
  Logic-based Methods in Programming Environments (WLPE2008) (Report-No:
  WLPE/2008). Paper submitted by a co-editor of the Workshop proceedings</arxiv:comment>
    <link href="http://arxiv.org/abs/0903.2353v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0903.2353v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0905.0737v1</id>
    <updated>2009-05-06T04:21:15Z</updated>
    <published>2009-05-06T04:21:15Z</published>
    <title>REC language is a live on IBM1130 simulator, EL lenguaje REC esta vivo
  en el simulador de la IBM 1130</title>
    <summary>  REC (Regular Expression Compiler) is a concise programming language
development in mayor Mexican Universities at end of 60s which allows students
to write programs without knowledge of the complicated syntax of languages like
FORTRAN and ALGOL. The language is recursive and contains only four elements
for control. This paper describes use of the interpreter of REC written in
FORTRAN on IBM1130 Simulator from -Computer History Simulation- Project.
</summary>
    <author>
      <name>Ignacio Vega-Paez</name>
    </author>
    <author>
      <name>Jose Angel Ortega</name>
    </author>
    <author>
      <name>Georgina G. Pulido</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This work is archaeological reconstruction of REC/A language</arxiv:comment>
    <link href="http://arxiv.org/abs/0905.0737v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0905.0737v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0905.2257v1</id>
    <updated>2009-05-14T06:23:18Z</updated>
    <published>2009-05-14T06:23:18Z</published>
    <title>A protocol for instruction stream processing</title>
    <summary>  The behaviour produced by an instruction sequence under execution is a
behaviour to be controlled by some execution environment: each step performed
actuates the processing of an instruction by the execution environment and a
reply returned at completion of the processing determines how the behaviour
proceeds. In this paper, we are concerned with the case where the processing
takes place remotely. We describe a protocol to deal with the case where the
behaviour produced by an instruction sequence under execution leads to the
generation of a stream of instructions to be processed and a remote execution
unit handles the processing of that stream of instructions.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0905.2257v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0905.2257v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.1; D.2.4; F.1.1; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0905.3432v1</id>
    <updated>2009-05-21T03:35:52Z</updated>
    <published>2009-05-21T03:35:52Z</published>
    <title>A Type System for Parallel Components</title>
    <summary>  The # component model was proposed to improve the practice of parallel
programming. This paper introduces a type system for # programming systems,
aiming to lift the abstraction and safety of programming for parallel computing
architectures by introducing a notion of abstract component based on universal
and existential bounded quantification. Issues about the implementation of such
type system in HPE, a # programming system, are also discussed.
</summary>
    <author>
      <name>Francisco Heron de Carvalho-Junior</name>
    </author>
    <author>
      <name>Rafael Dueire Lins</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted to SBLP 2009 (Brazilian Symposium on Programming Languages)</arxiv:comment>
    <link href="http://arxiv.org/abs/0905.3432v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0905.3432v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0905.4596v1</id>
    <updated>2009-05-28T10:01:47Z</updated>
    <published>2009-05-28T10:01:47Z</published>
    <title>About raising and handling exceptions</title>
    <summary>  This paper presents a unified framework for dealing with a deduction system
and a denotational semantics of exceptions. It is based on the fact that
handling exceptions can be seen as a kind of generalized case distinction. This
point of view on exceptions has been introduced in 2004, it is based on the
notion of diagrammatic logic, which assumes some familiarity with category
theory. Extensive sums of types can be used for dealing with case distinctions.
The aim of this new paper is to focus on the role of generalized extensivity
property for dealing with exceptions. Moreover, the presentation of this paper
makes only a restricted use of category theory.
</summary>
    <author>
      <name>Dominique Duval</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LMC - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>Jean-Claude Reynaud</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LSR - IMAG</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/0905.4596v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0905.4596v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0906.1777v1</id>
    <updated>2009-06-09T16:30:01Z</updated>
    <published>2009-06-09T16:30:01Z</published>
    <title>Creating Textual Language Dialects Using Aspect-like Techniques</title>
    <summary>  Here we present a work aimed on efficiently creating textual language
dialects and supporting tools for them (e.g. compiler front-ends, IDE support,
pretty-printers, etc.). A dialect is a language which may be described with a
(relatively small) set of changes to some other language (a parent language).
For example we can consider SQL dialects used in DB-management systems.
  We propose to use aspects for grammars to define different features of the
anguage and to transform grammars. A dialect is created by defining a
syntactical spect which modifies the parent language. This technique is not
dependent on any particular language design, AST structure or parsing
technology and provides a uniform way for creating dialects, which extend or
restrict languages.
</summary>
    <author>
      <name>Andrey Breslav</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">extended abstract for GTTSE'09</arxiv:comment>
    <link href="http://arxiv.org/abs/0906.1777v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0906.1777v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0906.3083v2</id>
    <updated>2014-10-01T14:26:01Z</updated>
    <published>2009-06-17T07:03:17Z</published>
    <title>Instruction sequence notations with probabilistic instructions</title>
    <summary>  This paper concerns instruction sequences that contain probabilistic
instructions, i.e. instructions that are themselves probabilistic by nature. We
propose several kinds of probabilistic instructions, provide an informal
operational meaning for each of them, and discuss related work. On purpose, we
refrain from providing an ad hoc formal meaning for the proposed kinds of
instructions. We also discuss the approach of projection semantics, which was
introduced in earlier work on instruction sequences, in the light of
probabilistic instruction sequences.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, revised because arxiv:1409.6873v1 [cs.LO] has come out</arxiv:comment>
    <link href="http://arxiv.org/abs/0906.3083v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0906.3083v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.4; F.1.1; F.1.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0907.2173v2</id>
    <updated>2011-06-06T00:35:43Z</updated>
    <published>2009-07-13T14:15:01Z</published>
    <title>Bit Copying - The Ultimate Computational Simplicity</title>
    <summary>  A computational abstract machine based on two operations: referencing and bit
copying is presented. These operations are sufficient for carrying out any
computation. They can be used as the primitives for a Turing-complete
programming language. The interesting point is that the computation can be done
without logic operations such as AND or OR. The compiler and emulator of this
language with sample programs are available on the Internet.
</summary>
    <author>
      <name>Oleg Mazonka</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Complex Systems Journal 2011, Vol 19, N3</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0907.2173v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0907.2173v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0907.4477v2</id>
    <updated>2009-09-11T19:57:27Z</updated>
    <published>2009-07-26T13:27:38Z</published>
    <title>Full abstraction for nominal general references</title>
    <summary>  Game semantics has been used with considerable success in formulating fully
abstract semantics for languages with higher-order procedures and a wide range
of computational effects. Recently, nominal games have been proposed for
modelling functional languages with names. These are ordinary, stateful games
cast in the theory of nominal sets developed by Pitts and Gabbay. Here we take
nominal games one step further, by developing a fully abstract semantics for a
language with nominal general references.
</summary>
    <author>
      <name>Nikos Tzevelekos</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-5(3:8)2009</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-5(3:8)2009" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 5, Issue 3 (September
  11, 2009) lmcs:918</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0907.4477v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0907.4477v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0907.4960v1</id>
    <updated>2009-07-28T19:24:51Z</updated>
    <published>2009-07-28T19:24:51Z</published>
    <title>Ezhil: A Tamil Programming Language</title>
    <summary>  Ezhil is a Tamil language based interpreted procedural programming language.
Tamil keywords and grammar are chosen to make the native Tamil speaker write
programs in the Ezhil system. Ezhil allows easy representation of computer
program closer to the Tamil language logical constructs equivalent to the
conditional, branch and loop statements in modern English based programming
languages. Ezhil is a compact programming language aimed towards Tamil speaking
novice computer users. Grammar for Ezhil and a few example programs are
reported here, from the initial proof-of-concept implementation using the
Python programming language1. To the best of our knowledge, Ezhil language is
the first freely available Tamil programming language.
</summary>
    <author>
      <name>Muthiah Annamalai</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages, Tamil UTF-8 characters</arxiv:comment>
    <link href="http://arxiv.org/abs/0907.4960v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0907.4960v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.0" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0907.5290v2</id>
    <updated>2012-03-22T18:58:15Z</updated>
    <published>2009-07-30T09:33:53Z</published>
    <title>Program structure</title>
    <summary>  A program is usually represented as a word chain. It is exactly a word chain
that appears as the lexical analyzer output and is parsed. The work shows that
a program can be syntactically represented as an oriented word tree, that is a
syntactic program tree, program words being located both in tree nodes and on
tree arrows. The basic property of a tree is that arrows starting from each
node are marked by different words (including an empty word). Semantics can
then be directly specified on such tree using either requirements or additional
links, and adding instructions to some tree nodes enables program execution
specification.
</summary>
    <author>
      <name>Alex Shkotin</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">22 pages, 4 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/0907.5290v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0907.5290v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0909.2089v3</id>
    <updated>2012-08-17T15:06:20Z</updated>
    <published>2009-09-11T05:51:09Z</published>
    <title>Indirect jumps improve instruction sequence performance</title>
    <summary>  Instruction sequences with direct and indirect jump instructions are as
expressive as instruction sequences with direct jump instructions only. We show
that, in the case where the number of instructions is not bounded, we are faced
with increases of the maximal internal delays of instruction sequences on
execution that are not bounded by a linear function if we strive for acceptable
increases of the lengths of instruction sequences on elimination of indirect
jump instructions.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.7561/SACS.2012.2.253</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.7561/SACS.2012.2.253" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages, definition of maximal internal delay and theorem 1 are
  stated more precise; presentation improved</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Scientific Annals of Computer Science, 22(2):253--265, 2012</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0909.2089v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0909.2089v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; F.1.1; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0909.2839v1</id>
    <updated>2009-09-15T16:59:57Z</updated>
    <published>2009-09-15T16:59:57Z</published>
    <title>A progression ring for interfaces of instruction sequences, threads, and
  services</title>
    <summary>  We define focus-method interfaces and some connections between such
interfaces and instruction sequences, giving rise to instruction sequence
components. We provide a flexible and practical notation for interfaces using
an abstract datatype specification comparable to that of basic process algebra
with deadlock. The structures thus defined are called progression rings. We
also define thread and service components. Two types of composition of
instruction sequences or threads and services (called `use' and `apply') are
lifted to the level of components.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <author>
      <name>Alban Ponse</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0909.2839v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0909.2839v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.2; D.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0911.2327v1</id>
    <updated>2009-11-12T08:56:05Z</updated>
    <published>2009-11-12T08:56:05Z</published>
    <title>An Intuitive Automated Modelling Interface for Systems Biology</title>
    <summary>  We introduce a natural language interface for building stochastic pi calculus
models of biological systems. In this language, complex constructs describing
biochemical events are built from basic primitives of association, dissociation
and transformation. This language thus allows us to model biochemical systems
modularly by describing their dynamics in a narrative-style language, while
making amendments, refinements and extensions on the models easy. We
demonstrate the language on a model of Fc-gamma receptor phosphorylation during
phagocytosis. We provide a tool implementation of the translation into a
stochastic pi calculus language, Microsoft Research's SPiM.
</summary>
    <author>
      <name>Ozan Kahramanoğullari</name>
    </author>
    <author>
      <name>Luca Cardelli</name>
    </author>
    <author>
      <name>Emmanuelle Caron</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.9.9</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.9.9" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 9, 2009, pp. 73-86</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0911.2327v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0911.2327v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="q-bio.QM" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0911.4203v1</id>
    <updated>2009-11-21T21:19:33Z</updated>
    <published>2009-11-21T21:19:33Z</published>
    <title>From Self-Interpreters to Normalization by Evaluation</title>
    <summary>  We characterize normalization by evaluation as the composition of a
self-interpreter with a self-reducer using a special representation scheme, in
the sense of Mogensen (1992). We do so by deriving in a systematic way an
untyped normalization by evaluation algorithm from a standard interpreter for
the ?-calculus. The derived algorithm is not novel and indeed other published
algorithms may be obtained in the same manner through appropriate adaptations
to the representation scheme.
</summary>
    <author>
      <name>Mathieu Boespflug</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIX</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">2009 Workshop on Normalization by Evaluation, Los Angeles :
  \'Etats-Unis d'Am\'erique (2009)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0911.4203v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0911.4203v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0911.5449v1</id>
    <updated>2009-11-29T00:35:42Z</updated>
    <published>2009-11-29T00:35:42Z</published>
    <title>Session Types at the Mirror</title>
    <summary>  We (re)define session types as projections of process behaviors with respect
to the communication channels they use. In this setting, we give session types
a semantics based on fair testing. The outcome is a unified theory of
behavioral types that shares common aspects with conversation types and that
encompass features of both dyadic and multi-party session types. The point of
view we provide sheds light on the nature of session types and gives us a
chance to reason about them in a framework where every notion, from
well-typedness to the subtyping relation between session types, is semantically
-rather than syntactically- grounded.
</summary>
    <author>
      <name>Luca Padovani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Urbino</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.12.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.12.5" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 12, 2009, pp. 71-86</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0911.5449v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0911.5449v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0912.4877v1</id>
    <updated>2009-12-24T15:27:18Z</updated>
    <published>2009-12-24T15:27:18Z</published>
    <title>Typing rule-based transformations over topological collections</title>
    <summary>  Pattern-matching programming is an example of a rule-based programming style
developed in functional languages. This programming style is intensively used
in dialects of ML but is restricted to algebraic data-types. This restriction
limits the field of application. However, as shown by Giavitto and Michel at
RULE'02, case-based function definitions can be extended to more general data
structures called topological collections. We show in this paper that this
extension retains the benefits of the typed discipline of the functional
languages. More precisely, we show that topological collections and the
rule-based definition of functions associated with them fit in a polytypic
extension of mini-ML where type inference is still possible.
</summary>
    <author>
      <name>Julien Cohen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LMI</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/S1571-0661(04)80676-5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/S1571-0661(04)80676-5" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">4th International Workshop on Rule-Based Programming, Valencia :
  Spain (2003)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0912.4877v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0912.4877v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0912.4878v1</id>
    <updated>2009-12-24T15:27:50Z</updated>
    <published>2009-12-24T15:27:50Z</published>
    <title>Typage fort et typage souple des collections topologiques et des
  transformations</title>
    <summary>  Topological collections allow to consider uniformly many data structures in
programming languages and are handled by functions defined by pattern matching
called transformations. We present two type systems for languages with
topological collections and transformations. The first one is a strong type
system \`a la Hindley/Milner which can be entirely typed at compile time. The
second one is a mixed static and dynamic type system allowing to handle
heterogeneous collections, that is collections which contain values with
different types. In the two cases, automatic type inference is possible.
</summary>
    <author>
      <name>Julien Cohen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LMI</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journ\'ees francophones des langages applicatifs,
  Sainte-Marie-de-R\'e : France (2004)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0912.4878v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0912.4878v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1001.4434v1</id>
    <updated>2010-01-25T14:06:29Z</updated>
    <published>2010-01-25T14:06:29Z</published>
    <title>Strategies in PRholog</title>
    <summary>  PRholog is an experimental extension of logic programming with strategic
conditional transformation rules, combining Prolog with Rholog calculus. The
rules perform nondeterministic transformations on hedges. Queries may have
several results that can be explored on backtracking. Strategies provide a
control on rule applications in a declarative way. With strategy combinators,
the user can construct more complex strategies from simpler ones. Matching with
four different kinds of variables provides a flexible mechanism of selecting
(sub)terms during execution. We give an overview on programming with strategies
in PRholog and demonstrate how rewriting strategies can be expressed.
</summary>
    <author>
      <name>Besik Dundua</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">RISC, JKU Linz</arxiv:affiliation>
    </author>
    <author>
      <name>Temur Kutsia</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">RISC, JKU Linz</arxiv:affiliation>
    </author>
    <author>
      <name>Mircea Marin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Tsukuba</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.15.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.15.3" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 15, 2010, pp. 32-43</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1001.4434v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1001.4434v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1001.4573v1</id>
    <updated>2010-01-26T01:05:09Z</updated>
    <published>2010-01-26T01:05:09Z</published>
    <title>Proceedings Ninth International Workshop on Reduction Strategies in
  Rewriting and Programming</title>
    <summary>  This volume contains selected papers presented at the 9th International
Workshop on Reduction Strategies in Rewriting and Programming, WRS2009, which
was held in Brasilia on the 28th June 2009, associated to RTA 2009 (the 20th
International Conference on Rewriting Techniques and Applications) at RDP, the
Federated Conference on Rewriting, Deduction and Programming. Reduction
strategies define which (sub)expression(s) should be selected for evaluation
and which rule(s) should be applied. These choices affect fundamental
properties of reductions, such as completeness, laziness and efficiency in
general. The WRS workshops promote research and collaboration in the area of
reduction strategies and their applications in specification and programming,
theorem proving, software engineering, etc.
</summary>
    <author>
      <name>Maribel Fernández</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">King's College London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.15</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.15" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 15, 2010</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1001.4573v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1001.4573v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1001.4901v1</id>
    <updated>2010-01-27T10:44:26Z</updated>
    <published>2010-01-27T10:44:26Z</published>
    <title>Deriving Ontologies from XML Schema</title>
    <summary>  In this paper, we present a method and a tool for deriving a skeleton of an
ontology from XML schema files. We first recall what an is ontology and its
relationships with XML schemas. Next, we focus on ontology building methodology
and associated tool requirements. Then, we introduce Janus, a tool for building
an ontology from various XML schemas in a given domain. We summarize the main
features of Janus and illustrate its functionalities through a simple example.
Finally, we compare our approach to other existing ontology building tools.
</summary>
    <author>
      <name>Ivan Bedini</name>
    </author>
    <author>
      <name>Georges Gardarin</name>
    </author>
    <author>
      <name>Benjamin Nguyen</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Entrepots de Donnees et Analyse en Ligne (EDA) Conference, Invited
  Paper, 2008</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1001.4901v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1001.4901v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1002.0936v1</id>
    <updated>2010-02-04T09:43:21Z</updated>
    <published>2010-02-04T09:43:21Z</published>
    <title>Programming Idioms for Transactional Events</title>
    <summary>  Transactional events (TE) are an extension of Concurrent ML (CML), a
programming model for synchronous message-passing. Prior work has focused on
TE's formal semantics and its implementation. This paper considers programming
idioms, particularly those that vary unexpectedly from the corresponding CML
idioms. First, we solve a subtle problem with client-server protocols in TE.
Second, we argue that CML's wrap and guard primitives do not translate well to
TE, and we suggest useful workarounds. Finally, we discuss how to rewrite CML
protocols that use abort actions.
</summary>
    <author>
      <name>Matthew Kehrt</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Washington</arxiv:affiliation>
    </author>
    <author>
      <name>Laura Effinger-Dean</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Washington</arxiv:affiliation>
    </author>
    <author>
      <name>Michael Schmitz</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Washington</arxiv:affiliation>
    </author>
    <author>
      <name>Dan Grossman</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Washington</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.17.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.17.4" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 17, 2010, pp. 43-48</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1002.0936v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1002.0936v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1002.0937v1</id>
    <updated>2010-02-04T09:46:48Z</updated>
    <published>2010-02-04T09:46:48Z</published>
    <title>Towards the Safe Programming of Wireless Sensor Networks</title>
    <summary>  Sensor networks are rather challenging to deploy, program, and debug. Current
programming languages for these platforms suffer from a significant semantic
gap between their specifications and underlying implementations. This fact
precludes the development of (type-)safe applications, which would potentially
simplify the task of programming and debugging deployed networks. In this paper
we define a core calculus for programming sensor networks and propose to use it
as an assembly language for developing type-safe, high-level programming
languages.
</summary>
    <author>
      <name>Francisco Martins</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Lisbon</arxiv:affiliation>
    </author>
    <author>
      <name>Luís Lopes</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Porto</arxiv:affiliation>
    </author>
    <author>
      <name>João Barros</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Porto</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.17.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.17.5" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 17, 2010, pp. 49-62</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1002.0937v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1002.0937v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.NI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1002.0940v1</id>
    <updated>2010-02-04T09:51:04Z</updated>
    <published>2010-02-04T09:51:04Z</published>
    <title>A Concurrent Language with a Uniform Treatment of Regions and Locks</title>
    <summary>  A challenge for programming language research is to design and implement
multi-threaded low-level languages providing static guarantees for memory
safety and freedom from data races. Towards this goal, we present a concurrent
language employing safe region-based memory management and hierarchical locking
of regions. Both regions and locks are treated uniformly, and the language
supports ownership transfer, early deallocation of regions and early release of
locks in a safe manner.
</summary>
    <author>
      <name>Prodromos Gerakios</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">National Technical University of Athens</arxiv:affiliation>
    </author>
    <author>
      <name>Nikolaos Papaspyrou</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">National Technical University of Athens</arxiv:affiliation>
    </author>
    <author>
      <name>Konstantinos Sagonas</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">National Technical University of Athens</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.17.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.17.7" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 17, 2010, pp. 79-93</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1002.0940v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1002.0940v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1002.1549v1</id>
    <updated>2010-02-08T08:51:06Z</updated>
    <published>2010-02-08T08:51:06Z</published>
    <title>Extensible type checker for parser generation</title>
    <summary>  Parser generators generate translators from language specifications. In many
cases, such specifications contain semantic actions written in the same
language as the generated code. Since these actions are subject to little
static checking, they are usually a source of errors which are discovered only
when generated code is compiled.
  In this paper we propose a parser generator front-end which statically checks
semantic actions for typing errors and prevents such errors from appearing in
generated code. The type checking procedure is extensible to support many
implementation languages. An extension for Java is presented along with an
extension for declarative type system descriptions.
</summary>
    <author>
      <name>Andrey Breslav</name>
    </author>
    <link href="http://arxiv.org/abs/1002.1549v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1002.1549v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1004.3241v1</id>
    <updated>2010-04-19T16:14:13Z</updated>
    <published>2010-04-19T16:14:13Z</published>
    <title>Causality and the semantics of provenance</title>
    <summary>  Provenance, or information about the sources, derivation, custody or history
of data, has been studied recently in a number of contexts, including
databases, scientific workflows and the Semantic Web. Many provenance
mechanisms have been developed, motivated by informal notions such as
influence, dependence, explanation and causality. However, there has been
little study of whether these mechanisms formally satisfy appropriate policies
or even how to formalize relevant motivating concepts such as causality. We
contend that mathematical models of these concepts are needed to justify and
compare provenance techniques. In this paper we review a theory of causality
based on structural models that has been developed in artificial intelligence,
and describe work in progress on a causal semantics for provenance graphs.
</summary>
    <author>
      <name>James Cheney</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Workshop submission</arxiv:comment>
    <link href="http://arxiv.org/abs/1004.3241v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1004.3241v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1004.4796v2</id>
    <updated>2011-04-13T09:14:23Z</updated>
    <published>2010-04-27T13:31:41Z</published>
    <title>Compiling Signal Processing Code embedded in Haskell via LLVM</title>
    <summary>  We discuss a programming language for real-time audio signal processing that
is embedded in the functional language Haskell and uses the Low-Level Virtual
Machine as back-end. With that framework we can code with the comfort and type
safety of Haskell while achieving maximum efficiency of fast inner loops and
full vectorisation. This way Haskell becomes a valuable alternative to special
purpose signal processing languages.
</summary>
    <author>
      <name>Henning Thielemann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 pages, 1 figure, 3 listings, 1 table, accepted by Linux Audio
  Conference LAC2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1004.4796v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1004.4796v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SD" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1005.4022v1</id>
    <updated>2010-05-21T17:35:59Z</updated>
    <published>2010-05-21T17:35:59Z</published>
    <title>Molecular Programming Pseudo-code Representation to Molecular
  Electronics</title>
    <summary>  This research paper is proposing the idea of pseudo code representation to
molecular programming used in designing molecular electronics devices. Already
the schematic representation of logical gates like AND, OR, NOT etc.from
molecular diodes or resonant tunneling diode are available. This paper is
setting a generic pseudo code model so that various logic gates can be
formulated. These molecular diodes have designed from organic molecules or
Bio-molecules. Our focus is on to give a scenario of molecular computation
through molecular programming. We have restricted our study to molecular
rectifying diode and logic device as AND gate from organic molecules only.
</summary>
    <author>
      <name>Manas Ranjan Pradhan</name>
    </author>
    <author>
      <name>E. G. Rajan</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">http://www.journalofcomputing.org</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Computing, Volume 2, Issue 5, May 2010</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1005.4022v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1005.4022v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1005.4616v1</id>
    <updated>2010-05-25T16:07:06Z</updated>
    <published>2010-05-25T16:07:06Z</published>
    <title>Parametrizing Program Analysis by Lifting to Cardinal Power Domains</title>
    <summary>  A parametric analysis is an analysis whose input and output are parametrized
with a number of parameters which can be instantiated to abstract properties
after analysis is completed. This paper proposes to use Cousot and Cousot's
Cardinal power domain to capture functional dependencies of analysis output on
its input and obtain a parametric analysis by parametrizing a non-parametric
base analysis. We illustrate the method by parametrizing a $\pos$ based
groundness analysis of logic programs to a parametric groundness analysis. In
addition, a prototype implementation shows that generality of the parametric
groundness analysis comes with a negligible extra cost.
</summary>
    <author>
      <name>Lunjin Lu</name>
    </author>
    <link href="http://arxiv.org/abs/1005.4616v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1005.4616v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1005.5278v2</id>
    <updated>2010-08-18T08:05:55Z</updated>
    <published>2010-05-28T12:33:37Z</published>
    <title>Positive Supercompilation for a Higher-Order Call-By-Value Language</title>
    <summary>  Previous deforestation and supercompilation algorithms may introduce
accidental termination when applied to call-by-value programs. This hides
looping bugs from the programmer, and changes the behavior of a program
depending on whether it is optimized or not. We present a supercompilation
algorithm for a higher-order call-by-value language and prove that the
algorithm both terminates and preserves termination properties. This algorithm
utilizes strictness information to decide whether to substitute or not and
compares favorably with previous call-by-name transformations.
</summary>
    <author>
      <name>Peter A. Jonsson</name>
    </author>
    <author>
      <name>Johan Nordlander</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-6(3:5)2010</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-6(3:5)2010" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 6, Issue 3 (August 18,
  2010) lmcs:1038</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1005.5278v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1005.5278v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1006.3039v2</id>
    <updated>2010-06-20T19:23:06Z</updated>
    <published>2010-06-15T17:44:15Z</published>
    <title>Concurrent Goal-Based Execution of Constraint Handling Rules</title>
    <summary>  (To appear in Theory and Practice of Logic Programming (TPLP)) We introduce a
systematic, concurrent execution scheme for Constraint Handling Rules (CHR)
based on a previously proposed sequential goal-based CHR semantics. We
establish strong correspondence results to the abstract CHR semantics, thus
guaranteeing that any answer in the concurrent, goal-based CHR semantics is
reproducible in the abstract CHR semantics. Our work provides the foundation to
obtain efficient, parallel CHR execution schemes.
</summary>
    <author>
      <name>Edmund S. L. Lam</name>
    </author>
    <author>
      <name>Martin Sulzmann</name>
    </author>
    <link href="http://arxiv.org/abs/1006.3039v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1006.3039v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1006.3159v1</id>
    <updated>2010-06-16T08:39:12Z</updated>
    <published>2010-06-16T08:39:12Z</published>
    <title>Abstract Fixpoint Computations with Numerical Acceleration Methods</title>
    <summary>  Static analysis by abstract interpretation aims at automatically proving
properties of computer programs. To do this, an over-approximation of program
semantics, defined as the least fixpoint of a system of semantic equations,
must be computed. To enforce the convergence of this computation, widening
operator is used but it may lead to coarse results. We propose a new method to
accelerate the computation of this fixpoint by using standard techniques of
numerical analysis. Our goal is to automatically and dynamically adapt the
widening operator in order to maintain precision.
</summary>
    <author>
      <name>Olivier Bouissou</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LMeASI</arxiv:affiliation>
    </author>
    <author>
      <name>Yassamine Seladji</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LMeASI</arxiv:affiliation>
    </author>
    <author>
      <name>Alexandre Chapoutot</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIP6</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/j.entcs.2010.09.004</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/j.entcs.2010.09.004" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Electronic Notes in Theoretical Computer Science (2010) 29-42</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1006.3159v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1006.3159v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.NA" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1007.3023v2</id>
    <updated>2011-02-10T17:57:10Z</updated>
    <published>2010-07-18T17:29:53Z</published>
    <title>Purely Functional Structured Programming</title>
    <summary>  The idea of functional programming has played a big role in shaping today's
landscape of mainstream programming languages. Another concept that dominates
the current programming style is Dijkstra's structured programming. Both
concepts have been successfully married, for example in the programming
language Scala. This paper proposes how the same can be achieved for structured
programming and PURELY functional programming via the notion of LINEAR SCOPE.
One advantage of this proposal is that mainstream programmers can reap the
benefits of purely functional programming like easily exploitable parallelism
while using familiar structured programming syntax and without knowing concepts
like monads. A second advantage is that professional purely functional
programmers can often avoid hard to read functional code by using structured
programming syntax that is often easier to parse mentally.
</summary>
    <author>
      <name>Steven Obua</name>
    </author>
    <link href="http://arxiv.org/abs/1007.3023v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1007.3023v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1007.3183v1</id>
    <updated>2010-07-19T15:28:00Z</updated>
    <published>2010-07-19T15:28:00Z</published>
    <title>A Non-Null Annotation Inferencer for Java Bytecode</title>
    <summary>  We present a non-null annotations inferencer for the Java bytecode language.
We previously proposed an analysis to infer non-null annotations and proved it
soundness and completeness with respect to a state of the art type system. This
paper proposes extensions to our former analysis in order to deal with the Java
bytecode language. We have implemented both analyses and compared their
behaviour on several benchmarks. The results show a substantial improvement in
the precision and, despite being a whole-program analysis, production
applications can be analyzed within minutes.
</summary>
    <author>
      <name>Laurent Hubert</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA - IRISA</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/1512475.1512484</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/1512475.1512484" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">PASTE: Program analysis for software tools and engineering,
  Atlanta, Georgia : United States (2008)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1007.3183v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1007.3183v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1008.0909v1</id>
    <updated>2010-08-05T03:47:48Z</updated>
    <published>2010-08-05T03:47:48Z</published>
    <title>A Heuristic Algorithm for optimizing Page Selection Instructions</title>
    <summary>  Page switching is a technique that increases the memory in microcontrollers
without extending the address buses. This technique is widely used in the
design of 8-bit MCUs. In this paper, we present an algorithm to reduce the
overhead of page switching. To pursue small code size, we place the emphasis on
the allocation of functions into suitable pages with a heuristic algorithm,
thereby the cost-effective placement of page selection instructions. Our
experimental results showed the optimization achieved a reduction in code size
of 13.2 percent.
</summary>
    <author>
      <name>Qing'an Li</name>
    </author>
    <author>
      <name>Yanxiang He</name>
    </author>
    <author>
      <name>Yong Chen</name>
    </author>
    <author>
      <name>Wei Wu</name>
    </author>
    <author>
      <name>Wenwen Xu</name>
    </author>
    <link href="http://arxiv.org/abs/1008.0909v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1008.0909v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1008.3431v1</id>
    <updated>2010-08-20T03:17:43Z</updated>
    <published>2010-08-20T03:17:43Z</published>
    <title>Comparative study of the Pros and Cons of Programming languages Java,
  Scala, C++, Haskell, VB .NET, AspectJ, Perl, Ruby, PHP &amp; Scheme - a Team 11
  COMP6411-S10 Term Report</title>
    <summary>  With the advent of numerous languages it is difficult to realize the edge of
one language in a particular scope over another one. We are making an effort,
realizing these few issues and comparing some main stream languages like Java,
Scala, C++, Haskell, VB .NET, AspectJ, Perl, Ruby, PHP and Scheme keeping in
mind some core issues in program development.
</summary>
    <author>
      <name>Venkatreddy Dwarampudi</name>
    </author>
    <author>
      <name>Shahbaz Singh Dhillon</name>
    </author>
    <author>
      <name>Jivitesh Shah</name>
    </author>
    <author>
      <name>Nikhil Joseph Sebastian</name>
    </author>
    <author>
      <name>Nitin Kanigicharla</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">28 pages, 2 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/1008.3431v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1008.3431v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1008.3561v1</id>
    <updated>2010-08-20T19:50:52Z</updated>
    <published>2010-08-20T19:50:52Z</published>
    <title>Comparative Studies of 10 Programming Languages within 10 Diverse
  Criteria - a Team 10 COMP6411-S10 Term Report</title>
    <summary>  This is a survey on the programming languages: C++, JavaScript, AspectJ, C#,
Haskell, Java, PHP, Scala, Scheme, and BPEL. Our survey work involves a
comparative study of these ten programming languages with respect to the
following criteria: secure programming practices, web application development,
web service composition, OOP-based abstractions, reflection, aspect
orientation, functional programming, declarative programming, batch scripting,
and UI prototyping. We study these languages in the context of the above
mentioned criteria and the level of support they provide for each one of them.
</summary>
    <author>
      <name>Rana Naim</name>
    </author>
    <author>
      <name>Mohammad Fahim Nizam</name>
    </author>
    <author>
      <name>Sheetal Hanamasagar</name>
    </author>
    <author>
      <name>Jalal Noureddine</name>
    </author>
    <author>
      <name>Marinela Miladinova</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">126 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1008.3561v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1008.3561v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1009.0817v1</id>
    <updated>2010-09-04T09:39:53Z</updated>
    <published>2010-09-04T09:39:53Z</published>
    <title>Towards a Property Preserving Transformation from IEC 61131-3 to BIP</title>
    <summary>  We report on a transformation from Sequential Function Charts of the IEC
61131-3 standard to BIP. Our presentation features a description of formal
syntax and semantics representation of the involved languages and
transformation rules. Furthermore, we present a formalism for describing
invariants of IEC 61131-3 systems and establish a notion of invariant
preservation between the two languages. For a subset of our transformation
rules we sketch a proof showing invariant preservation during the
transformation of IEC 61131-3 to BIP and vice versa.
</summary>
    <author>
      <name>Jan Olaf Blech</name>
    </author>
    <author>
      <name>Anton Hattendorf</name>
    </author>
    <author>
      <name>Jia Huang</name>
    </author>
    <link href="http://arxiv.org/abs/1009.0817v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1009.0817v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1009.2900v1</id>
    <updated>2010-09-15T11:43:13Z</updated>
    <published>2010-09-15T11:43:13Z</published>
    <title>Linear-Logic Based Analysis of Constraint Handling Rules with
  Disjunction</title>
    <summary>  Constraint Handling Rules (CHR) is a declarative committed-choice programming
language with a strong relationship to linear logic. Its generalization CHR
with Disjunction (CHRv) is a multi-paradigm declarative programming language
that allows the embedding of horn programs. We analyse the assets and the
limitations of the classical declarative semantics of CHR before we motivate
and develop a linear-logic declarative semantics for CHR and CHRv. We show how
to apply the linear-logic semantics to decide program properties and to prove
operational equivalence of CHRv programs across the boundaries of language
paradigms.
</summary>
    <author>
      <name>Hariolf Betz</name>
    </author>
    <author>
      <name>Thom W. Frühwirth</name>
    </author>
    <link href="http://arxiv.org/abs/1009.2900v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1009.2900v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1009.3174v1</id>
    <updated>2010-09-16T13:38:10Z</updated>
    <published>2010-09-16T13:38:10Z</published>
    <title>Evaluating Call-By-Need on the Control Stack</title>
    <summary>  Ariola and Felleisen's call-by-need {\lambda}-calculus replaces a variable
occurrence with its value at the last possible moment. To support this gradual
notion of substitution, function applications-once established-are never
discharged. In this paper we show how to translate this notion of reduction
into an abstract machine that resolves variable references via the control
stack. In particular, the machine uses the static address of a variable
occurrence to extract its current value from the dynamic control stack.
</summary>
    <author>
      <name>Stephen Chang</name>
    </author>
    <author>
      <name>David Van Horn</name>
    </author>
    <author>
      <name>Matthias Felleisen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Symposium on Trends in Functional Programming (TFP 2010), Norman,
  Oklahoma, May 2010</arxiv:comment>
    <link href="http://arxiv.org/abs/1009.3174v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1009.3174v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1009.3773v1</id>
    <updated>2010-09-20T11:09:27Z</updated>
    <published>2010-09-20T11:09:27Z</published>
    <title>Towards a Study of Meta-Predicate Semantics</title>
    <summary>  We describe and compare design choices for meta-predicate semantics, as found
in representative Prolog module systems and in Logtalk. We look at the
consequences of these design choices from a pragmatic perspective, discussing
explicit qualification semantics, computational reflection support,
expressiveness of meta-predicate declarations, safety of meta-predicate
definitions, portability of meta-predicate definitions, and meta-predicate
performance. Our aim is to provide useful insight for debating meta-predicate
semantics and portability issues based on actual implementations and common
usage patterns.
</summary>
    <author>
      <name>Paulo Moura</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Online proceedings of the Joint Workshop on Implementation of
  Constraint Logic Programming Systems and Logic-based Methods in Programming
  Environments (CICLOPS-WLPE 2010), Edinburgh, Scotland, U.K., July 15, 2010</arxiv:comment>
    <link href="http://arxiv.org/abs/1009.3773v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1009.3773v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.1234v2</id>
    <updated>2012-06-01T01:00:59Z</updated>
    <published>2010-10-06T19:13:38Z</published>
    <title>LR(1) Parser Generation System: LR(1) Error Recovery, Oracles, and
  Generic Tokens</title>
    <summary>  The LR(1) Parser Generation System generates full LR(1) parsers that are
comparable in speed and size to those generated by LALR(1) parser generators,
such as yacc [5]. LR contains a number of novel feature. This paper discusses
three of them in detail: an LR(1) grammar specified automatic error recovery
algorithm, oracles, and generic tokens.
</summary>
    <author>
      <name>Arthur Sorkin</name>
    </author>
    <author>
      <name>Peter Donovan</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1010.1234v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.1234v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.FL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N20" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4; F.4.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.2196v2</id>
    <updated>2010-11-03T22:41:27Z</updated>
    <published>2010-10-11T19:30:25Z</published>
    <title>Optimizing real world applications with GCC Link Time Optimization</title>
    <summary>  GCC has a new infrastructure to support a link time optimization (LTO). The
infrastructure is designed to allow linking of large applications using a
special mode (WHOPR) which support parallelization of the compilation process.
In this paper we present overview of the design and implementation of WHOPR and
present test results of its behavior when optimizing large applications. We
give numbers on compile time, memory usage and code quality comparisons to the
classical file by file based optimization model. In particular we focus on
Firefox web browser. We show main problems seen only when compiling a large
application, such as startup time and code size growth.
</summary>
    <author>
      <name>T. Glek</name>
    </author>
    <author>
      <name>J. Hubicka</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">21 pages, published version</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the 2010 GCC Developers' Summit</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1010.2196v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.2196v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N20" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.5023v1</id>
    <updated>2010-10-24T23:12:28Z</updated>
    <published>2010-10-24T23:12:28Z</published>
    <title>Yacc is dead</title>
    <summary>  We present two novel approaches to parsing context-free languages. The first
approach is based on an extension of Brzozowski's derivative from regular
expressions to context-free grammars. The second approach is based on a
generalization of the derivative to parser combinators. The payoff of these
techniques is a small (less than 250 lines of code), easy-to-implement parsing
library capable of parsing arbitrary context-free grammars into lazy parse
forests. Implementations for both Scala and Haskell are provided. Preliminary
experiments with S-Expressions parsed millions of tokens per second, which
suggests this technique is efficient enough for use in practice.
</summary>
    <author>
      <name>Matthew Might</name>
    </author>
    <author>
      <name>David Darais</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">18 pages; submitted October 2009 to ESOP; rejected</arxiv:comment>
    <link href="http://arxiv.org/abs/1010.5023v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.5023v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.5570v1</id>
    <updated>2010-10-27T05:04:32Z</updated>
    <published>2010-10-27T05:04:32Z</published>
    <title>Primitives for Contract-based Synchronization</title>
    <summary>  We investigate how contracts can be used to regulate the interaction between
processes. To do that, we study a variant of the concurrent constraints
calculus presented in [1], featuring primitives for multi-party synchronization
via contracts. We proceed in two directions. First, we exploit our primitives
to model some contract-based interactions. Then, we discuss how several models
for concurrency can be expressed through our primitives. In particular, we
encode the pi-calculus and graph rewriting.
</summary>
    <author>
      <name>Massimo Bartoletti</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Matematica e Informatica, Università degli Studi di Cagliari</arxiv:affiliation>
    </author>
    <author>
      <name>Roberto Zunino</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Ingegneria e Scienza dell'Informazione, Università degli studi di Trento</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.38.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.38.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2010, arXiv:1010.5308</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 38, 2010, pp. 67-82</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1010.5570v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.5570v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.5582v1</id>
    <updated>2010-10-27T06:12:50Z</updated>
    <published>2010-10-27T06:12:50Z</published>
    <title>Mechanized semantics</title>
    <summary>  The goal of this lecture is to show how modern theorem provers---in this
case, the Coq proof assistant---can be used to mechanize the specification of
programming languages and their semantics, and to reason over individual
programs and over generic program transformations, as typically found in
compilers. The topics covered include: operational semantics (small-step,
big-step, definitional interpreters); a simple form of denotational semantics;
axiomatic semantics and Hoare logic; generation of verification conditions,
with application to program proof; compilation to virtual machine code and its
proof of correctness; an example of an optimizing program transformation (dead
code elimination) and its proof of correctness.
</summary>
    <author>
      <name>Xavier Leroy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.3233/978-1-60750-100-8-195</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.3233/978-1-60750-100-8-195" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logics and languages for reliability and security, J. Esparza and
  B. Spanfelner and O. Grumberg (Ed.) (2010) 195-224</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1010.5582v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.5582v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1011.5640v1</id>
    <updated>2010-11-25T15:11:42Z</updated>
    <published>2010-11-25T15:11:42Z</published>
    <title>SICStus Prolog -- the first 25 years</title>
    <summary>  SICStus Prolog has evolved for nearly 25 years. This is an appropriate point
in time for revisiting the main language and design decisions, and try to
distill some lessons. SICStus Prolog was conceived in a context of multiple,
conflicting Prolog dialect camps and a fledgling standardization effort. We
reflect on the impact of this effort and role model implementations on our
development. After summarizing the development history, we give a guided tour
of the system anatomy, exposing some designs that were not published before. We
give an overview of our new interactive development environment, and describe a
sample of key applications. Finally, we try to identify key good and not so
good design decisions.
</summary>
    <author>
      <name>Mats Carlsson</name>
    </author>
    <author>
      <name>Per Mildner</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Theory and Practice of Logic Programming (TPLP)</arxiv:comment>
    <link href="http://arxiv.org/abs/1011.5640v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1011.5640v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1011.6223v3</id>
    <updated>2011-09-27T14:14:21Z</updated>
    <published>2010-11-29T13:24:11Z</published>
    <title>Just-In-Time compilation of OCaml byte-code</title>
    <summary>  This paper presents various improvements that were applied to OCamlJIT2, a
Just-In-Time compiler for the OCaml byte-code virtual machine. OCamlJIT2
currently runs on various Unix-like systems with x86 or x86-64 processors. The
improvements, including the new x86 port, are described in detail, and
performance measures are given, including a direct comparison of OCamlJIT2 to
OCamlJIT.
</summary>
    <author>
      <name>Benedikt Meurer</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 6 figures, 3 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/1011.6223v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1011.6223v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1012.2294v4</id>
    <updated>2011-08-15T09:21:52Z</updated>
    <published>2010-12-10T15:37:06Z</published>
    <title>Syntax and Semantics of Babel-17</title>
    <summary>  We present Babel-17, the first programming language for purely functional
structured programming (PFSP). Earlier work illustrated PFSP in the framework
of a toy research language. Babel-17 takes this earlier work to a new level by
showing how PFSP can be combined with pattern matching, object oriented
programming, and features like concurrency, lazy evaluation, memoization and
support for lenses.
</summary>
    <author>
      <name>Steven Obua</name>
    </author>
    <link href="http://arxiv.org/abs/1012.2294v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1012.2294v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1012.4240v1</id>
    <updated>2010-12-20T05:11:57Z</updated>
    <published>2010-12-20T05:11:57Z</published>
    <title>ECLiPSe - from LP to CLP</title>
    <summary>  ECLiPSe is a Prolog-based programming system, aimed at the development and
deployment of constraint programming applications. It is also used for teaching
most aspects of combinatorial problem solving, e.g. problem modelling,
constraint programming, mathematical programming, and search techniques. It
uses an extended Prolog as its high-level modelling and control language,
complemented by several constraint solver libraries, interfaces to third-party
solvers, an integrated development environment and interfaces for embedding
into host environments. This paper discusses language extensions,
implementation aspects, components and tools that we consider relevant on the
way from Logic Programming to Constraint Logic Programming.
</summary>
    <author>
      <name>Joachim Schimpf</name>
    </author>
    <author>
      <name>Kish Shen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Theory and Practice of Logic Programming (TPLP)</arxiv:comment>
    <link href="http://arxiv.org/abs/1012.4240v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1012.4240v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1012.5494v2</id>
    <updated>2014-04-19T20:28:54Z</updated>
    <published>2010-12-26T03:33:09Z</published>
    <title>Contents of COMP6411 Summer 2010 Final Reports on Comparative Studies of
  Programming Languages</title>
    <summary>  This index covers the lecture notes and the final course project reports for
COMP6411 Summer 2010 at Concordia University, Montreal, Canada, Comparative
Study of Programming Languages by 4 teams trying compare a set of common
criteria and their applicability to about 10 distinct programming languages,
where 5 language choices were provided by the instructor and five were picked
by each team and each student individually compared two of the 10 and then the
team did a summary synthesis across all 10 languages. Their findings are posted
here for further reference, comparative studies, and analysis.
</summary>
    <author>
      <name>Serguei A. Mokhov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">an index</arxiv:comment>
    <link href="http://arxiv.org/abs/1012.5494v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1012.5494v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1012.6035v2</id>
    <updated>2011-12-03T18:49:44Z</updated>
    <published>2010-12-29T20:49:10Z</published>
    <title>Models of quantum computation and quantum programming languages</title>
    <summary>  The goal of the presented paper is to provide an introduction to the basic
computational models used in quantum information theory. We review various
models of quantum Turing machine, quantum circuits and quantum random access
machine (QRAM) along with their classical counterparts. We also provide an
introduction to quantum programming languages, which are developed using the
QRAM model. We review the syntax of several existing quantum programming
languages and discuss their features and limitations.
</summary>
    <author>
      <name>J. A. Miszczak</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2478/v10175-011-0039-5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2478/v10175-011-0039-5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">23 pages, 10 figures, 9 listings</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Bull. Pol. Acad. Sci.-Tech. Sci., Vol. 59, No. 3 (2011), pp.
  305-324</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1012.6035v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1012.6035v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1101.3356v2</id>
    <updated>2011-01-19T14:07:27Z</updated>
    <published>2011-01-17T23:51:59Z</published>
    <title>CAL: A Language for Aggregating Functional and Extrafunctional
  Constraints in Streaming Networks</title>
    <summary>  In this article we present the {\em Constraint Aggregation Language} (CAL), a
declarative language for describing properties of stateless program components
that interact by exchanging messages. CAL allows one to describe functional as
well as extra-functional behaviours, such as computation latency. The CAL
language intention is to be able to describe the behaviour of so-called boxes
in the context of S-Net. However, the language would find application in other
coordination models based on stateless components.
</summary>
    <author>
      <name>Alex Shafarenko</name>
    </author>
    <author>
      <name>Raimund Kirner</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1101.3356v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1101.3356v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1101.4429v1</id>
    <updated>2011-01-24T01:39:52Z</updated>
    <published>2011-01-24T01:39:52Z</published>
    <title>Session Types = Intersection Types + Union Types</title>
    <summary>  We propose a semantically grounded theory of session types which relies on
intersection and union types. We argue that intersection and union types are
natural candidates for modeling branching points in session types and we show
that the resulting theory overcomes some important defects of related
behavioral theories. In particular, intersections and unions provide a native
solution to the problem of computing joins and meets of session types. Also,
the subtyping relation turns out to be a pre-congruence, while this is not
always the case in related behavioral theories.
</summary>
    <author>
      <name>Luca Padovani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Torino, Italy</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.45.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.45.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ITRS 2010, arXiv:1101.4104</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 45, 2011, pp. 71-89</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1101.4429v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1101.4429v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1101.4430v1</id>
    <updated>2011-01-24T01:40:00Z</updated>
    <published>2011-01-24T01:40:00Z</published>
    <title>Equality, Quasi-Implicit Products, and Large Eliminations</title>
    <summary>  This paper presents a type theory with a form of equality reflection:
provable equalities can be used to coerce the type of a term. Coercions and
other annotations, including implicit arguments, are dropped during reduction
of terms. We develop the metatheory for an undecidable version of the system
with unannotated terms. We then devise a decidable system with annotated terms,
justified in terms of the unannotated system. Finally, we show how the approach
can be extended to account for large eliminations, using what we call
quasi-implicit products.
</summary>
    <author>
      <name>Vilhelm Sjöberg</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Pennsylvania</arxiv:affiliation>
    </author>
    <author>
      <name>Aaron Stump</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">The University of Iowa</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.45.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.45.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ITRS 2010, arXiv:1101.4104</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 45, 2011, pp. 90-100</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1101.4430v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1101.4430v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1101.4732v1</id>
    <updated>2011-01-25T06:57:41Z</updated>
    <published>2011-01-25T06:57:41Z</published>
    <title>Contracts for Abstract Processes in Service Composition</title>
    <summary>  Contracts are a well-established approach for describing and analyzing
behavioral aspects of web service compositions. The theory of contracts comes
equipped with a notion of compatibility between clients and servers that
ensures that every possible interaction between compatible clients and servers
will complete successfully. It is generally agreed that real applications often
require the ability of exposing just partial descriptions of their behaviors,
which are usually known as abstract processes. We propose a formal
characterization of abstraction as an extension of the usual symbolic
bisimulation and we recover the notion of abstraction in the context of
contracts.
</summary>
    <author>
      <name>Maria Grazia Buscemi</name>
    </author>
    <author>
      <name>Hernán Melgratti</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.46.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.46.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings FIT 2010, arXiv:1101.4266</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 46, 2011, pp. 9-27</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1101.4732v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1101.4732v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1101.5569v1</id>
    <updated>2011-01-28T16:42:00Z</updated>
    <published>2011-01-28T16:42:00Z</published>
    <title>T2Script Programming Language</title>
    <summary>  Event-driven programming is used in many fields of modern Computer Science.
In event-driven programming languages user interacts with a program by
triggering the events. We propose a new approach that we denote command-event
driven programming in which the user interacts with a program by means of
events and commands. We describe a new programming language, T2Script, which is
based on command-event driven paradigm. T2Script has been already implemented
and used in one of industrial products. We describe the rationale, basic
concepts and advanced programming techniques of new T2Script language. We
evaluate the new language and show what advantages and limitations it has.
</summary>
    <author>
      <name>Piotr J. Puczynski</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">27 pages, 9 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1101.5569v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1101.5569v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1102.2003v2</id>
    <updated>2011-02-11T17:03:17Z</updated>
    <published>2011-02-09T22:44:26Z</published>
    <title>Parsing Reflective Grammars</title>
    <summary>  Existing technology can parse arbitrary context-free grammars, but only a
single, static grammar per input. In order to support more powerful
syntax-extension systems, we propose reflective grammars, which can modify
their own syntax during parsing. We demonstrate and prove the correctness of an
algorithm for parsing reflective grammars. The algorithm is based on Earley's
algorithm, and we prove that it performs asymptotically no worse than Earley's
algorithm on ordinary context-free grammars.
</summary>
    <author>
      <name>Paul Stansifer</name>
    </author>
    <author>
      <name>Mitchell Wand</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">A shorter version appears in LDTA 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1102.2003v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1102.2003v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1102.4971v2</id>
    <updated>2011-06-10T14:32:34Z</updated>
    <published>2011-02-24T12:28:36Z</published>
    <title>Elementary affine $lambda$-calculus with multithreading and side effects</title>
    <summary>  Linear logic provides a framework to control the complexity of higher-order
functional programs. We present an extension of this framework to programs with
multithreading and side effects focusing on the case of elementary time. Our
main contributions are as follows. First, we provide a new combinatorial proof
of termination in elementary time for the functional case. Second, we develop
an extension of the approach to a call-by-value $lambda$-calculus with
multithreading and side effects. Third, we introduce an elementary affine type
system that guarantees the standard subject reduction and progress properties.
Finally, we illustrate the programming of iterative functions with side effects
in the presented formalism.
</summary>
    <author>
      <name>Antoine Madet</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Roberto M. Amadio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1102.4971v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1102.4971v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1105.0106v1</id>
    <updated>2011-04-30T18:26:49Z</updated>
    <published>2011-04-30T18:26:49Z</published>
    <title>Semantic Solutions to Program Analysis Problems</title>
    <summary>  Problems in program analysis can be solved by developing novel program
semantics and deriving abstractions conventionally. For over thirty years,
higher-order program analysis has been sold as a hard problem. Its solutions
have required ingenuity and complex models of approximation. We claim that this
difficulty is due to premature focus on abstraction and propose a new approach
that emphasizes semantics. Its simplicity enables new analyses that are beyond
the current state of the art.
</summary>
    <author>
      <name>Sam Tobin-Hochstadt</name>
    </author>
    <author>
      <name>David Van Horn</name>
    </author>
    <link href="http://arxiv.org/abs/1105.0106v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1105.0106v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1105.0966v1</id>
    <updated>2011-05-05T01:29:17Z</updated>
    <published>2011-05-05T01:29:17Z</published>
    <title>A resource analysis of the pi-calculus</title>
    <summary>  We give a new treatment of the pi-calculus based on the semantic theory of
separation logic, continuing a research program begun by Hoare and O'Hearn.
Using a novel resource model that distinguishes between public and private
ownership, we refactor the operational semantics so that sending, receiving,
and allocating are commands that influence owned resources. These ideas lead
naturally to two denotational models: one for safety and one for liveness. Both
models are fully abstract for the corresponding observables, but more
importantly both are very simple. The close connections with the model theory
of separation logic (in particular, with Brookes's action trace model) give
rise to a logic of processes and resources.
</summary>
    <author>
      <name>Aaron Turon</name>
    </author>
    <author>
      <name>Mitchell Wand</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Preliminary version for MFPS 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1105.0966v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1105.0966v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68Q55" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1105.1985v3</id>
    <updated>2011-05-15T11:24:39Z</updated>
    <published>2011-05-10T15:59:09Z</published>
    <title>A Step-indexed Semantic Model of Types for the Call-by-Name Lambda
  Calculus</title>
    <summary>  Step-indexed semantic models of types were proposed as an alternative to
purely syntactic safety proofs using subject-reduction. Building upon the work
by Appel and others, we introduce a generalized step-indexed model for the
call-by-name lambda calculus. We also show how to prove type safety of general
recursion in our call-by-name model.
</summary>
    <author>
      <name>Benedikt Meurer</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages, 6 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1105.1985v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1105.1985v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1106.2578v1</id>
    <updated>2011-06-14T00:06:58Z</updated>
    <published>2011-06-14T00:06:58Z</published>
    <title>Extensible Pattern Matching in an Extensible Language</title>
    <summary>  Pattern matching is a widely used technique in functional languages,
especially those in the ML and Haskell traditions, where it is at the core of
the semantics. In languages in the Lisp tradition, in contrast, pattern
matching it typically provided by libraries built with macros. We present
match, a sophisticated pattern matcher for Racket, implemented as language
extension. using macros. The system supports novel and widely-useful
pattern-matching forms, and is itself extensible. The extensibility of match is
implemented via a general technique for creating extensible language
extensions.
</summary>
    <author>
      <name>Sam Tobin-Hochstadt</name>
    </author>
    <link href="http://arxiv.org/abs/1106.2578v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1106.2578v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1106.2637v1</id>
    <updated>2011-06-14T08:34:11Z</updated>
    <published>2011-06-14T08:34:11Z</published>
    <title>Using Bounded Model Checking to Focus Fixpoint Iterations</title>
    <summary>  Two classical sources of imprecision in static analysis by abstract
interpretation are widening and merge operations. Merge operations can be done
away by distinguishing paths, as in trace partitioning, at the expense of
enumerating an exponential number of paths. In this article, we describe how to
avoid such systematic exploration by focusing on a single path at a time,
designated by SMT-solving. Our method combines well with acceleration
techniques, thus doing away with widenings as well in some cases. We illustrate
it over the well-known domain of convex polyhedra.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>Laure Gonnord</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIFL</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1106.2637v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1106.2637v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1106.3457v1</id>
    <updated>2011-06-17T12:01:01Z</updated>
    <published>2011-06-17T12:01:01Z</published>
    <title>Extensional Higher-Order Logic Programming</title>
    <summary>  We propose a purely extensional semantics for higher-order logic programming.
In this semantics program predicates denote sets of ordered tuples, and two
predicates are equal iff they are equal as sets. Moreover, every program has a
unique minimum Herbrand model which is the greatest lower bound of all Herbrand
models of the program and the least fixed-point of an immediate consequence
operator. We also propose an SLD-resolution proof procedure which is proven
sound and complete with respect to the minimum model semantics. In other words,
we provide a purely extensional theoretical framework for higher-order logic
programming which generalizes the familiar theory of classical (first-order)
logic programming.
</summary>
    <author>
      <name>A. Charalambidis</name>
    </author>
    <author>
      <name>K. Handjopoulos</name>
    </author>
    <author>
      <name>P. Rondogiannis</name>
    </author>
    <author>
      <name>W. W. Wadge</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">45 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1106.3457v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1106.3457v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.0190v1</id>
    <updated>2011-07-31T18:01:14Z</updated>
    <published>2011-07-31T18:01:14Z</published>
    <title>On the Correctness of Pull-Tabbing</title>
    <summary>  Pull-tabbing is an evaluation approach for functional logic computations,
based on a graph transformation recently proposed, which avoids making
irrevocable non-deterministic choices that would jeopardize the completeness of
computations. In contrast to other approaches with this property, it does not
require an upfront cloning of a possibly large portion of the choice's context.
We formally define the pull-tab transformation, characterize the class of
programs for which the transformation is intended, extend the computations in
these programs to include the transformation, and prove the correctness of the
extended computations.
</summary>
    <author>
      <name>Sergio Antoy</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068411000263</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068411000263" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, vol. 11, no. 4-5, pp.
  713-730, 2011</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1108.0190v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.0190v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.0329v1</id>
    <updated>2011-08-01T14:56:56Z</updated>
    <published>2011-08-01T14:56:56Z</published>
    <title>Observational equivalences for linear logic CC languages</title>
    <summary>  Linear logic Concurrent Constraint programming (LCC) is an extension of
concurrent constraint programming (CC) where the constraint system is based on
Girard's linear logic instead of the classical logic. In this paper we address
the problem of program equivalence for this programming framework. For this
purpose, we present a structural operational semantics for LCC based on a label
transition system and investigate different notions of observational
equivalences inspired by the state of art of process algebras. Then, we
demonstrate that the asynchronous \pi-calculus can be viewed as simple
syntactical restrictions of LCC. Finally we show LCC observational equivalences
can be transposed straightforwardly to classical Concurrent Constraint
languages and Constraint Handling Rules, and investigate the resulting
equivalences.
</summary>
    <author>
      <name>Rémy Haemmerlé</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068411000123</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068411000123" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, 11(4-5): 469-485, 2011</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1108.0329v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.0329v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.0464v1</id>
    <updated>2011-08-02T02:27:04Z</updated>
    <published>2011-08-02T02:27:04Z</published>
    <title>Interaction and observation, categorically</title>
    <summary>  This paper proposes to use dialgebras to specify the semantics of interactive
systems in a natural way. Dialgebras are a conservative extension of
coalgebras. In this categorical model, from the point of view that we provide,
the notions of observation and interaction are separate features. This is
useful, for example, in the specification of process equivalences, which are
obtained as kernels of the homomorphisms of dialgebras. As an example we
present the asynchronous semantics of the CCS.
</summary>
    <author>
      <name>Vincenzo Ciancia</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.59.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.59.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2011, arXiv:1108.0144</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 59, 2011, pp. 25-36</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1108.0464v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.0464v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.0466v1</id>
    <updated>2011-08-02T02:27:18Z</updated>
    <published>2011-08-02T02:27:18Z</published>
    <title>Polymorphic Endpoint Types for Copyless Message Passing</title>
    <summary>  We present PolySing#, a calculus that models process interaction based on
copyless message passing, in the style of Singularity OS. We equip the calculus
with a type system that accommodates polymorphic endpoint types, which are a
variant of polymorphic session types, and we show that well-typed processes are
free from faults, leaks, and communication errors. The type system is
essentially linear, although linearity alone may leave room for scenarios where
well-typed processes leak memory. We identify a condition on endpoint types
that prevents these leaks from occurring.
</summary>
    <author>
      <name>Viviana Bono</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Torino, Italy</arxiv:affiliation>
    </author>
    <author>
      <name>Luca Padovani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Torino, Italy</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.59.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.59.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2011, arXiv:1108.0144</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 59, 2011, pp. 52-67</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1108.0466v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.0466v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.2360v1</id>
    <updated>2011-08-11T09:28:01Z</updated>
    <published>2011-08-11T09:28:01Z</published>
    <title>A type checking algorithm for qualified session types</title>
    <summary>  We present a type checking algorithm for establishing a session-based
discipline in the pi calculus of Milner, Parrow and Walker. Our session types
are qualified as linear or unrestricted. Linearly typed communication channels
are guaranteed to occur in exactly one thread, possibly multiple times;
afterwards they evolve as unrestricted channels. Session protocols are
described by a type constructor that denotes the two ends of one and the same
communication channel. We ensure the soundness of the algorithm by showing that
processes consuming all linear resources are accepted by a type system
preserving typings during the computation and that type checking is consistent
w.r.t. structural congruence.
</summary>
    <author>
      <name>Marco Giunti</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA and LIX, Ecole Polytechnique, France</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.61.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.61.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings WWV 2011, arXiv:1108.2085</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 61, 2011, pp. 96-114</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1108.2360v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.2360v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.4547v1</id>
    <updated>2011-08-23T10:44:28Z</updated>
    <published>2011-08-23T10:44:28Z</published>
    <title>Language Support for Declarative Future Commitments</title>
    <summary>  Sequential programming and work-flow programming are two useful, but
radically different, ways of describing computational processing. Of the two,
it is sequential programming that we teach all programmers and support by
programming languages, whether in procedural, objectoriented, or functional
paradigms. We teach workflow as a secondary style of problem decomposition for
use in special situations, like distributed or networked processing. Both
styles offer complementary advantages, but the fact that they employ radically
different models for ownership of continuations interferes with our ability to
integrate them in a way that allows them to be taught and used in a single
programming language. This paper describes a programming language construct,
declarative future commitments, that permit better integration of the two.
</summary>
    <author>
      <name>William Harrison</name>
    </author>
    <link href="http://arxiv.org/abs/1108.4547v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.4547v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.0781v1</id>
    <updated>2011-09-05T01:56:53Z</updated>
    <published>2011-09-05T01:56:53Z</published>
    <title>Tutorial on Online Partial Evaluation</title>
    <summary>  This paper is a short tutorial introduction to online partial evaluation. We
show how to write a simple online partial evaluator for a simple, pure,
first-order, functional programming language. In particular, we show that the
partial evaluator can be derived as a variation on a compositionally defined
interpreter. We demonstrate the use of the resulting partial evaluator for
program optimization in the context of model-driven development.
</summary>
    <author>
      <name>William R. Cook</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Texas at Austin</arxiv:affiliation>
    </author>
    <author>
      <name>Ralf Lämmel</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Koblenz-Landau</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.66.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.66.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings DSL 2011, arXiv:1109.0323</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 66, 2011, pp. 168-180</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1109.0781v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.0781v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.0786v1</id>
    <updated>2011-09-05T01:57:27Z</updated>
    <published>2011-09-05T01:57:27Z</published>
    <title>Accurate Programming: Thinking about programs in terms of properties</title>
    <summary>  Accurate programming is a practical approach to producing high quality
programs. It combines ideas from test-automation, test-driven development,
agile programming, and other state of the art software development methods. In
addition to building on approaches that have proven effective in practice, it
emphasizes concepts that help programmers sharpen their understanding of both
the problems they are solving and the solutions they come up with. This is
achieved by encouraging programmers to think about programs in terms of
properties.
</summary>
    <author>
      <name>Walid Taha</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Halmstad University</arxiv:affiliation>
    </author>
    <author>
      <name>Veronica Gaspes</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Halmstad University</arxiv:affiliation>
    </author>
    <author>
      <name>Rex Page</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Oklahoma</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.66.13</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.66.13" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings DSL 2011, arXiv:1109.0323</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 66, 2011, pp. 236-260</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1109.0786v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.0786v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.1421v1</id>
    <updated>2011-09-07T11:20:46Z</updated>
    <published>2011-09-07T11:20:46Z</published>
    <title>Profiling parallel Mercury programs with ThreadScope</title>
    <summary>  The behavior of parallel programs is even harder to understand than the
behavior of sequential programs. Parallel programs may suffer from any of the
performance problems affecting sequential programs, as well as from several
problems unique to parallel systems. Many of these problems are quite hard (or
even practically impossible) to diagnose without help from specialized tools.
We present a proposal for a tool for profiling the parallel execution of
Mercury programs, a proposal whose implementation we have already started. This
tool is an adaptation and extension of the ThreadScope profiler that was first
built to help programmers visualize the execution of parallel Haskell programs.
</summary>
    <author>
      <name>Paul Bone</name>
    </author>
    <author>
      <name>Zoltan Somogyi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">21st Workshop on Logic-based methods in Programming Environments.
  Lexington, Kentucky, July 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1109.1421v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.1421v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.1905v1</id>
    <updated>2011-09-09T06:38:06Z</updated>
    <published>2011-09-09T06:38:06Z</published>
    <title>Modular Abstractions of Reactive Nodes using Disjunctive Invariants</title>
    <summary>  We wish to abstract nodes in a reactive programming language, such as Lustre,
into nodes with a simpler control structure, with a bound on the number of
control states. In order to do so, we compute disjunctive invariants in
predicate abstraction, with a bounded number of disjuncts, then we abstract the
node, each disjunct representing an abstract state. The computation of the
disjunctive invariant is performed by a form of quantifier elimination
expressed using SMT-solving. The same method can also be used to obtain
disjunctive loop invariants.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>Martin Bodin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG, DI</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1109.1905v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.1905v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.2405v1</id>
    <updated>2011-09-12T08:48:00Z</updated>
    <published>2011-09-12T08:48:00Z</published>
    <title>Stratified Static Analysis Based on Variable Dependencies</title>
    <summary>  In static analysis by abstract interpretation, one often uses widening
operators in order to enforce convergence within finite time to an inductive
invariant. Certain widening operators, including the classical one over finite
polyhedra, exhibit an unintuitive behavior: analyzing the program over a subset
of its variables may lead a more precise result than analyzing the original
program! In this article, we present simple workarounds for such behavior.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>Julien Le Guen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG, ST Microelectronics</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1109.2405v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.2405v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.2548v1</id>
    <updated>2011-09-12T17:49:01Z</updated>
    <published>2011-09-12T17:49:01Z</published>
    <title>RedAlert: Determinacy Inference for Prolog</title>
    <summary>  This paper revisits the problem of determinacy inference addressing the
problem of how to uniformly handle cut. To this end a new semantics is
introduced for cut, which is abstracted to systematically derive a backward
analysis that derives conditions sufficient for a goal to succeed at most once.
The method is conceptionally simpler and easier to implement than existing
techniques, whilst improving the latter's handling of cut. Formal arguments
substantiate correctness and experimental work, and a tool called 'RedAlert'
demonstrates the method's generality and applicability.
</summary>
    <author>
      <name>Jael Kriener</name>
    </author>
    <author>
      <name>Andy King</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, 2011, 27th Int'l.
  Conference on Logic Programming (ICLP'11) Special Issue, volume 11, issue 4-5</arxiv:comment>
    <link href="http://arxiv.org/abs/1109.2548v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.2548v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1110.1029v2</id>
    <updated>2011-10-27T16:09:44Z</updated>
    <published>2011-10-05T16:05:41Z</published>
    <title>Towards a native toplevel for the OCaml language</title>
    <summary>  This paper presents the current state of our work on an interactive toplevel
for the OCaml language based on the optimizing native code compiler and
runtime. Our native toplevel is up to 100 times faster than the default OCaml
toplevel, which is based on the byte code compiler and interpreter. It uses
Just-In-Time techniques to compile toplevel phrases to native code at runtime,
and currently works with various Unix-like systems running on x86 or x86-64
processors.
</summary>
    <author>
      <name>Marcell Fischbach</name>
    </author>
    <author>
      <name>Benedikt Meurer</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages, 5 figures, technical report</arxiv:comment>
    <link href="http://arxiv.org/abs/1110.1029v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1110.1029v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1110.4160v1</id>
    <updated>2011-10-19T02:29:14Z</updated>
    <published>2011-10-19T02:29:14Z</published>
    <title>A Type System for Unstructured Locking that Guarantees Deadlock Freedom
  without Imposing a Lock Ordering</title>
    <summary>  Deadlocks occur in concurrent programs as a consequence of cyclic resource
acquisition between threads. In this paper we present a novel type system that
guarantees deadlock freedom for a language with references, unstructured
locking primitives, and locks which are implicitly associated with references.
The proposed type system does not impose a strict lock acquisition order and
thus increases programming language expressiveness.
</summary>
    <author>
      <name>Prodromos Gerakios</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">National Technical University of Athens</arxiv:affiliation>
    </author>
    <author>
      <name>Nikolaos Papaspyrou</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">National Technical University of Athens</arxiv:affiliation>
    </author>
    <author>
      <name>Konstantinos Sagonas</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">National Technical University of Athens</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.69.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.69.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2010, arXiv:1110.3853</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 69, 2011, pp. 44-58</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1110.4160v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1110.4160v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.3.2; D.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1111.3606v3</id>
    <updated>2015-02-12T13:12:12Z</updated>
    <published>2011-11-15T18:32:29Z</published>
    <title>tym: Typed Matlab</title>
    <summary>  Although, many scientists and engineers use Octave or MATLAB as their
preferred programming language, dynamic nature of these languages can lead to
slower running-time of programs written in these languages compared to programs
written in languages which are not as dynamic, like C, C++ and Fortran. In this
work we developed a translator for a new programming language (tym) which tries
to address performance issues, common in scientific programs, by adding new
constructs to a subset of Octave/MATLAB language. Our translator compiles
programs written in tym, to efficient C++ code.
</summary>
    <author>
      <name>Hamid A. Toussi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented at University of Sistan and Baluchestan, 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1111.3606v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1111.3606v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.MS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1111.4737v1</id>
    <updated>2011-11-21T05:24:23Z</updated>
    <published>2011-11-21T05:24:23Z</published>
    <title>Compiler Optimization: A Case for the Transformation Tool Contest</title>
    <summary>  An optimizing compiler consists of a front end parsing a textual programming
language into an intermediate representation (IR), a middle end performing
optimizations on the IR, and a back end lowering the IR to a target
representation (TR) built of operations supported by the target hardware. In
modern compiler construction graph-based IRs are employed. Optimization and
lowering tasks can then be implemented with graph transformation rules. This
case provides two compiler tasks to evaluate the participating tools regarding
performance.
</summary>
    <author>
      <name>Sebastian Buchwald</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <author>
      <name>Edgar Jakumeit</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.74.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.74.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TTC 2011, arXiv:1111.4407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 74, 2011, pp. 6-16</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1111.4737v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1111.4737v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1111.4751v1</id>
    <updated>2011-11-21T05:26:14Z</updated>
    <published>2011-11-21T05:26:14Z</published>
    <title>Solving the TTC 2011 Reengineering Case with GrGen.NET</title>
    <summary>  The challenge of the Reengineering Case is to extract a state machine model
out of the abstract syntax graph of a Java program. The extracted state machine
offers a reduced view on the full program graph and thus helps to understand
the program regarding the question of interest. We tackle this task employing
the general purpose graph rewrite system GrGen.NET (www.grgen.net).
</summary>
    <author>
      <name>Edgar Jakumeit</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <author>
      <name>Sebastian Buchwald</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.74.16</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.74.16" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TTC 2011, arXiv:1111.4407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 74, 2011, pp. 168-180</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1111.4751v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1111.4751v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1111.4755v1</id>
    <updated>2011-11-21T05:26:57Z</updated>
    <published>2011-11-21T05:26:57Z</published>
    <title>Saying Hello World with MOLA - A Solution to the TTC 2011 Instructive
  Case</title>
    <summary>  This paper describes the solution of Hello World transformations in MOLA
transformation language. Transformations implementing the task are relatively
straightforward and easily inferable from the task specification. The required
additional steps related to model import and export are also described.
</summary>
    <author>
      <name>Elina Kalnina</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Institute of Mathematics and Computer Science, University of Latvia</arxiv:affiliation>
    </author>
    <author>
      <name>Audris Kalnins</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Institute of Mathematics and Computer Science, University of Latvia</arxiv:affiliation>
    </author>
    <author>
      <name>Agris Sostaks</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Institute of Mathematics and Computer Science, University of Latvia</arxiv:affiliation>
    </author>
    <author>
      <name>Janis Iraids</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Institute of Mathematics and Computer Science, University of Latvia</arxiv:affiliation>
    </author>
    <author>
      <name>Edgars Celms</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Institute of Mathematics and Computer Science, University of Latvia</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.74.21</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.74.21" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TTC 2011, arXiv:1111.4407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 74, 2011, pp. 237-252</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1111.4755v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1111.4755v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.2396v3</id>
    <updated>2012-09-07T01:22:05Z</updated>
    <published>2011-12-11T20:29:40Z</published>
    <title>Decorated proofs for computational effects: States</title>
    <summary>  The syntax of an imperative language does not mention explicitly the state,
while its denotational semantics has to mention it. In this paper we show that
the equational proofs about an imperative language may hide the state, in the
same way as the syntax does.
</summary>
    <author>
      <name>Jean-Guillaume Dumas</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LJK, Université de Grenoble, France</arxiv:affiliation>
    </author>
    <author>
      <name>Dominique Duval</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LJK, Université de Grenoble, France</arxiv:affiliation>
    </author>
    <author>
      <name>Laurent Fousse</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LJK, Université de Grenoble, France</arxiv:affiliation>
    </author>
    <author>
      <name>Jean-Claude Reynaud</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LJK, Université de Grenoble, France</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.93.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.93.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ACCAT 2012, arXiv:1208.4301</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 93, 2012, pp. 45-59</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1112.2396v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.2396v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.CT" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.3785v1</id>
    <updated>2011-12-16T12:25:28Z</updated>
    <published>2011-12-16T12:25:28Z</published>
    <title>Nesting Probabilistic Inference</title>
    <summary>  When doing inference in ProbLog, a probabilistic extension of Prolog, we
extend SLD resolution with some additional bookkeeping. This additional
information is used to compute the probabilistic results for a probabilistic
query. In Prolog's SLD, goals are nested very naturally. In ProbLog's SLD,
nesting probabilistic queries interferes with the probabilistic bookkeeping. In
order to support nested probabilistic inference we propose the notion of a
parametrised ProbLog engine. Nesting becomes possible by suspending and
resuming instances of ProbLog engines. With our approach we realise several
extensions of ProbLog such as meta-calls, negation, and answers of
probabilistic goals.
</summary>
    <author>
      <name>Theofrastos Mantadelis</name>
    </author>
    <author>
      <name>Gerda Janssens</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Online Proceedings of the 11th International Colloquium on
  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),
  Lexington, KY, U.S.A., July 10, 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1112.3785v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.3785v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.3786v2</id>
    <updated>2011-12-23T08:49:22Z</updated>
    <published>2011-12-16T12:25:42Z</published>
    <title>High-Level Multi-Threading in hProlog</title>
    <summary>  A new high-level interface to multi-threading in Prolog, implemented in
hProlog, is described. Modern CPUs often contain multiple cores and through
high-level multi-threading a programmer can leverage this power without having
to worry about low-level details. Two common types of high-level explicit
parallelism are discussed: independent and-parallelism and competitive
or-parallelism. A new type of explicit parallelism, pipeline parallelism, is
proposed. This new type can be used in certain cases where independent
and-parallelism and competitive or-parallelism cannot be used.
</summary>
    <author>
      <name>Timon Van Overveldt</name>
    </author>
    <author>
      <name>Bart Demoen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Online Proceedings of the 11th International Colloquium on
  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),
  Lexington, KY, U.S.A., July 10, 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1112.3786v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.3786v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.3787v1</id>
    <updated>2011-12-16T12:26:59Z</updated>
    <published>2011-12-16T12:26:59Z</published>
    <title>Approximating Constraint Propagation in Datalog</title>
    <summary>  We present a technique exploiting Datalog with aggregates to improve the
performance of programs with arithmetic (in)equalities. Our approach employs a
source-to-source program transformation which approximates the propagation
technique from Constraint Programming. The experimental evaluation of the
approach shows good run time speed-ups on a range of non-recursive as well as
recursive programs. Furthermore, our technique improves upon the previously
reported in the literature constraint magic set transformation approach.
</summary>
    <author>
      <name>Dario Campagna</name>
    </author>
    <author>
      <name>Beata Sarna-Starosta</name>
    </author>
    <author>
      <name>Tom Schrijvers</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Online Proceedings of the 11th International Colloquium on
  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),
  Lexington, KY, U.S.A., July 10, 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1112.3787v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.3787v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.3789v1</id>
    <updated>2011-12-16T12:27:19Z</updated>
    <published>2011-12-16T12:27:19Z</published>
    <title>An Implementation of Bubbling</title>
    <summary>  Non-determinism is of great importance in functional logic programming. It
provides expressiveness and efficiency to functional logic computations. In
this paper we describe an implementation of the multi-paradigm functional logic
language Curry. The evaluation strategy employed by the implementation is based
on definitional trees and needed narrowing for deterministic operations, while
non-deterministic operations will depend on the graph transformation, bubbling.
Bubbling preserves the completeness of non-deterministic operations and avoids
unnecessary large-scale reconstruction of expressions done by other approaches.
</summary>
    <author>
      <name>Abdulla Alqaddoumi</name>
    </author>
    <author>
      <name>Enrico Pontelli</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Online Proceedings of the 11th International Colloquium on
  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),
  Lexington, KY, U.S.A., July 10, 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1112.3789v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.3789v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.3833v1</id>
    <updated>2011-12-16T14:48:42Z</updated>
    <published>2011-12-16T14:48:42Z</published>
    <title>Dependently Typed Programming based on Automated Theorem Proving</title>
    <summary>  Mella is a minimalistic dependently typed programming language and
interactive theorem prover implemented in Haskell. Its main purpose is to
investigate the effective integration of automated theorem provers in a pure
and simple setting. Such integrations are essential for supporting program
development in dependently typed languages. We integrate the equational theorem
prover Waldmeister and test it on more than 800 proof goals from the TPTP
library. In contrast to previous approaches, the reconstruction of Waldmeister
proofs within Mella is quite robust and does not generate a significant
overhead to proof search. Mella thus yields a template for integrating more
expressive theorem provers in more sophisticated languages.
</summary>
    <author>
      <name>Alasdair Armstrong</name>
    </author>
    <author>
      <name>Simon Foster</name>
    </author>
    <author>
      <name>Georg Struth</name>
    </author>
    <link href="http://arxiv.org/abs/1112.3833v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.3833v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; F.3.1; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.4106v3</id>
    <updated>2012-08-01T04:56:07Z</updated>
    <published>2011-12-18T01:42:11Z</published>
    <title>Dependent Types for JavaScript</title>
    <summary>  We present Dependent JavaScript (DJS), a statically-typed dialect of the
imperative, object-oriented, dynamic language. DJS supports the particularly
challenging features such as run-time type-tests, higher-order functions,
extensible objects, prototype inheritance, and arrays through a combination of
nested refinement types, strong updates to the heap, and heap unrolling to
precisely track prototype hierarchies. With our implementation of DJS, we
demonstrate that the type system is expressive enough to reason about a variety
of tricky idioms found in small examples drawn from several sources, including
the popular book JavaScript: The Good Parts and the SunSpider benchmark suite.
</summary>
    <author>
      <name>Ravi Chugh</name>
    </author>
    <author>
      <name>David Herman</name>
    </author>
    <author>
      <name>Ranjit Jhala</name>
    </author>
    <link href="http://arxiv.org/abs/1112.4106v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.4106v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.6096v1</id>
    <updated>2011-12-28T10:49:18Z</updated>
    <published>2011-12-28T10:49:18Z</published>
    <title>Solving XCSP problems by using Gecode</title>
    <summary>  Gecode is one of the most efficient libraries that can be used for constraint
solving. However, using it requires dealing with C++ programming details. On
the other hand several formats for representing constraint networks have been
proposed. Among them, XCSP has been proposed as a format based on XML which
allows us to represent constraints defined either extensionally or
intensionally, permits global constraints and has been the standard format of
the international competition of constraint satisfaction problems solvers. In
this paper we present a plug-in for solving problems specified in XCSP by
exploiting the Gecode solver. This is done by dynamically translating
constraints into Gecode library calls, thus avoiding the need to interact with
C++.
</summary>
    <author>
      <name>Massimo Morara</name>
    </author>
    <author>
      <name>Jacopo Mauro</name>
    </author>
    <author>
      <name>Maurizio Gabbrielli</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages, http://ceur-ws.org/Vol-810 CILC 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1112.6096v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.6096v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1201.0874v1</id>
    <updated>2012-01-04T11:22:08Z</updated>
    <published>2012-01-04T11:22:08Z</published>
    <title>Applicative Bisimulations for Delimited-Control Operators</title>
    <summary>  We develop a behavioral theory for the untyped call-by-value lambda calculus
extended with the delimited-control operators shift and reset. For this
calculus, we discuss the possible observable behaviors and we define an
applicative bisimilarity that characterizes contextual equivalence. We then
compare the applicative bisimilarity and the CPS equivalence, a relation on
terms often used in studies of control operators. In the process, we illustrate
how bisimilarity can be used to prove equivalence of terms with
delimited-control effects.
</summary>
    <author>
      <name>Dariusz Biernacki</name>
    </author>
    <author>
      <name>Serguei Lenglet</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">A long version of an article accepted at FoSSaCS 2012</arxiv:comment>
    <link href="http://arxiv.org/abs/1201.0874v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1201.0874v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; D.3.3; F.3.2; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1201.2312v1</id>
    <updated>2012-01-10T08:24:07Z</updated>
    <published>2012-01-10T08:24:07Z</published>
    <title>Actor Garbage Collection in Distributed Systems using Graph
  Transformation</title>
    <summary>  A lot of research work has been done in the area of Garbage collection for
both uniprocessor and distributed systems. Actors are associated with activity
(thread) and hence usual garbage collection algorithms cannot be applied for
them. Hence a separate algorithm should be used to collect them. If we
transform the active reference graph into a graph which captures all the
features of actors and looks like passive reference graph then any passive
reference graph algorithm can be applied for it. But the cost of transformation
and optimization are the core issues. An attempt has been made to walk through
these issues.
</summary>
    <author>
      <name>B. Seetha Lakshmi</name>
    </author>
    <author>
      <name>C. D. Balapriya</name>
    </author>
    <author>
      <name>R. Soniya</name>
    </author>
    <link href="http://arxiv.org/abs/1201.2312v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1201.2312v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1201.4262v1</id>
    <updated>2012-01-20T11:11:37Z</updated>
    <published>2012-01-20T11:11:37Z</published>
    <title>Secondary use of data in EHR systems</title>
    <summary>  We show how to use aspect-oriented programming to separate security and trust
issues from the logical design of mobile, distributed systems. The main
challenge is how to enforce various types of security policies, in particular
predictive access control policies - policies based on the future behavior of a
program. A novel feature of our approach is that advice is able to analyze the
future use of data. We consider a number of different security policies,
concerning both primary and secondary use of data, some of which can only be
enforced by analysis of process continuations.
</summary>
    <author>
      <name>Fan Yang</name>
    </author>
    <author>
      <name>Chris Hankin</name>
    </author>
    <author>
      <name>Flemming Nielson</name>
    </author>
    <author>
      <name>Hanne Riis Nielson</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">40 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1201.4262v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1201.4262v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1201.4719v1</id>
    <updated>2012-01-23T14:06:32Z</updated>
    <published>2012-01-23T14:06:32Z</published>
    <title>On Synergy of Metal, Slicing, and Symbolic Execution</title>
    <summary>  We introduce a novel technique for finding real errors in programs. The
technique is based on a synergy of three well-known methods: metacompilation,
slicing, and symbolic execution. More precisely, we instrument a given program
with a code that tracks runs of state machines representing various kinds of
errors. Next we slice the program to reduce its size without affecting runs of
state machines. And then we symbolically execute the sliced program. Depending
on the kind of symbolic execution, the technique can be applied as a
stand-alone bug finding technique, or to weed out some false positives from an
output of another bug-finding tool. We provide several examples demonstrating
the practical applicability of our technique.
</summary>
    <author>
      <name>Jiří Slabý</name>
    </author>
    <author>
      <name>Jan Strejček</name>
    </author>
    <author>
      <name>Marek Trtík</name>
    </author>
    <link href="http://arxiv.org/abs/1201.4719v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1201.4719v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1201.6188v1</id>
    <updated>2012-01-30T11:58:01Z</updated>
    <published>2012-01-30T11:58:01Z</published>
    <title>On the realizability of contracts in dishonest systems</title>
    <summary>  We develop a theory of contracting systems, where behavioural contracts may
be violated by dishonest participants after they have been agreed upon - unlike
in traditional approaches based on behavioural types. We consider the contracts
of \cite{CastagnaPadovaniGesbert09toplas}, and we embed them in a calculus that
allows distributed participants to advertise contracts, reach agreements, query
the fulfilment of contracts, and realise them (or choose not to).
  Our contract theory makes explicit who is culpable at each step of a
computation. A participant is honest in a given context S when she is not
culpable in each possible interaction with S. Our main result is a sufficient
criterion for classifying a participant as honest in all possible contexts.
</summary>
    <author>
      <name>Massimo Bartoletti</name>
    </author>
    <author>
      <name>Emilio Tuosto</name>
    </author>
    <author>
      <name>Roberto Zunino</name>
    </author>
    <link href="http://arxiv.org/abs/1201.6188v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1201.6188v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.2086v2</id>
    <updated>2012-03-01T20:44:48Z</updated>
    <published>2012-02-09T19:22:13Z</published>
    <title>Typing Copyless Message Passing</title>
    <summary>  We present a calculus that models a form of process interaction based on
copyless message passing, in the style of Singularity OS. The calculus is
equipped with a type system ensuring that well-typed processes are free from
memory faults, memory leaks, and communication errors. The type system is
essentially linear, but we show that linearity alone is inadequate, because it
leaves room for scenarios where well-typed processes leak significant amounts
of memory. We address these problems basing the type system upon an original
variant of session types.
</summary>
    <author>
      <name>Viviana Bono</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Università di Torino</arxiv:affiliation>
    </author>
    <author>
      <name>Luca Padovani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Università di Torino</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-8(1:17)2012</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-8(1:17)2012" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">50 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 8, Issue 1 (March 2,
  2012) lmcs:798</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1202.2086v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.2086v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.2, F.3.3, F.3.1, D.4.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.2736v1</id>
    <updated>2012-02-13T14:14:00Z</updated>
    <published>2012-02-13T14:14:00Z</published>
    <title>Function call overhead benchmarks with MATLAB, Octave, Python, Cython
  and C</title>
    <summary>  We consider the overhead of function calls in the programming languages
MATLAB/Octave, Python, Cython and C. In many applications a function has to be
called very often inside a loop. One such application in numerical analysis is
the finite element method where integrals have to be computed on each element
in a loop. The called functions can often be evaluated efficiently but the
function call itself may be time-consuming. We present a benchmark whose goal
is to identify and quantify optimization potentials with respect to time
consumption caused by function calls in the mentioned programming languages.
</summary>
    <author>
      <name>André Gaul</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">The benchmark's source code is available under GPL3 at
  https://bitbucket.org/andrenarchy/funcall</arxiv:comment>
    <link href="http://arxiv.org/abs/1202.2736v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.2736v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.MS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.NA" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.2922v1</id>
    <updated>2012-02-14T03:01:53Z</updated>
    <published>2012-02-14T03:01:53Z</published>
    <title>Tracing monadic computations and representing effects</title>
    <summary>  In functional programming, monads are supposed to encapsulate computations,
effectfully producing the final result, but keeping to themselves the means of
acquiring it. For various reasons, we sometimes want to reveal the internals of
a computation. To make that possible, in this paper we introduce monad
transformers that add the ability to automatically accumulate observations
about the course of execution as an effect. We discover that if we treat the
resulting trace as the actual result of the computation, we can find new
functionality in existing monads, notably when working with non-terminating
computations.
</summary>
    <author>
      <name>Maciej Piróg</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, University of Oxford</arxiv:affiliation>
    </author>
    <author>
      <name>Jeremy Gibbons</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, University of Oxford</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.76.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.76.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MSFP 2012, arXiv:1202.2407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 76, 2012, pp. 90-111</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1202.2922v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.2922v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.5959v2</id>
    <updated>2012-02-28T15:33:59Z</updated>
    <published>2012-02-27T14:49:00Z</published>
    <title>Normal Form Bisimulations for Delimited-Control Operators</title>
    <summary>  We define a notion of normal form bisimilarity for the untyped call-by-value
lambda calculus extended with the delimited-control operators shift and reset.
Normal form bisimilarities are simple, easy-to-use behavioral equivalences
which relate terms without having to test them within all contexts (like
contextual equivalence), or by applying them to function arguments (like
applicative bisimilarity). We prove that the normal form bisimilarity for shift
and reset is sound but not complete w.r.t. contextual equivalence and we define
up-to techniques that aim at simplifying bisimulation proofs. Finally, we
illustrate the simplicity of the techniques we develop by proving several
equivalences on terms.
</summary>
    <author>
      <name>Dariusz Biernacki</name>
    </author>
    <author>
      <name>Serguei Lenglet</name>
    </author>
    <link href="http://arxiv.org/abs/1202.5959v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.5959v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; D.3.3; F.3.2; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1203.0835v1</id>
    <updated>2012-03-05T09:07:18Z</updated>
    <published>2012-03-05T09:07:18Z</published>
    <title>Functional Logic Programming with Generalized Circular Coinduction</title>
    <summary>  We propose a method to adapt functional logic programming to deal with
reasoning on coinductively interpreted programs as well as on inductively
interpreted programs. In order to do so, we consider a class of objects
interesting for this coinductive interpretation, namely regular terms. We show
how the usual data structures can be adapted to capture these objects. We adapt
the operational semantics of Curry to interpret programs coinductively. We
illustrate this method with several examples that show the working of our
method and several cases in which it could be useful. Finally, we suggest how
the declarative semantics can be adapted suitably.
</summary>
    <author>
      <name>Ronald de Haan</name>
    </author>
    <link href="http://arxiv.org/abs/1203.0835v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1203.0835v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1203.1539v1</id>
    <updated>2012-03-07T17:05:09Z</updated>
    <published>2012-03-07T17:05:09Z</published>
    <title>Programming with Algebraic Effects and Handlers</title>
    <summary>  Eff is a programming language based on the algebraic approach to
computational effects, in which effects are viewed as algebraic operations and
effect handlers as homomorphisms from free algebras. Eff supports first-class
effects and handlers through which we may easily define new computational
effects, seamlessly combine existing ones, and handle them in novel ways. We
give a denotational semantics of eff and discuss a prototype implementation
based on it. Through examples we demonstrate how the standard effects are
treated in eff, and how eff supports programming techniques that use various
forms of delimited continuations, such as backtracking, breadth-first search,
selection functionals, cooperative multi-threading, and others.
</summary>
    <author>
      <name>Andrej Bauer</name>
    </author>
    <author>
      <name>Matija Pretnar</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/j.jlamp.2014.02.001</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/j.jlamp.2014.02.001" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Logical and Algebraic Methods in Programming. Volume
  84, Issue 1, January 2015, Pages 108-123</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1203.1539v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1203.1539v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1203.1986v1</id>
    <updated>2012-03-09T04:19:19Z</updated>
    <published>2012-03-09T04:19:19Z</published>
    <title>Type-Preserving Flow Analysis and Interprocedural Unboxing (Extended
  Version)</title>
    <summary>  Interprocedural flow analysis can be used to eliminate otherwise unnecessary
heap allocated objects (unboxing), and in previous work we have shown how to do
so while maintaining correctness with respect to the garbage collector. In this
paper, we extend the notion of flow analysis to incorporate types, enabling
analysis and optimization of typed programs. We apply this typed analysis to
specify a type preserving interprocedural unboxing optimization, and prove that
the optimization preserves both type and GC safety along with program
semantics. We also show that the unboxing optimization can be applied
independently to separately compiled program modules, and prove via a
contextual equivalence result that unboxing a module in isolation preserves
program semantics.
</summary>
    <author>
      <name>Neal Glew</name>
    </author>
    <author>
      <name>Leaf Petersen</name>
    </author>
    <link href="http://arxiv.org/abs/1203.1986v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1203.1986v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1203.5303v1</id>
    <updated>2012-03-23T17:22:06Z</updated>
    <published>2012-03-23T17:22:06Z</published>
    <title>Bound Analysis of Imperative Programs with the Size-change Abstraction
  (extended version)</title>
    <summary>  The size-change abstraction (SCA) is an important program abstraction for
termination analysis, which has been successfully implemented in many tools for
functional and logic programs. In this paper, we demonstrate that SCA is also a
highly effective abstract domain for the bound analysis of imperative programs.
  We have implemented a bound analysis tool based on SCA for imperative
programs. We abstract programs in a pathwise and context dependent manner,
which enables our tool to analyze real-world programs effectively. Our work
shows that SCA captures many of the essential ideas of previous termination and
bound analysis and goes beyond in a conceptually simpler framework.
</summary>
    <author>
      <name>Florian Zuleger</name>
    </author>
    <author>
      <name>Sumit Gulwani</name>
    </author>
    <author>
      <name>Moritz Sinn</name>
    </author>
    <author>
      <name>Helmut Veith</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended version of SAS 2011 conference article</arxiv:comment>
    <link href="http://arxiv.org/abs/1203.5303v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1203.5303v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1204.1147v1</id>
    <updated>2012-04-05T08:33:16Z</updated>
    <published>2012-04-05T08:33:16Z</published>
    <title>Numerical Invariants through Convex Relaxation and Max-Strategy
  Iteration</title>
    <summary>  In this article we develop a max-strategy improvement algorithm for computing
least fixpoints of operators on on the reals that are point-wise maxima of
finitely many monotone and order-concave operators. Computing the uniquely
determined least fixpoint of such operators is a problem that occurs frequently
in the context of numerical program/systems verification/analysis. As an
example for an application we discuss how our algorithm can be applied to
compute numerical invariants of programs by abstract interpretation based on
quadratic templates.
</summary>
    <author>
      <name>Thomas Martin Gawlitza</name>
    </author>
    <author>
      <name>Helmut Seidl</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">42 pages, conference version appears in the proceedings of the Static
  Analysis Symposium 2010</arxiv:comment>
    <link href="http://arxiv.org/abs/1204.1147v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1204.1147v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1204.5541v1</id>
    <updated>2012-04-25T02:41:47Z</updated>
    <published>2012-04-25T02:41:47Z</published>
    <title>The Design of GP 2</title>
    <summary>  This papers defines the syntax and semantics of GP 2, a revised version of
the graph programming language GP. New concepts are illustrated and explained
with example programs. Changes to the first version of GP include an improved
type system for labels, a built-in marking mechanism for nodes and edges, a
more powerful edge predicate for conditional rule schemata, and functions
returning the indegree and outdegree of matched nodes. Moreover, the semantics
of the branching and loop statement have been simplified to allow their
efficient implementation.
</summary>
    <author>
      <name>Detlef Plump</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">The University of York</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.82.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.82.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings WRS 2011, arXiv:1204.5318</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 82, 2012, pp. 1-16</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1204.5541v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1204.5541v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1204.6411v1</id>
    <updated>2012-04-28T14:26:56Z</updated>
    <published>2012-04-28T14:26:56Z</published>
    <title>Catroid: A Mobile Visual Programming System for Children</title>
    <summary>  Catroid is a free and open source visual programming language, programming
environment, image manipulation program, and website. Catroid allows casual and
first-time users starting from age eight to develop their own animations and
games solely using their Android phones or tablets. Catroid also allows to
wirelessly control external hardware such as Lego Mindstorms robots via
Bluetooth, Bluetooth Arduino boards, as well as Parrot's popular and
inexpensive AR.Drone quadcopters via WiFi.
</summary>
    <author>
      <name>Wolfgang Slany</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">4 pages. Demo paper at the 11th International Conference on
  Interaction Design and Children (IDC 2012)</arxiv:comment>
    <link href="http://arxiv.org/abs/1204.6411v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1204.6411v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CY" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.HC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.RO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1206.5112v1</id>
    <updated>2012-06-22T11:07:14Z</updated>
    <published>2012-06-22T11:07:14Z</published>
    <title>Lucretia - a type system for objects in languages with reflection</title>
    <summary>  Object-oriented scripting languages such as JavaScript or Python gain in
popularity due to their flexibility. Still, the growing code bases written in
the languages call for methods that make possible to automatically control the
properties of the programs that ensure their stability in the running time. We
propose a type system, called Lucretia, that makes possible to control the
object structure of languages with reflection. Subject reduction and soundness
of the type system with respect to the semantics of the language is proved.
</summary>
    <author>
      <name>Viviana Bono</name>
    </author>
    <author>
      <name>Marcin Benke</name>
    </author>
    <author>
      <name>Aleksy Schubert</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">21 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1206.5112v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1206.5112v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.3; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1207.6369v1</id>
    <updated>2012-07-26T18:56:59Z</updated>
    <published>2012-07-26T18:56:59Z</published>
    <title>Concept of the abstract program</title>
    <summary>  The aim of this paper is to alter the abstract definition of the program of
the theoretical programming model which has been developed at Eotvos Lorand
University for many years in order to investigate methods that support
designing correct programs. The motivation of this modification was that the
dynamic properties of programs appear in the model. This new definition of the
program gives a hand to extend the model with the concept of subprograms while
the earlier results of the original programming model are preserved.
</summary>
    <author>
      <name>T. Gregorics</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Acta Universitatis Sapientiae, Informatica, 4, 1 (2012) 7-16</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1207.6369v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1207.6369v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N30" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1207.6541v1</id>
    <updated>2012-07-27T13:40:23Z</updated>
    <published>2012-07-27T13:40:23Z</published>
    <title>Guided Grammar Convergence. Full Case Study Report. Generated by
  converge::Guided</title>
    <summary>  This report is meant to be used as auxiliary material for the guided grammar
convergence technique proposed earlier as problem-specific improvement in the
topic of convergence of grammars. It contains a narrated MegaL megamodel, as
well as full results of the guided grammar convergence experiment on the
Factorial Language, with details about each grammar source packaged in a
readable form. All formulae used within this document, are generated
automatically by the convergence infrastructure in order to avoid any mistakes.
The generator source code and the source of the introduction text can be found
publicly available in the Software Language Processing Suite repository.
</summary>
    <author>
      <name>Vadim Zaytsev</name>
    </author>
    <link href="http://arxiv.org/abs/1207.6541v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1207.6541v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.FL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.2; F.4.3; I.2.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1207.6816v1</id>
    <updated>2012-07-30T01:11:12Z</updated>
    <published>2012-07-30T01:11:12Z</published>
    <title>Transforming floundering into success</title>
    <summary>  We show how logic programs with "delays" can be transformed to programs
without delays in a way which preserves information concerning floundering
(also known as deadlock). This allows a declarative (model-theoretic),
bottom-up or goal independent approach to be used for analysis and debugging of
properties related to floundering. We rely on some previously introduced
restrictions on delay primitives and a key observation which allows properties
such as groundness to be analysed by approximating the (ground) success set.
This paper is to appear in Theory and Practice of Logic Programming (TPLP).
  Keywords: Floundering, delays, coroutining, program analysis, abstract
interpretation, program transformation, declarative debugging
</summary>
    <author>
      <name>Lee Naish</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S147106841200035X</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S147106841200035X" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Number of pages: 24 Number of figures: 9 Number of tables: none</arxiv:comment>
    <link href="http://arxiv.org/abs/1207.6816v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1207.6816v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1208.0535v1</id>
    <updated>2012-08-02T16:38:13Z</updated>
    <published>2012-08-02T16:38:13Z</published>
    <title>Modular Type-Safety Proofs using Dependant Types</title>
    <summary>  While methods of code abstraction and reuse are widespread and well
researched, methods of proof abstraction and reuse are still emerging. We
consider the use of dependent types for this purpose, introducing a completely
mechanical approach to proof composition. We show that common techniques for
abstracting algorithms over data structures naturally translate to abstractions
over proofs. We first introduce a language composed of a series of smaller
language components tied together by standard techniques from Malcom (1990). We
proceed by giving proofs of type preservation for each language component and
show that the basic ideas used in composing the syntactic data structures can
be applied to their semantics as well.
</summary>
    <author>
      <name>Christopher Schwaab</name>
    </author>
    <author>
      <name>Jeremy G. Siek</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1208.0535v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1208.0535v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1209.1711v1</id>
    <updated>2012-09-08T12:31:50Z</updated>
    <published>2012-09-08T12:31:50Z</published>
    <title>Programming Languages for Scientific Computing</title>
    <summary>  Scientific computation is a discipline that combines numerical analysis,
physical understanding, algorithm development, and structured programming.
Several yottacycles per year on the world's largest computers are spent
simulating problems as diverse as weather prediction, the properties of
material composites, the behavior of biomolecules in solution, and the quantum
nature of chemical compounds. This article is intended to review specfic
languages features and their use in computational science. We will review the
strengths and weaknesses of different programming styles, with examples taken
from widely used scientific codes.
</summary>
    <author>
      <name>Matthew G. Knepley</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">21 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Encyclopedia of Applied and Computational Mathematics, Springer,
  2012</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1209.1711v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1209.1711v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.MS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1209.5145v1</id>
    <updated>2012-09-24T03:55:45Z</updated>
    <published>2012-09-24T03:55:45Z</published>
    <title>Julia: A Fast Dynamic Language for Technical Computing</title>
    <summary>  Dynamic languages have become popular for scientific computing. They are
generally considered highly productive, but lacking in performance. This paper
presents Julia, a new dynamic language for technical computing, designed for
performance from the beginning by adapting and extending modern programming
language techniques. A design based on generic functions and a rich type system
simultaneously enables an expressive programming model and successful type
inference, leading to good performance for a wide range of programs. This makes
it possible for much of the Julia library to be written in Julia itself, while
also incorporating best-of-breed C and Fortran libraries.
</summary>
    <author>
      <name>Jeff Bezanson</name>
    </author>
    <author>
      <name>Stefan Karpinski</name>
    </author>
    <author>
      <name>Viral B. Shah</name>
    </author>
    <author>
      <name>Alan Edelman</name>
    </author>
    <link href="http://arxiv.org/abs/1209.5145v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1209.5145v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1210.2297v2</id>
    <updated>2012-10-09T12:43:36Z</updated>
    <published>2012-10-08T14:34:25Z</published>
    <title>Diagrammatic confluence for Constraint Handling Rules</title>
    <summary>  Confluence is a fundamental property of Constraint Handling Rules (CHR)
since, as in other rewriting formalisms, it guarantees that the computations
are not dependent on rule application order, and also because it implies the
logical consistency of the program declarative view. In this paper we are
concerned with proving the confluence of non-terminating CHR programs. For this
purpose, we derive from van Oostrom's decreasing diagrams method a novel
criterion on CHR critical pairs that generalizes all preexisting criteria. We
subsequently improve on a result on the modularity of CHR confluence, which
permits modular combinations of possibly non-terminating confluent programs,
without loss of confluence.
</summary>
    <author>
      <name>Rémy Haemmerlé</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068412000270</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068412000270" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, 12(4-5): 737-753, 2012</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1210.2297v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1210.2297v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1210.3937v1</id>
    <updated>2012-10-15T08:31:38Z</updated>
    <published>2012-10-15T08:31:38Z</published>
    <title>Introduction to the 28th International Conference on Logic Programming
  Special Issue</title>
    <summary>  We are proud to introduce this special issue of the Journal of Theory and
Practice of Logic Programming (TPLP), dedicated to the full papers accepted for
the 28th International Conference on Logic Programming (ICLP). The ICLP
meetings started in Marseille in 1982 and since then constitute the main venue
for presenting and discussing work in the area of logic programming.
</summary>
    <author>
      <name>Agostino Dovier</name>
    </author>
    <author>
      <name>Vítor Santos Costa</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068412000300</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068412000300" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">TPLP 12 (4-5): 421-426, 2012</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1210.3937v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1210.3937v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1210.5935v1</id>
    <updated>2012-10-22T15:36:56Z</updated>
    <published>2012-10-22T15:36:56Z</published>
    <title>GADT meet Subtyping</title>
    <summary>  While generalized abstract datatypes (GADT) are now considered
well-understood, adding them to a language with a notion of subtyping comes
with a few surprises. What does it mean for a GADT parameter to be covariant?
The answer turns out to be quite subtle. It involves fine-grained properties of
the subtyping relation that raise interesting design questions. We allow
variance annotations in GADT definitions, study their soundness, and present a
sound and complete algorithm to check them. Our work may be applied to
real-world ML-like languages with explicit subtyping such as OCaml, or to
languages with general subtyping constraints.
</summary>
    <author>
      <name>Gabriel Scherer</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>Didier Rémy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">No. RR-8114 (2012)</arxiv:comment>
    <link href="http://arxiv.org/abs/1210.5935v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1210.5935v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1210.6114v1</id>
    <updated>2012-10-23T02:55:15Z</updated>
    <published>2012-10-23T02:55:15Z</published>
    <title>Adding Sessions to BPEL</title>
    <summary>  By considering an essential subset of the BPEL orchestration language, we
define SeB, a session based style of this subset. We discuss the formal
semantics of SeB and we present its main properties. We use a new approach to
address the formal semantics, based on a translation into so-called control
graphs. Our semantics handles control links and addresses the static semantics
that prescribes the valid usage of variables. We also provide the semantics of
collections of networked services.
  Relying on these semantics, we define precisely what is meant by interaction
safety, paving the way to the formal analysis of safe interactions between BPEL
services.
</summary>
    <author>
      <name>Jonathan Michaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Télécom ParisTech</arxiv:affiliation>
    </author>
    <author>
      <name>Elie Najm</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Télécom ParisTech</arxiv:affiliation>
    </author>
    <author>
      <name>Alessandro Fantechi</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Università degli Studi di Firenze</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.98.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.98.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings WWV 2012, arXiv:1210.5783</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 98, 2012, pp. 60-76</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1210.6114v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1210.6114v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1211.6192v1</id>
    <updated>2012-11-27T02:37:00Z</updated>
    <published>2012-11-27T02:37:00Z</published>
    <title>Static Analysis of Lockless Microcontroller C Programs</title>
    <summary>  Concurrently accessing shared data without locking is usually a subject to
race conditions resulting in inconsistent or corrupted data. However, there are
programs operating correctly without locking by exploiting the atomicity of
certain operations on a specific hardware. In this paper, we describe how to
precisely analyze lockless microcontroller C programs with interrupts by taking
the hardware architecture into account. We evaluate this technique in an
octagon-based value range analysis using access-based localization to increase
efficiency.
</summary>
    <author>
      <name>Eva Beckschulze</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Embedded Software Laboratory RWTH Aachen University, Germany</arxiv:affiliation>
    </author>
    <author>
      <name>Sebastian Biallas</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Embedded Software Laboratory RWTH Aachen University, Germany</arxiv:affiliation>
    </author>
    <author>
      <name>Stefan Kowalewski</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Embedded Software Laboratory RWTH Aachen University, Germany</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.102.10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.102.10" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings SSV 2012, arXiv:1211.5873</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 102, 2012, pp. 103-114</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1211.6192v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1211.6192v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AR" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1212.6844v1</id>
    <updated>2012-12-31T09:20:05Z</updated>
    <published>2012-12-31T09:20:05Z</published>
    <title>Improving Robustness via Disjunctive Statements in Imperative
  Programming</title>
    <summary>  To deal with failures as simply as possible, we propose a new foun- dation
for the core (untyped) C, which is based on a new logic called task logic or
imperative logic. We then introduce a sequential-disjunctive statement of the
form S : R. This statement has the following semantics: execute S and R
sequentially. It is considered a success if at least one of S;R is a success.
This statement is useful for dealing with inessential errors without explicitly
catching them.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <author>
      <name>Sungwoo Hur</name>
    </author>
    <author>
      <name>Mi-Young Park</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1587/transinf.E96.D.2036</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1587/transinf.E96.D.2036" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">IEICE transaction on information and system, vol.E96-D, no. 9,
  Sep, 2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1212.6844v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1212.6844v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1301.2903v1</id>
    <updated>2013-01-14T10:22:57Z</updated>
    <published>2013-01-14T10:22:57Z</published>
    <title>GADTs meet subtyping</title>
    <summary>  While generalized algebraic datatypes (\GADTs) are now considered
well-understood, adding them to a language with a notion of subtyping comes
with a few surprises. What does it mean for a \GADT parameter to be covariant?
The answer turns out to be quite subtle. It involves fine-grained properties of
the subtyping relation that raise interesting design questions. We allow
variance annotations in \GADT definitions, study their soundness, and present a
sound and complete algorithm to check them. Our work may be applied to
real-world ML-like languages with explicit subtyping such as OCaml, or to
languages with general subtyping constraints.
</summary>
    <author>
      <name>Gabriel Scherer</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>Didier Rémy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: substantial text overlap with arXiv:1210.5935</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">22nd European Symposium on Programming (ESOP), Rome : Italy (2013)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1301.2903v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1301.2903v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1301.4779v1</id>
    <updated>2013-01-21T08:12:22Z</updated>
    <published>2013-01-21T08:12:22Z</published>
    <title>Formal Verification of Hardware Synthesis</title>
    <summary>  We report on the implementation of a certified compiler for a high-level
hardware description language (HDL) called Fe-Si (FEatherweight SynthesIs).
Fe-Si is a simplified version of Bluespec, an HDL based on a notion of guarded
atomic actions. Fe-Si is defined as a dependently typed deep embedding in Coq.
The target language of the compiler corresponds to a synthesisable subset of
Verilog or VHDL. A key aspect of our approach is that input programs to the
compiler can be defined and proved correct inside Coq. Then, we use extraction
and a Verilog back-end (written in OCaml) to get a certified version of a
hardware design.
</summary>
    <author>
      <name>Thomas Braibant</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>Adam Chlipala</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CSAIL</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-642-39799-8_14</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-642-39799-8_14" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Computer Aided Verification, Saint Petersburg : Russie,
  F\'ed\'eration De (2013)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1301.4779v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1301.4779v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1301.5076v1</id>
    <updated>2013-01-22T05:17:40Z</updated>
    <published>2013-01-22T05:17:40Z</published>
    <title>Mathematics Is Imprecise</title>
    <summary>  We commonly think of mathematics as bringing precision to application
domains, but its relationship with computer science is more complex. This
experience report on the use of Racket and Haskell to teach a required first
university CS course to students with very good mathematical skills focusses on
the ways that programming forces one to get the details right, with consequent
benefits in the mathematical domain. Conversely, imprecision in mathematical
abstractions and notation can work to the benefit of beginning programmers, if
handled carefully.
</summary>
    <author>
      <name>Prabhakar Ragde</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Waterloo</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.106.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.106.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TFPIE 2012, arXiv:1301.4650</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 106, 2013, pp. 40-49</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1301.5076v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1301.5076v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CY" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1;K.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1301.6260v1</id>
    <updated>2013-01-26T14:25:54Z</updated>
    <published>2013-01-26T14:25:54Z</published>
    <title>Problems of Inheritance at Java Inner Class</title>
    <summary>  Single inheritance has been widely accepted in the current programming
practice to avoid the complication that incurred by multiple inheritance.
Single inheritance enhances the reusability of codes and eliminates the
confusion of identical methods that possibly defined in two superclasses.
However, the mechanism of inner class in Java potentially reintroduces the
problems encountered by multiple inheritance. When the depth of Java inner
class is increased, the problem becomes severe. This paper aims at exposing the
problems of inheritance at the Java inner class. In addition, a measure is
proposed to evaluate the potential problem of inheritance for Java inner class
</summary>
    <author>
      <name>Sim-Hui Tee</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">4 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1301.6260v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1301.6260v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1301.7680v1</id>
    <updated>2013-01-31T16:55:52Z</updated>
    <published>2013-01-31T16:55:52Z</published>
    <title>Efficient Support for Mode-Directed Tabling in the YapTab Tabling System</title>
    <summary>  Mode-directed tabling is an extension to the tabling technique that supports
the definition of mode operators for specifying how answers are inserted into
the table space. In this paper, we focus our discussion on the efficient
support for mode directed-tabling in the YapTab tabling system. We discuss 7
different mode operators and explain how we have extended and optimized
YapTab's table space organization to support them. Initial experimental results
show that our implementation compares favorably with the B-Prolog and XSB
state-of-the-art Prolog tabling systems.
</summary>
    <author>
      <name>João Santos</name>
    </author>
    <author>
      <name>Ricardo Rocha</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in CICLOPS 2012. 15 Pages, 12 Figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1301.7680v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1301.7680v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1302.6325v4</id>
    <updated>2013-05-13T06:51:13Z</updated>
    <published>2013-02-26T06:34:42Z</published>
    <title>A Note on "A polynomial-time algorithm for global value numbering"</title>
    <summary>  A Global Value Numbering(GVN) algorithm is considered to be complete (or
precise), if it can detect all Herbrand equivalences among expressions in a
program. A polynomial time algorithm for GVN is presented by Gulwani and Necula
(2006). Here we present two problems with this algorithm that prevents
detection of some of the Herbrand equivalences among program expressions. We
suggest improvements that will make the algorithm more precise.
</summary>
    <author>
      <name>Saleena Nabeezath</name>
    </author>
    <author>
      <name>Vineeth Paleri</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1302.6325v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1302.6325v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1302.6328v1</id>
    <updated>2013-02-26T06:48:39Z</updated>
    <published>2013-02-26T06:48:39Z</published>
    <title>Variant-Frequency Semantics for Green Futures</title>
    <summary>  This paper describes an operational semantics for futures, with the primary
target on energy efficiency. The work in progress is built around an insight
that different threads can coordinate by running at different "paces," so that
the time for synchronization and the resulting wasteful energy consumption can
be reduced. We exploit several inherent characteristics of futures to determine
how the paces of involving threads can be coordinated. The semantics is
inspired by recent advances in computer architectures, where the frequencies of
CPU cores can be adjusted dynamically. The work is a first-step toward a
direction where variant frequencies are directly modeled as an essential
semantic feature in concurrent programming languages.
</summary>
    <author>
      <name>Yu David Liu</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">SUNY Binghamton</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.109.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.109.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2012, arXiv:1302.5798</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 109, 2013, pp. 1-6</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1302.6328v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1302.6328v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1302.6333v1</id>
    <updated>2013-02-26T06:49:18Z</updated>
    <published>2013-02-26T06:49:18Z</published>
    <title>Modularizing and Specifying Protocols among Threads</title>
    <summary>  We identify three problems with current techniques for implementing protocols
among threads, which complicate and impair the scalability of multicore
software development: implementing synchronization, implementing coordination,
and modularizing protocols. To mend these deficiencies, we argue for the use of
domain-specific languages (DSL) based on existing models of concurrency. To
demonstrate the feasibility of this proposal, we explain how to use the model
of concurrency Reo as a high-level protocol DSL, which offers appropriate
abstractions and a natural separation of protocols and computations. We
describe a Reo-to-Java compiler and illustrate its use through examples.
</summary>
    <author>
      <name>Sung-Shik T. Q. Jongmans</name>
    </author>
    <author>
      <name>Farhad Arbab</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.109.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.109.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2012, arXiv:1302.5798</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 109, 2013, pp. 34-45</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1302.6333v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1302.6333v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1303.0722v1</id>
    <updated>2013-03-04T15:11:38Z</updated>
    <published>2013-03-04T15:11:38Z</published>
    <title>EasyTime++: A case study of incremental domain-specific language
  development</title>
    <summary>  EasyTime is a domain-specific language (DSL) for measuring time during sports
competitions. A distinguishing feature of DSLs is that they are much more
amenable to change, and EasyTime is no exception in this regard. This paper
introduces two new EasyTime features: classifications of competitors into
categories, and the inclusion of competitions where the number of laps must be
dynamically determined. It shows how such extensions can be incrementally added
into the base-language reusing most of the language specifications. Two case
studies are presented showing the suitability of this approach.
</summary>
    <author>
      <name>Iztok Fister Jr.</name>
    </author>
    <author>
      <name>Tomaž Kosar</name>
    </author>
    <author>
      <name>Iztok Fister</name>
    </author>
    <author>
      <name>Marjan Mernik</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Information technology and control, 42(1), 77--85, 2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1303.0722v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1303.0722v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1303.0908v1</id>
    <updated>2013-03-05T02:13:28Z</updated>
    <published>2013-03-05T02:13:28Z</published>
    <title>KRAB Algorithm - A Revised Algorithm for Incremental Call Graph
  Generation</title>
    <summary>  This paper is aimed to present the importance and implementation of an
incremental call graph plugin. An algorithm is proposed for the call graph
implementation which has better overall performance than the algorithm that has
been proposed previously. In addition to this, the algorithm has been
empirically proved to have excellent performance on recursive codes. The
algorithm also readily checks for function skip and returns exceptions.
</summary>
    <author>
      <name>Rajasekhara Babu</name>
    </author>
    <author>
      <name>Krishnakumar V.</name>
    </author>
    <author>
      <name>George Abraham</name>
    </author>
    <author>
      <name>Kiransinh Borasia</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages, 7 figures, 1 Table, Conference</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">World Applied Programming, Vol (2), Issue (5), May 2012. 294-299,
  Special section for proceeding of International E-Conference on Information
  Technology and Applications (IECITA), ISSN: 2222-2510</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1303.0908v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1303.0908v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1303.1880v2</id>
    <updated>2014-09-16T06:59:03Z</updated>
    <published>2013-03-08T04:02:33Z</published>
    <title>A Simple Algorithm for Global Value Numbering</title>
    <summary>  Global Value Numbering(GVN) is a method for detecting redundant computations
in programs. Here, we introduce the problem of Global Value Numbering in its
original form, as conceived by Kildall(1973), and present an algorithm which is
a simpler variant of Kildall's. The algorithm uses the concept of value
expression - an abstraction of a set of expressions - enabling a representation
of the equivalence information which is compact and simple to manipulate.
</summary>
    <author>
      <name>Nabizath Saleena</name>
    </author>
    <author>
      <name>Vineeth Paleri</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1303.1880v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1303.1880v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.0660v1</id>
    <updated>2013-04-02T15:07:47Z</updated>
    <published>2013-04-02T15:07:47Z</published>
    <title>Quantified Data Automata on Skinny Trees: an Abstract Domain for Lists</title>
    <summary>  We propose a new approach to heap analysis through an abstract domain of
automata, called automatic shapes. The abstract domain uses a particular kind
of automata, called quantified data automata on skinny trees (QSDAs), that
allows to define universally quantified properties of singly-linked lists. To
ensure convergence of the abstract fixed-point computation, we introduce a
sub-class of QSDAs called elastic QSDAs, which also form an abstract domain. We
evaluate our approach on several list manipulating programs and we show that
the proposed domain is powerful enough to prove a large class of these programs
correct.
</summary>
    <author>
      <name>Pranav Garg</name>
    </author>
    <author>
      <name>P. Madhusudan</name>
    </author>
    <author>
      <name>Gennaro Parlato</name>
    </author>
    <link href="http://arxiv.org/abs/1304.0660v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.0660v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.FL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.0864v1</id>
    <updated>2013-04-03T08:01:42Z</updated>
    <published>2013-04-03T08:01:42Z</published>
    <title>Efficient Generation of Correctness Certificates for the Abstract Domain
  of Polyhedra</title>
    <summary>  Polyhedra form an established abstract domain for inferring runtime
properties of programs using abstract interpretation. Computations on them need
to be certified for the whole static analysis results to be trusted. In this
work, we look at how far we can get down the road of a posteriori verification
to lower the overhead of certification of the abstract domain of polyhedra. We
demonstrate methods for making the cost of inclusion certificate generation
negligible. From a performance point of view, our single-representation,
constraints-based implementation compares with state-of-the-art
implementations.
</summary>
    <author>
      <name>Alexis Fouilhé</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>Michaël Périn</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1304.0864v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.0864v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.MS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.1913v2</id>
    <updated>2013-05-07T16:47:24Z</updated>
    <published>2013-04-06T17:00:00Z</published>
    <title>Towards Efficient Abstractions for Concurrent Consensus</title>
    <summary>  Consensus is an often occurring problem in concurrent and distributed
programming. We present a programming language with simple semantics and
build-in support for consensus in the form of communicating transactions. We
motivate the need for such a construct with a characteristic example of
generalized consensus which can be naturally encoded in our language. We then
focus on the challenges in achieving an implementation that can efficiently run
such programs. We setup an architecture to evaluate different implementation
alternatives and use it to experimentally evaluate runtime heuristics. This is
the basis for a research project on realistic programming language support for
consensus.
</summary>
    <author>
      <name>Carlo Spaccasassi</name>
    </author>
    <author>
      <name>Vasileios Koutavas</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 5 figures, symposium: TFP 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1304.1913v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.1913v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.3140v1</id>
    <updated>2013-04-09T04:20:23Z</updated>
    <published>2013-04-09T04:20:23Z</published>
    <title>On PROGRESS Operation. How to Make Object-Oriented Programming System
  More Object-Oriented (DRAFT)</title>
    <summary>  A system, which implements persistent objects, has to provide different
opportunities to change the objects in arbitrary ways during their existence. A
traditional realization of OO paradigm in modern programming systems has
fundamental drawbacks which complicate an implementation of persistent
modifiable objects considerably. There is alternative realization that does not
have these drawbacks. In the article the PROGRESS operation is offered, which
modify existing object within an existing inheritance hierarchy.
</summary>
    <author>
      <name>Evgeniy Grigoriev</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">4 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1304.3140v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.3140v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; D.3.3; H.2.3; H.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.5485v1</id>
    <updated>2013-04-19T17:33:33Z</updated>
    <published>2013-04-19T17:33:33Z</published>
    <title>An Introduction to Quantum Programming in Quipper</title>
    <summary>  Quipper is a recently developed programming language for expressing quantum
computations. This paper gives a brief tutorial introduction to the language,
through a demonstration of how to make use of some of its key features. We
illustrate many of Quipper's language features by developing a few well known
examples of Quantum computation, including quantum teleportation, the quantum
Fourier transform, and a quantum circuit for addition.
</summary>
    <author>
      <name>Alexander S. Green</name>
    </author>
    <author>
      <name>Peter LeFanu Lumsdaine</name>
    </author>
    <author>
      <name>Neil J. Ross</name>
    </author>
    <author>
      <name>Peter Selinger</name>
    </author>
    <author>
      <name>Benoît Valiron</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-642-38986-3_10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-642-38986-3_10" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, RC2013</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Lecture Notes in Computer Science 7948:110-124, Springer, 2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1304.5485v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.5485v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.ET" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.5661v1</id>
    <updated>2013-04-20T18:58:36Z</updated>
    <published>2013-04-20T18:58:36Z</published>
    <title>On Integrating Deductive Synthesis and Verification Systems</title>
    <summary>  We describe techniques for synthesis and verification of recursive functional
programs over unbounded domains. Our techniques build on top of an algorithm
for satisfiability modulo recursive functions, a framework for deductive
synthesis, and complete synthesis procedures for algebraic data types. We
present new counterexample-guided algorithms for constructing verified
programs. We have implemented these algorithms in an integrated environment for
interactive verification and synthesis from relational specifications. Our
system was able to synthesize a number of useful recursive functions that
manipulate unbounded numbers and data structures.
</summary>
    <author>
      <name>Etienne Kneuss</name>
    </author>
    <author>
      <name>Viktor Kuncak</name>
    </author>
    <author>
      <name>Ivan Kuraj</name>
    </author>
    <author>
      <name>Philippe Suter</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages. 46 references</arxiv:comment>
    <link href="http://arxiv.org/abs/1304.5661v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.5661v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.6038v1</id>
    <updated>2013-04-22T18:07:36Z</updated>
    <published>2013-04-22T18:07:36Z</published>
    <title>Implementing hash-consed structures in Coq</title>
    <summary>  We report on three different approaches to use hash-consing in programs
certified with the Coq system, using binary decision diagrams (BDD) as running
example. The use cases include execution inside Coq, or execution of the
extracted OCaml code. There are different trade-offs between faithful use of
pristine extracted code, and code that is fine-tuned to make use of OCaml
programming constructs not available in Coq. We discuss the possible
consequences in terms of performances and guarantees.
</summary>
    <author>
      <name>Thomas Braibant</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>Jacques-Henri Jourdan</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1304.6038v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.6038v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.7600v1</id>
    <updated>2013-04-29T09:30:33Z</updated>
    <published>2013-04-29T09:30:33Z</published>
    <title>C++11 - określanie typów</title>
    <summary>  This paper presents a review of some new futures introduced to C++ language
by ISO/IEC 14882:2011 standard (known as C++11). It describes new language
elements which allow to easier expressed of types of variables: auto and
decltype keywords, new function declaration syntax, and tools which are
included in type_traits header.
  -----
  Niniejszy artyku{\l} jest jednym z serii artyku{\l}\'ow w kt\'orych zawarto
przegl{\ka}d nowych element\'ow j{\ke}zyka C++ wprowadzonych przez standard
ISO/IEC 14882:2011, znany pod nazw{\ka} C++11. W artykule przedstawiono nowe
mo\.zliwo\'sci zwi{\ka}zane ze wskazywaniem typ\'ow zmiennych. Opisano s{\l}owa
kluczowe auto i decltype, now{\ka} sk{\l}adnie deklarowania funkcji/metod oraz
narz{\ke}dzia zawarte w pliku nag{\l}\'owkowym &lt;type_traits&gt;.
</summary>
    <author>
      <name>Piotr Beling</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages, in Polish</arxiv:comment>
    <link href="http://arxiv.org/abs/1304.7600v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.7600v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1305.3103v1</id>
    <updated>2013-05-14T10:45:16Z</updated>
    <published>2013-05-14T10:45:16Z</published>
    <title>A fast method for implementation of the property lists in programming
  languages</title>
    <summary>  One of the major challenges in programming languages is to support different
data structures and their variations in both static and dynamic aspects. One of
the these data structures is the property list which applications use it as a
convenient way to store, organize, and access standard types of data. In this
paper, the standards methods for implementation of the Property Lists,
including the Static Array, Link List, Hash and Tree are reviewed. Then an
efficient method to implement the property list is presented. The experimental
results shows that our method is fast compared with the existing methods.
</summary>
    <author>
      <name>Hassan Rashidi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 Pages, 5 Figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1305.3103v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1305.3103v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1305.4584v1</id>
    <updated>2013-05-20T17:38:19Z</updated>
    <published>2013-05-20T17:38:19Z</published>
    <title>Functional Package Management with Guix</title>
    <summary>  We describe the design and implementation of GNU Guix, a purely functional
package manager designed to support a complete GNU/Linux distribution. Guix
supports transactional upgrades and roll-backs, unprivileged package
management, per-user profiles, and garbage collection. It builds upon the
low-level build and deployment layer of the Nix package manager. Guix uses
Scheme as its programming interface. In particular, we devise an embedded
domain-specific language (EDSL) to describe and compose packages. We
demonstrate how it allows us to benefit from the host general-purpose
programming language while not compromising on expressiveness. Second, we show
the use of Scheme to write build programs, leading to "two-tier" programming
system.
</summary>
    <author>
      <name>Ludovic Courtès</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">European Lisp Symposium (2013)</arxiv:comment>
    <link href="http://arxiv.org/abs/1305.4584v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1305.4584v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1305.6721v1</id>
    <updated>2013-05-29T08:38:32Z</updated>
    <published>2013-05-29T08:38:32Z</published>
    <title>Type-based Dependency Analysis for JavaScript</title>
    <summary>  Dependency analysis is a program analysis that determines potential data flow
between program points. While it is not a security analysis per se, it is a
viable basis for investigating data integrity, for ensuring confidentiality,
and for guaranteeing sanitization. A noninterference property can be stated and
proved for the dependency analysis. We have designed and implemented a
dependency analysis for JavaScript. We formalize this analysis as an
abstraction of a tainting semantics. We prove the correctness of the tainting
semantics, the soundness of the abstraction, a noninterference property, and
the termination of the analysis.
</summary>
    <author>
      <name>Matthias Keil</name>
    </author>
    <author>
      <name>Peter Thiemann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Technical Report</arxiv:comment>
    <link href="http://arxiv.org/abs/1305.6721v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1305.6721v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.1870v1</id>
    <updated>2013-06-08T02:22:42Z</updated>
    <published>2013-06-08T02:22:42Z</published>
    <title>The Cyan Language</title>
    <summary>  This is the manual of Cyan, a prototype-based object-oriented language. Cyan
supports static typing, single inheritance, mixin objects (similar to mixin
classes with mixin inheritance), generic prototypes, and Java-like interfaces.
The language has several innovations: a completely object-oriented exception
system, statically-typed closures, a kind of graphical metaobjects called
codegs, optional dynamic typing, user-defined literal objects (an innovative
way of creating objects), context objects (a generalization of closures), and
grammar methods and message sends (which makes it easy to define Domain
Specific Languages).
</summary>
    <author>
      <name>José de Oliveira Guimarães</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">248 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1306.1870v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.1870v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.1901v1</id>
    <updated>2013-06-08T10:10:05Z</updated>
    <published>2013-06-08T10:10:05Z</published>
    <title>Eventual Linear Ranking Functions</title>
    <summary>  Program termination is a hot research topic in program analysis. The last few
years have witnessed the development of termination analyzers for programming
languages such as C and Java with remarkable precision and performance. These
systems are largely based on techniques and tools coming from the field of
declarative constraint programming. In this paper, we first recall an algorithm
based on Farkas' Lemma for discovering linear ranking functions proving
termination of a certain class of loops. Then we propose an extension of this
method for showing the existence of eventual linear ranking functions, i.e.,
linear functions that become ranking functions after a finite unrolling of the
loop. We show correctness and completeness of this algorithm.
</summary>
    <author>
      <name>Roberto Bagnara</name>
    </author>
    <author>
      <name>Fred Mesnard</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/2505879.2505884</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/2505879.2505884" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1306.1901v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.1901v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; D.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.2267v1</id>
    <updated>2013-06-06T13:07:30Z</updated>
    <published>2013-06-06T13:07:30Z</published>
    <title>Let's Annotate to Let Our Code Run in Parallel</title>
    <summary>  This paper presents an approach that exploits Java annotations to provide
meta information needed to automatically transform plain Java programs into
parallel code that can be run on multicore workstation. Programmers just need
to decorate the methods that will eventually be executed in parallel with
standard Java annotations. Annotations are automatically processed at
launch-time and parallel byte code is derived. Once in execution the program
automatically retrieves the information about the executing platform and
evaluates the information specified inside the annotations to transform the
byte-code into a semantically equivalent multithreaded version, depending on
the target architecture features. The results returned by the annotated
methods, when invoked, are futures with a wait-by-necessity semantics.
</summary>
    <author>
      <name>Patrizio Dazzi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">4 pages, 1 figure</arxiv:comment>
    <link href="http://arxiv.org/abs/1306.2267v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.2267v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.2291v1</id>
    <updated>2013-06-10T19:12:57Z</updated>
    <published>2013-06-10T19:12:57Z</published>
    <title>Optimal multi-binding unification for sharing and linearity analysis</title>
    <summary>  In the analysis of logic programs, abstract domains for detecting sharing
properties are widely used. Recently the new domain $\Linp$ has been introduced
to generalize both sharing and linearity information. This domain is endowed
with an optimal abstract operator for single-binding unification. The authors
claim that the repeated application of this operator is also optimal for
multi-binding unification. This is the proof of such a claim.
</summary>
    <author>
      <name>Gianluca Amato</name>
    </author>
    <author>
      <name>Francesca Scozzari</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068413000070</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068413000070" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Theory and Practice of Logic Programming (TPLP)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, 14, pp 379-400, 2014</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1306.2291v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.2291v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.5061v1</id>
    <updated>2013-06-21T06:53:04Z</updated>
    <published>2013-06-21T06:53:04Z</published>
    <title>Towards Tree Automata-based Success Types</title>
    <summary>  Error detection facilities for dynamic languages are often based on unit
testing. Thus, the advantage of rapid prototyping and flexibility must be
weighed against cumbersome and time consuming test suite development. Lindahl
and Sagonas' success typings provide a means of static must-fail detection in
Erlang. Due to the constraint-based nature of the approach, some errors
involving nested tuples and recursion cannot be detected.
  We propose an approach that uses an extension of model checking for
pattern-matching recursion schemes with context-aware ranked tree automata to
provide improved success typings for a constructor-based first-order prototype
language.
</summary>
    <author>
      <name>Robert Jakob</name>
    </author>
    <author>
      <name>Peter Thiemann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Abstract presented at HOPA 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1306.5061v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.5061v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.6029v4</id>
    <updated>2014-06-22T20:43:48Z</updated>
    <published>2013-06-25T16:49:16Z</published>
    <title>AstraKahn: A Coordination Language for Streaming Networks</title>
    <summary>  This is a preliminary version of the language report. It contains key
definitions, specifications and some examples, but lacks completeness. The full
document will include Chapter 3 (Data and Instrumentation Layer) and will
comprise an appendix giving the complete syntax and some whole program
examples. The purpose of the present document is to fix the concepts and major
features of the language and to enable the production of the definition
document that is required for implementation.
</summary>
    <author>
      <name>Alex Shafarenko</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">34 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1306.6029v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.6029v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.6856v1</id>
    <updated>2013-06-28T14:38:13Z</updated>
    <published>2013-06-28T14:38:13Z</published>
    <title>Linear Dependent Types for Domain Specific Program Analysis (Extended
  Abstract)</title>
    <summary>  In this tutorial I will present how a combination of linear and dependent
type can be useful to describe different properties about higher order
programs. Linear types have been proved particularly useful to express
properties of functions; dependent types are useful to describe the behavior of
the program in terms of its control flow. This two ideas fits together well
when one is interested in analyze properties of functions depending on the
control flow of the program. I will present these ideas with example taken by
complexity analysis and sensitivity analysis. I will conclude the tutorial by
arguing about the generality of this approach.
</summary>
    <author>
      <name>Marco Gaboardi</name>
    </author>
    <link href="http://arxiv.org/abs/1306.6856v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.6856v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4474v1</id>
    <updated>2013-07-17T01:42:29Z</updated>
    <published>2013-07-17T01:42:29Z</published>
    <title>Probabilistic data flow analysis: a linear equational approach</title>
    <summary>  Speculative optimisation relies on the estimation of the probabilities that
certain properties of the control flow are fulfilled. Concrete or estimated
branch probabilities can be used for searching and constructing advantageous
speculative and bookkeeping transformations.
  We present a probabilistic extension of the classical equational approach to
data-flow analysis that can be used to this purpose. More precisely, we show
how the probabilistic information introduced in a control flow graph by branch
prediction can be used to extract a system of linear equations from a program
and present a method for calculating correct (numerical) solutions.
</summary>
    <author>
      <name>Alessandra Di Pierro</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Verona</arxiv:affiliation>
    </author>
    <author>
      <name>Herbert Wiklicky</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Imperial College London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.119.14</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.119.14" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings GandALF 2013, arXiv:1307.4162</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 119, 2013, pp. 150-165</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1307.4474v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4474v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4635v1</id>
    <updated>2013-07-17T13:58:38Z</updated>
    <published>2013-07-17T13:58:38Z</published>
    <title>Integrating Datalog and Constraint Solving</title>
    <summary>  LP is a common formalism for the field of databases and CSP, both at the
theoretical level and the implementation level in the form of Datalog and CLP.
In the past, close correspondences have been made between both fields at the
theoretical level. Yet correspondence at the implementation level has been much
less explored. In this article we work towards relating them at the
implementation level. Concretely, we show how to derive the efficient Leapfrog
Triejoin execution algorithm of Datalog from a generic CP execution scheme.
</summary>
    <author>
      <name>Benoit Desouter</name>
    </author>
    <author>
      <name>Tom Schrijvers</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the 13th International Colloquium on Implementation of
  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August
  25, 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.4635v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4635v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4641v1</id>
    <updated>2013-07-17T14:13:50Z</updated>
    <published>2013-07-17T14:13:50Z</published>
    <title>Experimenting with X10 for Parallel Constraint-Based Local Search</title>
    <summary>  In this study, we have investigated the adequacy of the PGAS parallel
language X10 to implement a Constraint-Based Local Search solver. We decided to
code in this language to benefit from the ease of use and architectural
independence from parallel resources which it offers. We present the
implementation strategy, in search of different sources of parallelism in the
context of an implementation of the Adaptive Search algorithm. We extensively
discuss the algorithm and its implementation. The performance evaluation on a
representative set of benchmarks shows close to linear speed-ups, in all the
problems treated.
</summary>
    <author>
      <name>Danny Munera</name>
    </author>
    <author>
      <name>Daniel Diaz</name>
    </author>
    <author>
      <name>Salvador Abreu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the 13th International Colloquium on Implementation of
  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August
  25, 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.4641v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4641v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4642v1</id>
    <updated>2013-07-17T14:14:08Z</updated>
    <published>2013-07-17T14:14:08Z</published>
    <title>A Prolog Specification of Giant Number Arithmetic</title>
    <summary>  The tree based representation described in this paper, hereditarily binary
numbers, applies recursively a run-length compression mechanism that enables
computations limited by the structural complexity of their operands rather than
by their bitsizes. While within constant factors from their traditional
counterparts for their worst case behavior, our arithmetic operations open the
doors for interesting numerical computations, impossible with traditional
number representations. We provide a complete specification of our algorithms
in the form of a purely declarative Prolog program.
</summary>
    <author>
      <name>Paul Tarau</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the 13th International Colloquium on Implementation of
  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August
  25, 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.4642v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4642v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4644v1</id>
    <updated>2013-07-17T14:20:15Z</updated>
    <published>2013-07-17T14:20:15Z</published>
    <title>Interning Ground Terms in XSB</title>
    <summary>  This paper presents an implementation of interning of ground terms in the XSB
Tabled Prolog system. This is related to the idea of hash-consing. I describe
the concept of interning atoms and discuss the issues around interning ground
structured terms, motivating why tabling Prolog systems may change the
cost-benefit tradeoffs from those of traditional Prolog systems. I describe the
details of the implementation of interning ground terms in the XSB Tabled
Prolog System and show some of its performance properties. This implementation
achieves the effects of that of Zhou and Have but is tuned for XSB's
representations and is arguably simpler.
</summary>
    <author>
      <name>David S. Warren</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the 13th International Colloquium on Implementation of
  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August
  25, 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.4644v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4644v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4827v1</id>
    <updated>2013-07-18T04:06:49Z</updated>
    <published>2013-07-18T04:06:49Z</published>
    <title>Characterizing traits of coordination</title>
    <summary>  How can one recognize coordination languages and technologies? As this report
shows, the common approach that contrasts coordination with computation is
intellectually unsound: depending on the selected understanding of the word
"computation", it either captures too many or too few programming languages.
Instead, we argue for objective criteria that can be used to evaluate how well
programming technologies offer coordination services. Of the various criteria
commonly used in this community, we are able to isolate three that are strongly
characterizing: black-box componentization, which we had identified previously,
but also interface extensibility and customizability of run-time optimization
goals. These criteria are well matched by Intel's Concurrent Collections and
AstraKahn, and also by OpenCL, POSIX and VMWare ESX.
</summary>
    <author>
      <name>Raphael 'kena' Poss</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages, 3 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.4827v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4827v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.5277v1</id>
    <updated>2013-07-19T16:38:25Z</updated>
    <published>2013-07-19T16:38:25Z</published>
    <title>Formalisation of the lambda aleph Runtime</title>
    <summary>  In previous work we describe a novel approach to dependent typing based on a
multivalued term language. In this technical report we formalise the runtime, a
kind of operational semantics, for that language. We describe a fairly
comprehensive core language, and then give a small-step operational semantics
based on an abstract machine. Errors are explicit in the semantics. We also
prove several simple properties: that every non-terminated machine state steps
to something and that reduction is deterministic once input is fixed.
</summary>
    <author>
      <name>Neal Glew</name>
    </author>
    <author>
      <name>Tim Sweeney</name>
    </author>
    <author>
      <name>Leaf Petersen</name>
    </author>
    <link href="http://arxiv.org/abs/1307.5277v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.5277v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.7849v1</id>
    <updated>2013-07-30T07:23:59Z</updated>
    <published>2013-07-30T07:23:59Z</published>
    <title>Proceedings Sixth Workshop on Intersection Types and Related Systems</title>
    <summary>  This volume contains the proceedings of the Sixth Workshop on Intersection
Types and Related Systems (ITRS 2012). The workshop was held in Dubrovnik
(Croatia) on June 29th, 2012, affiliated to Twenty-Seventh Annual ACM/IEEE
Symposium on Logic in Computer Science (LICS 2012). The ITRS workshop aims to
bring together researchers working on both the theory and practical
applications of systems based on intersection types and related approaches
(e.g., union types, refinement types, behavioural types, recursive types, and
so on).
</summary>
    <author>
      <name>Stéphane Graham-Lengrand</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CNRS - École Polytechnique</arxiv:affiliation>
    </author>
    <author>
      <name>Luca Paolini</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Università di Torino</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.121</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.121" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 121, 2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1307.7849v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.7849v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1, D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.8207v1</id>
    <updated>2013-07-31T03:24:46Z</updated>
    <published>2013-07-31T03:24:46Z</published>
    <title>Reconciling positional and nominal binding</title>
    <summary>  We define an extension of the simply-typed lambda calculus where two
different binding mechanisms, by position and by name, nicely coexist. In the
former, as in standard lambda calculus, the matching between parameter and
argument is done on a positional basis, hence alpha-equivalence holds, whereas
in the latter it is done on a nominal basis. The two mechanisms also
respectively correspond to static binding, where the existence and type
compatibility of the argument are checked at compile-time, and dynamic binding,
where they are checked at run-time.
</summary>
    <author>
      <name>Davide Ancona</name>
    </author>
    <author>
      <name>Paola Giannini</name>
    </author>
    <author>
      <name>Elena Zucca</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.121.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.121.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ITRS 2012, arXiv:1307.7849</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 121, 2013, pp. 81-93</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1307.8207v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.8207v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1308.3938v1</id>
    <updated>2013-08-19T07:15:23Z</updated>
    <published>2013-08-19T07:15:23Z</published>
    <title>Efficiently Retrieving Function Dependencies in the Linux Kernel Using
  XSB</title>
    <summary>  In this paper we investigate XSB-Prolog as a static analysis engine for data
represented by medium-sized graphs. We use XSB-Prolog to automatically identify
function dependencies in the Linux Kernel---queries that are difficult to
implement efficiently in a commodity database and that developers often have to
identify manually. This project illustrates that Prolog systems are ideal for
building tools for use in other disciplines that require sophisticated
inferences, because Prolog is both declarative and can efficiently implement
complex problem specifications through tabling and indexing.
</summary>
    <author>
      <name>Spyros Hadjichristodoulou</name>
    </author>
    <author>
      <name>Donald E. Porter</name>
    </author>
    <author>
      <name>David S. Warren</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Part of WLPE 2013 proceedings (arXiv:1308.2055)</arxiv:comment>
    <link href="http://arxiv.org/abs/1308.3938v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1308.3938v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1308.4452v3</id>
    <updated>2015-08-24T04:59:23Z</updated>
    <published>2013-08-21T00:13:32Z</published>
    <title>A New Statement for Selection and Exception Handling in Imperative
  Languages</title>
    <summary>  Diverse selection statements -- if-then-else, switch and try-catch -- are
commonly used in modern programming languages. To make things simple, we
propose a unifying statement for selection. This statement is of the form
schoose(G_1,...,G_n) where each $G_i$ is a statement. It has a a simple
semantics: sequentially choose the first successful statement $G_i$ and then
proceeds with executing $G_i$. Examples will be provided for this statement.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 pages. We replace choose with schoose which is more accurate
  alternative of if-then-else and try-catch</arxiv:comment>
    <link href="http://arxiv.org/abs/1308.4452v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1308.4452v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1308.4815v2</id>
    <updated>2013-08-23T09:02:41Z</updated>
    <published>2013-08-22T10:14:43Z</published>
    <title>Machine Code Optimization - Improving Executable Object Code</title>
    <summary>  This dissertation explores classes of compiler optimization techniques that
are applicable late in the compilation process, after all executable code for a
program has been linked. I concentrate on techniques which, for various
reasons, cannot be applied earlier in the compilation process. In addition to a
theoretical treatment of this class of optimization techniques, this
dissertation reports on an implementation of these techniques in a production
environment. I describe the details of the implementation which allows these
techniques to be re-targeted easily and report on improvements gained when
optimizing production software.
</summary>
    <author>
      <name>Clinton F. Goss</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Technical Report #246, Courant Institute of Mathematical Sciences,
  New York University. Initially published June 1986; Revised August 22, 2013.
  41 pages, 9 figures, 7 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/1308.4815v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1308.4815v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N20" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1308.6096v1</id>
    <updated>2013-08-28T08:59:41Z</updated>
    <published>2013-08-28T08:59:41Z</published>
    <title>Micro Spitbol</title>
    <summary>  A compact version of MACRO SPITBOL, a compiler/ interpreter for a variant of
SNOBOL4, has been developed for use on microcomputer systems. The techniques
for producing an implementation are largely automatic in order to preserve the
integrity and portability of the SPITBOL system. These techniques are discussed
along with a description of an initial implementation on a 65K byte
minicomputer. An interesting theoretical problem which arises when using
procedures which compact the interpretive object code is also analyzed.
</summary>
    <author>
      <name>Robert B. K. Dewar</name>
    </author>
    <author>
      <name>Martin Charles Golumbic</name>
    </author>
    <author>
      <name>Clinton F. Goss</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Initially published October 1979; Revised August 28, 2013. 8 pages, 3
  figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1308.6096v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1308.6096v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N20" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.1261v1</id>
    <updated>2013-09-05T08:04:31Z</updated>
    <published>2013-09-05T08:04:31Z</published>
    <title>Proving termination of evaluation for System F with control operators</title>
    <summary>  We present new proofs of termination of evaluation in reduction semantics
(i.e., a small-step operational semantics with explicit representation of
evaluation contexts) for System F with control operators. We introduce a
modified version of Girard's proof method based on reducibility candidates,
where the reducibility predicates are defined on values and on evaluation
contexts as prescribed by the reduction semantics format. We address both
abortive control operators (callcc) and delimited-control operators (shift and
reset) for which we introduce novel polymorphic type systems, and we consider
both the call-by-value and call-by-name evaluation strategies.
</summary>
    <author>
      <name>Małgorzata Biernacka</name>
    </author>
    <author>
      <name>Dariusz Biernacki</name>
    </author>
    <author>
      <name>Sergueï Lenglet</name>
    </author>
    <author>
      <name>Marek Materzok</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.127.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.127.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings COS 2013, arXiv:1309.0924</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 127, 2013, pp. 15-29</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.1261v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.1261v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1, F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.1307v1</id>
    <updated>2013-09-05T10:48:52Z</updated>
    <published>2013-09-05T10:48:52Z</published>
    <title>C++11 -- idea r-wartości i przenoszenia</title>
    <summary>  This paper presents a review of some new futures introduced to C++ language
by ISO/IEC 14882:2011 standard (known as C++11). It describes the ideas of
r-values and move constructors.
  ----
  Niniejszy artyku{\l} jest jednym z serii artyku{\l}\'ow w kt\'orych zawarto
przegl{\ka}d nowych element\'ow j{\ke}zyka C++ wprowadzonych przez standard
ISO/IEC 14882:2011, znany pod nazw{\ka} C++11. W artykule przedstawiono nowe
mo\.zliwo\'sci zwi{\ka}zane z przekazywaniem parametr\'ow i pisaniem
konstruktor\'ow. Zawarto w nim dok{\l}adne om\'owienie idei r-warto\'sci i
przenoszenia obiekt\'ow.
</summary>
    <author>
      <name>Piotr Beling</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages, in Polish</arxiv:comment>
    <link href="http://arxiv.org/abs/1309.1307v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.1307v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.3919v1</id>
    <updated>2013-09-16T11:52:40Z</updated>
    <published>2013-09-16T11:52:40Z</published>
    <title>Environmental Bisimulations for Delimited-Control Operators</title>
    <summary>  We present a theory of environmental bisimilarity for the delimited-control
operators {\it shift} and {\it reset}. We consider two different notions of
contextual equivalence: one that does not require the presence of a top-level
control delimiter when executing tested terms, and another one, fully
compatible with the original CPS semantics of shift and reset, that does. For
each of them, we develop sound and complete environmental bisimilarities, and
we discuss up-to techniques.
</summary>
    <author>
      <name>Dariusz Biernacki</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Nancy - Grand Est / LORIA</arxiv:affiliation>
    </author>
    <author>
      <name>Sergueï Lenglet</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Nancy - Grand Est / LORIA</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Long version of the corresponding APLAS13 paper</arxiv:comment>
    <link href="http://arxiv.org/abs/1309.3919v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.3919v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.FL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.4557v1</id>
    <updated>2013-09-18T07:26:07Z</updated>
    <published>2013-09-18T07:26:07Z</published>
    <title>Semantics, Abstract Interpretation, and Reasoning about Programs: Essays
  Dedicated to David A. Schmidt on the Occasion of his Sixtieth Birthday</title>
    <summary>  This Liber Amicorum is a collection of essays ranging from personal memories
to technical contributions. It is a tribute to Dave Schmidt and his career, and
was composed at the occasion of his sixtieth birthday.
</summary>
    <author>
      <name>Anindya Banerjee</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IMDEA Software Institute</arxiv:affiliation>
    </author>
    <author>
      <name>Olivier Danvy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Aarhus University</arxiv:affiliation>
    </author>
    <author>
      <name>Kyung-Goo Doh</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Hanyang University</arxiv:affiliation>
    </author>
    <author>
      <name>John Hatcliff</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Kansas State University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.4557v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.4557v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5130v1</id>
    <updated>2013-09-20T01:43:16Z</updated>
    <published>2013-09-20T01:43:16Z</published>
    <title>A Comparison of Well-Quasi Orders on Trees</title>
    <summary>  Well-quasi orders such as homeomorphic embedding are commonly used to ensure
termination of program analysis and program transformation, in particular
supercompilation.
  We compare eight well-quasi orders on how discriminative they are and their
computational complexity. The studied well-quasi orders comprise two very
simple examples, two examples from literature on supercompilation and four new
proposed by the author.
  We also discuss combining several well-quasi orders to get well-quasi orders
of higher discriminative power. This adds 19 more well-quasi orders to the
list.
</summary>
    <author>
      <name>Torben Æ. Mogensen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">DIKU, University of Copenhagen, Denmark</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Festschrift for Dave Schmidt, arXiv:1309.4557</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013, pp. 30-40</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.5130v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5130v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="E.1; F.2.2; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5132v1</id>
    <updated>2013-09-20T01:43:32Z</updated>
    <published>2013-09-20T01:43:32Z</published>
    <title>Notions of Monad Strength</title>
    <summary>  Over the past two decades the notion of a strong monad has found wide
applicability in computing. Arising out of a need to interpret products in
computational and semantic settings, different approaches to this concept have
arisen. In this paper we introduce and investigate the connections between
these approaches and also relate the results to monad composition. We also
introduce new methods for checking and using the required laws associated with
such compositions, as well as provide examples illustrating problems and issues
that arise.
</summary>
    <author>
      <name>Philip Mulry</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Colgate University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Festschrift for Dave Schmidt, arXiv:1309.4557</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013, pp. 67-83</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.5132v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5132v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5137v1</id>
    <updated>2013-09-20T01:44:04Z</updated>
    <published>2013-09-20T01:44:04Z</published>
    <title>Online partial evaluation of sheet-defined functions</title>
    <summary>  We present a spreadsheet implementation, extended with sheet-defined
functions, that allows users to define functions using only standard
spreadsheet concepts such as cells, formulas and references, requiring no new
syntax. This implements an idea proposed by Peyton-Jones and others.
  As the main contribution of this paper, we then show how to add an online
partial evaluator for such sheet-defined functions. The result is a
higher-order functional language that is dynamically typed, in keeping with
spreadsheet traditions, and an interactive platform for function definition and
function specialization.
  We describe an implementation of these ideas, present some performance data
from microbenchmarks, and outline desirable improvements and extensions.
</summary>
    <author>
      <name>Peter Sestoft</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IT University of Copenhagen</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129.10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129.10" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Festschrift for Dave Schmidt, arXiv:1309.4557</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013, pp. 136-160</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.5137v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5137v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5144v1</id>
    <updated>2013-09-20T01:45:17Z</updated>
    <published>2013-09-20T01:45:17Z</published>
    <title>A Simple Semantics and Static Analysis for Stack Inspection</title>
    <summary>  The Java virtual machine and the .NET common language runtime feature an
access control mechanism specified operationally in terms of run-time stack
inspection. We give a denotational semantics in "eager" form, and show that it
is equivalent to the "lazy" semantics using stack inspection. We give a static
analysis of safety, i.e., the absence of security errors, that is simpler than
previous proposals. We identify several program transformations that can be
used to remove run-time checks. We give complete, detailed proofs for safety of
the analysis and for the transformations, exploiting compositionality of the
eager semantics.
</summary>
    <author>
      <name>Anindya Banerjee</name>
    </author>
    <author>
      <name>David A. Naumann</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129.17</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129.17" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Festschrift for Dave Schmidt, arXiv:1309.4557</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013, pp. 284-308</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.5144v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5144v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5147v1</id>
    <updated>2013-09-20T01:45:44Z</updated>
    <published>2013-09-20T01:45:44Z</published>
    <title>A short note on Simulation and Abstraction</title>
    <summary>  This short note is written in celebration of David Schmidt's sixtieth
birthday. He has now been active in the program analysis research community for
over thirty years and we have enjoyed many interactions with him. His work on
characterising simulations between Kripke structures using Galois connections
was particularly influential in our own work on using probabilistic abstract
interpretation to study Larsen and Skou's notion of probabilistic bisimulation.
We briefly review this work and discuss some recent applications of these ideas
in a variety of different application areas.
</summary>
    <author>
      <name>Chris Hankin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Imperial College London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129.20</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129.20" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Festschrift for Dave Schmidt, arXiv:1309.4557</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013, pp. 337-340</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.5147v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5147v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5149v1</id>
    <updated>2013-09-20T01:46:06Z</updated>
    <published>2013-09-20T01:46:06Z</published>
    <title>Pretty-big-step-semantics-based Certified Abstract Interpretation
  (Preliminary version)</title>
    <summary>  We present a technique for deriving semantic program analyses from a natural
semantics specification of the programming language. The technique is based on
a particular kind of semantics called pretty-big-step semantics. We present a
pretty-big-step semantics of a language with simple objects called O'While and
specify a series of instrumentations of the semantics that explicitates the
flows of values in a program. This leads to a semantics-based dependency
analysis, at the core, e.g., of tainting analysis in software security. The
formalization has been realized with the Coq proof assistant.
</summary>
    <author>
      <name>Martin Bodin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">ENS Lyon and Inria</arxiv:affiliation>
    </author>
    <author>
      <name>Thomas Jensen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Inria</arxiv:affiliation>
    </author>
    <author>
      <name>Alan Schmitt</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Inria</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129.23</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129.23" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Festschrift for Dave Schmidt, arXiv:1309.4557</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013, pp. 360-383</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.5149v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5149v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1310.3473v1</id>
    <updated>2013-10-13T12:28:54Z</updated>
    <published>2013-10-13T12:28:54Z</published>
    <title>A Domain-Specific Language for Discrete Mathematics</title>
    <summary>  This paper discusses a Domain Specific Language (DSL) that has been developed
to enable implementation of concepts of discrete mathematics. A library of data
types and functions provides functionality which is frequently required by
users. Covering the areas of Mathematical Logic, Set Theory, Functions, Graph
Theory, Number Theory, Linear Algebra and Combinatorics, the language's syntax
is close to the actual notation used in the specific fields.
</summary>
    <author>
      <name>Rohit Jha</name>
    </author>
    <author>
      <name>Alfy Samuel</name>
    </author>
    <author>
      <name>Ashmee Pawar</name>
    </author>
    <author>
      <name>M. Kiruthika</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.5120/12036-7257</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.5120/12036-7257" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">International Journal of Computer Applications 70(15):6-19, May
  2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1310.3473v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1310.3473v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DM" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1310.7449v1</id>
    <updated>2013-10-28T15:08:28Z</updated>
    <published>2013-10-28T15:08:28Z</published>
    <title>Deadlock detection in linear recursive programs</title>
    <summary>  Deadlock detection in recursive programs that admit dynamic resource creation
is extremely complex and solutions either give imprecise answers or do not
scale.
  We define an algorithm for detecting deadlocks of "linear recursive programs"
of a basic model. The theory that underpins the algorithm is a generalization
of the theory of permutations of names to so-called "mutations", which
transform tuples by introducing duplicates and fresh names.
  Our algorithm realizes the back-end of deadlock analyzers for object-oriented
programming languages, once the association programs/basic-model-programs has
been defined as front-end.
</summary>
    <author>
      <name>Elena Giachino</name>
    </author>
    <author>
      <name>Cosimo Laneve</name>
    </author>
    <link href="http://arxiv.org/abs/1310.7449v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1310.7449v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68Q85" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; F.3.2; F.1.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1311.0864v1</id>
    <updated>2013-11-04T15:32:51Z</updated>
    <published>2013-11-04T15:32:51Z</published>
    <title>Two automated techniques for analyzing and debugging Mpi-based programs</title>
    <summary>  Message Passing Interface (MPI) is the most commonly used paradigm in writing
parallel programs since it can be employed not only within a single processing
node but also across several connected ones. Data flow analysis concepts,
techniques and tools are needed to understand and analyze MPI-based programs to
detect bugs arise in these programs. In this paper we propose two automated
techniques to analyze and debug MPI-based programs source codes.
</summary>
    <author>
      <name>Alaa Ismail Elnashar</name>
    </author>
    <author>
      <name>Sultan Aljahdali</name>
    </author>
    <author>
      <name>Mosaid Al Sadhan</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: substantial text overlap with arXiv:1311.0731</arxiv:comment>
    <link href="http://arxiv.org/abs/1311.0864v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1311.0864v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1311.5810v1</id>
    <updated>2013-11-22T16:50:48Z</updated>
    <published>2013-11-22T16:50:48Z</published>
    <title>Deciding $k$CFA is complete for EXPTIME</title>
    <summary>  We give an exact characterization of the computational complexity of the
$k$CFA hierarchy. For any $k &gt; 0$, we prove that the control flow decision
problem is complete for deterministic exponential time. This theorem validates
empirical observations that such control flow analysis is intractable. It also
provides more general insight into the complexity of abstract interpretation.
</summary>
    <author>
      <name>David Van Horn</name>
    </author>
    <author>
      <name>Harry G. Mairson</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in The 13th ACM SIGPLAN International Conference on
  Functional Programming (ICFP'08), Victoria, British Columbia, Canada,
  September 2008</arxiv:comment>
    <link href="http://arxiv.org/abs/1311.5810v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1311.5810v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1311.7242v1</id>
    <updated>2013-11-28T09:15:55Z</updated>
    <published>2013-11-28T09:15:55Z</published>
    <title>Programming with Permissions in Mezzo</title>
    <summary>  We present Mezzo, a typed programming language of ML lineage. Mezzo is
equipped with a novel static discipline of duplicable and affine permissions,
which controls aliasing and ownership. This rules out certain mistakes,
including representation exposure and data races, and enables new idioms, such
as gradual initialization, memory re-use, and (type)state changes. Although the
core static discipline disallows sharing a mutable data structure, Mezzo offers
several ways of working around this restriction, including a novel dynamic
ownership control mechanism which we dub "adoption and abandon".
</summary>
    <author>
      <name>Jonathan Protzenko</name>
    </author>
    <author>
      <name>François Pottier</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/2500365.2500598</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/2500365.2500598" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">ICFP 2013, Proceedings of the 18th ACM SIGPLAN international
  conference on Functional programming</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1311.7242v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1311.7242v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.0078v1</id>
    <updated>2013-11-30T08:48:02Z</updated>
    <published>2013-11-30T08:48:02Z</published>
    <title>Hop and HipHop : Multitier Web Orchestration</title>
    <summary>  Rich applications merge classical computing, client-server concurrency,
web-based interfaces, and the complex time- and event-based reactive
programming found in embedded systems. To handle them, we extend the Hop web
programming platform by HipHop, a domain-specific language dedicated to
event-based process orchestration. Borrowing the synchronous reactive model of
Esterel, HipHop is based on synchronous concurrency and preemption primitives
that are known to be key components for the modular design of complex reactive
behaviors. HipHop departs from Esterel by its ability to handle the dynamicity
of Web applications, thanks to the reflexivity of Hop. Using a music player
example, we show how to modularly build a non-trivial Hop application using
HipHop orchestration code.
</summary>
    <author>
      <name>Gérard Berry</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Sophia Antipolis</arxiv:affiliation>
    </author>
    <author>
      <name>Manuel Serrano</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">International Conference on Distributed Computing and Internet
  Technology (2014)</arxiv:comment>
    <link href="http://arxiv.org/abs/1312.0078v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.0078v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.0138v1</id>
    <updated>2013-11-30T18:43:31Z</updated>
    <published>2013-11-30T18:43:31Z</published>
    <title>The bitwise operations related to a fast sorting algorithm</title>
    <summary>  In the work we discuss the benefit of using bitwise operations in
programming. Some interesting examples in this respect have been shown. What is
described in detail is an algorithm for sorting an integer array with the
substantial use of the bitwise operations. Besides its correctness we strictly
prove that the described algorithm works in time O(n). In the work during the
realisation of each of the examined algorithms we use the apparatus of the
object-oriented programming with the syntax and the semantics of the
programming language C++.
</summary>
    <author>
      <name>Krasimir Yordzhev</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">(IJACSA) International Journal of Advanced Computer Science and
  Applications, Vol. 4, No. 9, 2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1312.0138v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.0138v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.0342v1</id>
    <updated>2013-12-02T06:59:06Z</updated>
    <published>2013-12-02T06:59:06Z</published>
    <title>The Petri-Nets to Statecharts Transformation Case</title>
    <summary>  This paper describes a case study for the sixth Transformation Tool Contest.
The case is based on a mapping from Petri-Nets to statecharts (i.e., from flat
process models to hierarchical ones). The case description separates a simple
mapping phase from a phase that involves the step by step destruction Petri-Net
elements and the corresponding construction of a hierarchy of statechart
elements. Although the focus of this case study is on the comparison of the
runtime performance of solutions, we also include correctness tests as well as
bonus criteria for evaluating transformation language and tool features.
</summary>
    <author>
      <name>Pieter Van Gorp</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Eindhoven University of Technology</arxiv:affiliation>
    </author>
    <author>
      <name>Louis M. Rose</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of York</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.135.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.135.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TTC 2013, arXiv:1311.7536</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 135, 2013, pp. 16-31</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1312.0342v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.0342v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.2.2;F.4.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.1529v1</id>
    <updated>2013-12-05T12:53:56Z</updated>
    <published>2013-12-05T12:53:56Z</published>
    <title>Instruction sequence expressions for the Karatsuba multiplication
  algorithm</title>
    <summary>  The Karatsuba multiplication algorithm is an algorithm for computing the
product of two natural numbers represented in the binary number system. This
means that the algorithm actually computes a function on bit strings. The
restriction of this function to bit strings of any given length can be computed
according to the Karatsuba multiplication algorithm by a finite instruction
sequence that contains only instructions to set and get the content of Boolean
registers, forward jump instructions, and a termination instruction. We
describe the instruction sequences concerned for the restrictions to bit
strings of the different lengths by uniform terms from an algebraic theory.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages. arXiv admin note: substantial text overlap with
  arXiv:1308.0219</arxiv:comment>
    <link href="http://arxiv.org/abs/1312.1529v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.1529v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; F.2.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.2334v3</id>
    <updated>2014-09-11T19:51:32Z</updated>
    <published>2013-12-09T08:13:19Z</published>
    <title>Inferring Algebraic Effects</title>
    <summary>  We present a complete polymorphic effect inference algorithm for an ML-style
language with handlers of not only exceptions, but of any other algebraic
effect such as input &amp; output, mutable references and many others. Our main aim
is to offer the programmer a useful insight into the effectful behaviour of
programs. Handlers help here by cutting down possible effects and the resulting
lengthy output that often plagues precise effect systems. Additionally, we
present a set of methods that further simplify the displayed types, some even
by deliberately hiding inferred information from the programmer.
</summary>
    <author>
      <name>Matija Pretnar</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Ljubljana</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-10(3:21)2014</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-10(3:21)2014" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 10, Issue 3 (September
  12, 2014) lmcs:1004</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1312.2334v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.2334v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.2698v1</id>
    <updated>2013-12-10T08:03:18Z</updated>
    <published>2013-12-10T08:03:18Z</published>
    <title>From Lock Freedom to Progress Using Session Types</title>
    <summary>  Inspired by Kobayashi's type system for lock freedom, we define a behavioral
type system for ensuring progress in a language of binary sessions. The key
idea is to annotate actions in session types with priorities representing the
urgency with which such actions must be performed and to verify that processes
perform such actions with the required priority. Compared to related systems
for session-based languages, the presented type system is relatively simpler
and establishes progress for a wider range of processes.
</summary>
    <author>
      <name>Luca Padovani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Torino</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.137.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.137.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2013, arXiv:1312.2218</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 137, 2013, pp. 3-19</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1312.2698v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.2698v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.3; D.3.3; F.1.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.2702v1</id>
    <updated>2013-12-10T08:03:57Z</updated>
    <published>2013-12-10T08:03:57Z</published>
    <title>Coinductive Big-Step Semantics for Concurrency</title>
    <summary>  In a paper presented at SOS 2010, we developed a framework for big-step
semantics for interactive input-output in combination with divergence, based on
coinductive and mixed inductive-coinductive notions of resumptions, evaluation
and termination-sensitive weak bisimilarity. In contrast to standard
inductively defined big-step semantics, this framework handles divergence
properly; in particular, runs that produce some observable effects and then
diverge, are not "lost". Here we scale this approach for shared-variable
concurrency on a simple example language. We develop the metatheory of our
semantics in a constructive logic.
</summary>
    <author>
      <name>Tarmo Uustalu</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.137.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.137.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2013, arXiv:1312.2218</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 137, 2013, pp. 63-78</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1312.2702v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.2702v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; F.1.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.2704v1</id>
    <updated>2013-12-10T08:04:18Z</updated>
    <published>2013-12-10T08:04:18Z</published>
    <title>Session Types Go Dynamic or How to Verify Your Python Conversations</title>
    <summary>  This paper presents the first implementation of session types in a
dynamically-typed language - Python. Communication safety of the whole system
is guaranteed at runtime by monitors that check the execution traces comply
with an associated protocol. Protocols are written in Scribble, a choreography
description language based on multiparty session types, with addition of logic
formulas for more precise behaviour properties. The presented framework
overcomes the limitations of previous works on the session types where all
endpoints should be statically typed so that they do not permit
interoperability with untyped participants. The advantages, expressiveness and
performance of dynamic protocol checking are demonstrated through use case and
benchmarks.
</summary>
    <author>
      <name>Rumyana Neykova</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Imperial College</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.137.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.137.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2013, arXiv:1312.2218</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 137, 2013, pp. 95-102</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1312.2704v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.2704v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1401.5391v1</id>
    <updated>2014-01-21T17:23:45Z</updated>
    <published>2014-01-21T17:23:45Z</published>
    <title>The semantic marriage of monads and effects</title>
    <summary>  Wadler and Thiemann unified type-and-effect systems with monadic semantics
via a syntactic correspondence and soundness results with respect to an
operational semantics. They conjecture that a general, "coherent" denotational
semantics can be given to unify effect systems with a monadic-style semantics.
We provide such a semantics based on the novel structure of an indexed monad,
which we introduce. We redefine the semantics of Moggi's computational
lambda-calculus in terms of (strong) indexed monads which gives a one-to-one
correspondence between indices of the denotations and the effect annotations of
traditional effect systems. Dually, this approach yields indexed comonads which
gives a unified semantics and effect system to contextual notions of effect
(called coeffects), which we have previously described.
</summary>
    <author>
      <name>Dominic Orchard</name>
    </author>
    <author>
      <name>Tomas Petricek</name>
    </author>
    <author>
      <name>Alan Mycroft</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">extended abstract</arxiv:comment>
    <link href="http://arxiv.org/abs/1401.5391v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1401.5391v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1402.2949v1</id>
    <updated>2014-02-10T21:35:37Z</updated>
    <published>2014-02-10T21:35:37Z</published>
    <title>A Programming Language Oriented Approach to Computability</title>
    <summary>  The field of computability and complexity was, where computer science sprung
from. Turing, Church, and Kleene all developed formalisms that demonstrated
what they held "intuitively computable". The times change however and today's
(aspiring) computer scientists are less proficient in building automata or
composing functions and are much more native to the world of programming
languages. This article will try to introduce typical concepts of computability
theory and complexity in a form more fitted for a modern developer. It is
mostly based on \cite{jones}, but takes input from other sources to provide
examples, additional information, etc.
</summary>
    <author>
      <name>Aaron Karper</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Bachelor thesis at the University of Bern, supervised by Professor
  Dr. Thomas Strahm</arxiv:comment>
    <link href="http://arxiv.org/abs/1402.2949v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1402.2949v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1403.1694v1</id>
    <updated>2014-03-07T09:30:38Z</updated>
    <published>2014-03-07T09:30:38Z</published>
    <title>Methods of executable code protection</title>
    <summary>  The article deals with the problems in constructing a protection system of
executable code. The techniques of breaking the integrity of executable code
and ways to eliminate them are described. The adoption of virtual machine
technology in the context of executable code protection from analysis is
considered. The substantiation of the application of virtual machines as the
best way to oppose the analysis of executable code is made. The protection of
executable code by transferring the protected code in a virtual execution
environment is considered. An efficient implementation of the method is
proposed.
</summary>
    <author>
      <name>Anton Petrov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages, 5 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1403.1694v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1403.1694v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="00-02" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1403.6997v1</id>
    <updated>2014-03-27T12:24:41Z</updated>
    <published>2014-03-27T12:24:41Z</published>
    <title>Optimizing large applications</title>
    <summary>  Both uppermost open source compilers, GCC and LLVM, are mature enough to
link-time optimize large applications. In case of large applications, we must
take into account, except standard speed efficiency and memory consumption,
different aspects. We focus on size of the code, cold start-up time, etc.
Developers of applications often come up with ad-hoc solutions such as Elfhack
utility, start-up of an application via a pre-loading utility and dlopen;
prelinking and variety of different tools that reorder functions to fit the
order of execution. The goal of the thesis is to analyse all existing
techniques of optimization, evaluate their efficiency and design new solutions
based on the link-time optimization platform.
</summary>
    <author>
      <name>Martin Liška</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">78 pages, diploma thesis</arxiv:comment>
    <link href="http://arxiv.org/abs/1403.6997v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1403.6997v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1404.0073v1</id>
    <updated>2014-04-01T00:36:54Z</updated>
    <published>2014-04-01T00:36:54Z</published>
    <title>General dynamic recovery for compensating CSP</title>
    <summary>  Compensation is a technique to roll-back a system to a consistent state in
case of failure. Recovery mechanisms for compensating calculi specify the order
of execution of compensation sequences. Dynamic recovery means that the order
of execution is determined at runtime. In this paper, we define an extension of
Compensating CSP, called DEcCSP, with general dynamic recovery. We provide a
formal, operational semantics for the calculus, and illustrate its expressive
power with a case study. In contrast with previous versions of Compensating
CSP, DEcCSP provides mechanisms to replace or discard compensations at runtime.
Additionally, we bring back to DEcCSP standard CSP operators that are not
available in other compensating CSP calculi, and introduce channel
communication.
</summary>
    <author>
      <name>Abeer S. Al-Humaimeedy</name>
    </author>
    <author>
      <name>Maribel Fernández</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.143.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.143.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings DCM 2012, arXiv:1403.7579</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 143, 2014, pp. 3-16</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1404.0073v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1404.0073v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1404.3407v1</id>
    <updated>2014-04-13T18:20:40Z</updated>
    <published>2014-04-13T18:20:40Z</published>
    <title>Annotated imports</title>
    <summary>  Presented simple extensions to scala language related to import statements:
exported imports, which provide ability to reuse sequence of import clauses in
composable form and default rewriters, which provide mechanism for pluggable
macro-based AST transformation of overall compilation unit, activated by import
of library object. Using these facilities not only allows more compact code, it
prevents application programmer from producing certain type of errors too and
allows to implement local language extension as libraries on top of standard
compiler. Part of discussed extensions is submitted to scala language committee
as pre-sip \cite{ai-presip} and can be used as first step for refining imports
semantics in the future version of scala language.
</summary>
    <author>
      <name>Ruslan Shevchenko</name>
    </author>
    <link href="http://arxiv.org/abs/1404.3407v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1404.3407v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.2538v1</id>
    <updated>2014-05-11T14:45:07Z</updated>
    <published>2014-05-11T14:45:07Z</published>
    <title>Combinatorial Search With Picat</title>
    <summary>  Picat, a new member of the logic programming family, follows a different
doctrine than Prolog in offering the core logic programming concepts: arrays
and maps as built-in data types; implicit pattern matching with explicit
unification and explicit non-determinism; functions for deterministic
computations; and loops for convenient scripting and modeling purposes. Picat
provides facilities for solving combinatorial search problems, including a
common interface with CP, SAT, and MIP solvers, tabling for dynamic
programming, and a module for planning. Picat's planner module, which is
implemented by the use of tabling, has produced surprising and encouraging
results. Thanks to term-sharing and resource-bounded tabled search, Picat
overwhelmingly outperforms the cutting-edge ASP and PDDL planners on the
planning benchmarks used in recent ASP competitions.
</summary>
    <author>
      <name>Neng-Fa Zhou</name>
    </author>
    <link href="http://arxiv.org/abs/1405.2538v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.2538v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.2564v1</id>
    <updated>2014-05-11T18:39:26Z</updated>
    <published>2014-05-11T18:39:26Z</published>
    <title>Towards an Efficient Prolog System by Code Introspection</title>
    <summary>  To appear in Theory and Practice of Logic Programming (TPLP). Several Prolog
interpreters are based on the Warren Abstract Machine (WAM), an elegant model
to compile Prolog programs. In order to improve the performance several
strategies have been proposed, such as: optimize the selection of clauses,
specialize the unification, global analysis, native code generation and
tabling. This paper proposes a different strategy to implement an efficient
Prolog System, the creation of specialized emulators on the fly. The proposed
strategy was implemented and evaluated at YAP Prolog System, and the
experimental evaluation showed interesting results.
</summary>
    <author>
      <name>George Souza Oliveira</name>
    </author>
    <author>
      <name>Anderson Faustino da Silva</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1405.2564v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.2564v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.3791v1</id>
    <updated>2014-05-15T10:27:52Z</updated>
    <published>2014-05-15T10:27:52Z</published>
    <title>On contour representation of two dimensional patterns</title>
    <summary>  Two-dimensional patterns are used in many research areas in computer science,
ranging from image processing to specification and verification of complex
software systems (via scenarios). The contribution of this paper is twofold.
First, we present the basis of a new formal representation of two-dimensional
patterns based on contours and their compositions. Then, we present efficient
algorithms to verify correctness of the contour-representation. Finally, we
briefly discuss possible applications, in particular using them as a basic
instrument in developing software tools for handling two dimensional words.
</summary>
    <author>
      <name>Iulia Teodora Banu-Demergian</name>
    </author>
    <author>
      <name>Gheorghe Stefanescu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in: Carpathian J. Math., 2014</arxiv:comment>
    <link href="http://arxiv.org/abs/1405.3791v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.3791v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.3795v1</id>
    <updated>2014-05-15T10:48:10Z</updated>
    <published>2014-05-15T10:48:10Z</published>
    <title>Logic Programming as Scripting Language for Bots in Computer Games --
  Research Overview</title>
    <summary>  This publication is to present a summary of research (referred as Klabs -
http://www.kappalabs.org) carried out in author's Ph.D studies on topic of
application of Logic Programming as scripting language for virtual character
behavior control in First Person Shooter (FPS) games. The research goal is to
apply reasoning and knowledge representation techniques to create character
behavior, which results in increased players' engagement. An extended abstract
/ full version of a paper accepted to be presented at the Doctoral Consortium
of the 30th International Conference on Logic Programming (ICLP 2014), July
19-22, Vienna, Austria
</summary>
    <author>
      <name>Grzegorz Jaśkiewicz</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1405.3795v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.3795v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.5590v2</id>
    <updated>2016-10-23T19:45:46Z</updated>
    <published>2014-05-22T01:50:47Z</published>
    <title>Language to Specify Syntax-Guided Synthesis Problems</title>
    <summary>  We present a language to specify syntax guided synthesis (SyGuS) problems.
Syntax guidance is a prominent theme in contemporary program synthesis
approaches, and SyGuS was first described in [1]. This paper describes
concretely the input format of a SyGuS solver.
  [1] Rajeev Alur, Rastislav Bodik, Garvit Juniwal, Milo M. K. Martin, Mukund
Raghothaman, Sanjit A. Seshia, Rishabh Singh, Armando Solar-Lezama, Emina
Torlak, and Abhishek Udupa. Syntax-guided synthesis. In FMCAD, pages 1--17,
2013.
</summary>
    <author>
      <name>Mukund Raghothaman</name>
    </author>
    <author>
      <name>Abhishek Udupa</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Fixed small typo in the SyGuS grammar specification pointed out by
  Sergey Mechtaev</arxiv:comment>
    <link href="http://arxiv.org/abs/1405.5590v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.5590v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.1393v1</id>
    <updated>2014-06-05T14:09:30Z</updated>
    <published>2014-06-05T14:09:30Z</published>
    <title>Interclausal Logic Variables</title>
    <summary>  Unification of logic variables instantly connects present and future
observations of their value, independently of their location in the data areas
of the runtime system. The paper extends this property to "interclausal logic
variables", an easy to implement Prolog extension that supports instant global
information exchanges without dynamic database updates. We illustrate their
usefulness with two of algorithms, {\em graph coloring} and {\em minimum
spanning tree}. Implementations of interclausal variables as source-level
transformations and as abstract machine adaptations are given. To address the
need for globally visible chained transitions of logic variables we describe a
DCG-based program transformation that extends the functionality of interclausal
variables.
</summary>
    <author>
      <name>Paul Tarau</name>
    </author>
    <author>
      <name>Fahmida Hamid</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">to appear as a ICLP'14 technical contribution</arxiv:comment>
    <link href="http://arxiv.org/abs/1406.1393v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.1393v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.1534v1</id>
    <updated>2014-06-05T22:07:03Z</updated>
    <published>2014-06-05T22:07:03Z</published>
    <title>Proceedings 5th Workshop on Mathematically Structured Functional
  Programming</title>
    <summary>  This volume contains the proceedings of the Fifth Workshop on Mathematically
Structured Functional Programming (MSFP 2014), taking place on 12 April, 2014
in Grenoble, France, as a satellite event of the European Joint Conferences on
Theory and Practice of Software, ETAPS 2014.
  MSFP is devoted to the derivation of functionality from structure. It
highlights concepts from algebra, semantics and type theory as they are
increasingly reflected in programming practice, especially functional
programming. As the range of papers presented in this year's workshop shows,
this continues to be a fruitful interface.
</summary>
    <author>
      <name>Paul Levy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Birmingham</arxiv:affiliation>
    </author>
    <author>
      <name>Neel Krishnaswami</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Birmingham</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.153</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.153" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 153, 2014</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1406.1534v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.1534v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3; F.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.2058v1</id>
    <updated>2014-06-09T03:29:29Z</updated>
    <published>2014-06-09T03:29:29Z</published>
    <title>Monad Transformers for Backtracking Search</title>
    <summary>  This paper extends Escardo and Oliva's selection monad to the selection monad
transformer, a general monadic framework for expressing backtracking search
algorithms in Haskell. The use of the closely related continuation monad
transformer for similar purposes is also discussed, including an implementation
of a DPLL-like SAT solver with no explicit recursion. Continuing a line of work
exploring connections between selection functions and game theory, we use the
selection monad transformer with the nondeterminism monad to obtain an
intuitive notion of backward induction for a certain class of nondeterministic
games.
</summary>
    <author>
      <name>Jules Hedges</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Queen Mary University of London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.153.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.153.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MSFP 2014, arXiv:1406.1534</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 153, 2014, pp. 31-50</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1406.2058v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.2058v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.2062v1</id>
    <updated>2014-06-09T03:30:38Z</updated>
    <published>2014-06-09T03:30:38Z</published>
    <title>Categorical Semantics for Functional Reactive Programming with Temporal
  Recursion and Corecursion</title>
    <summary>  Functional reactive programming (FRP) makes it possible to express temporal
aspects of computations in a declarative way. Recently we developed two kinds
of categorical models of FRP: abstract process categories (APCs) and concrete
process categories (CPCs). Furthermore we showed that APCs generalize CPCs. In
this paper, we extend APCs with additional structure. This structure models
recursion and corecursion operators that are related to time. We show that the
resulting categorical models generalize those CPCs that impose an additional
constraint on time scales. This constraint boils down to ruling out
$\omega$-supertasks, which are closely related to Zeno's paradox of Achilles
and the tortoise.
</summary>
    <author>
      <name>Wolfgang Jeltsch</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">TTÜ Küberneetika Instituut</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.153.9</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.153.9" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MSFP 2014, arXiv:1406.1534</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 153, 2014, pp. 127-142</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1406.2062v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.2062v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; D.1.1; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.2121v1</id>
    <updated>2014-06-09T10:03:26Z</updated>
    <published>2014-06-09T10:03:26Z</published>
    <title>Constraint Handling Rules with Multiset Comprehension Patterns</title>
    <summary>  CHR is a declarative, concurrent and committed choice rule-based constraint
programming language. We extend CHR with multiset comprehension patterns,
providing the programmer with the ability to write multiset rewriting rules
that can match a variable number of constraints in the store. This enables
writing more readable, concise and declarative code for algorithms that
coordinate large amounts of data or require aggregate operations. We call this
extension $\mathit{CHR}^\mathit{cp}$. We give a high-level abstract semantics
of $\mathit{CHR}^\mathit{cp}$, followed by a lower-level operational semantics.
We then show the soundness of this operational semantics with respect to the
abstract semantics.
</summary>
    <author>
      <name>Edmund S. L. Lam</name>
    </author>
    <author>
      <name>Iliano Cervesato</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Part of CHR 2014 proceedings (arXiv:1406.1510)</arxiv:comment>
    <link href="http://arxiv.org/abs/1406.2121v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.2121v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.3479v1</id>
    <updated>2014-06-13T10:16:41Z</updated>
    <published>2014-06-13T10:16:41Z</published>
    <title>Sessions as Propositions</title>
    <summary>  Recently, Wadler presented a continuation-passing translation from a
session-typed functional language, GV, to a process calculus based on classical
linear logic, CP. However, this translation is one-way: CP is more expressive
than GV. We propose an extension of GV, called HGV, and give translations
showing that it is as expressive as CP. The new translations shed light both on
the original translation from GV to CP, and on the limitations in
expressiveness of GV.
</summary>
    <author>
      <name>Sam Lindley</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">The University of Edinburgh</arxiv:affiliation>
    </author>
    <author>
      <name>J. Garrett Morris</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">The University of Edinburgh</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.155.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.155.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2014, arXiv:1406.3313</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 155, 2014, pp. 9-16</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1406.3479v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.3479v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2;F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.3483v1</id>
    <updated>2014-06-13T10:17:23Z</updated>
    <published>2014-06-13T10:17:23Z</published>
    <title>Lightening Global Types</title>
    <summary>  Global session types prevent participants from waiting for never coming
messages. Some interactions take place just for the purpose of informing
receivers that some message will never arrive or the session is terminated. By
decomposing a big global type into several light global types, one can avoid
such kind of redundant interactions. Lightening global types gives us cleaner
global types, which keep all necessary communications. This work proposes a
framework which allows to easily decompose global types into light global
types, preserving the interaction sequences of the original ones but for
redundant interactions.
</summary>
    <author>
      <name>Tzu-chun Chen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Universita' di Torino, Italy</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.155.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.155.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2014, arXiv:1406.3313</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 155, 2014, pp. 38-46</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1406.3483v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.3483v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1407.3892v1</id>
    <updated>2014-07-15T06:40:59Z</updated>
    <published>2014-07-15T06:40:59Z</published>
    <title>Verified Subtyping with Traits and Mixins</title>
    <summary>  Traits allow decomposing programs into smaller parts and mixins are a form of
composition that resemble multiple inheritance. Unfortunately, in the presence
of traits, programming languages like Scala give up on subtyping relation
between objects. In this paper, we present a method to check subtyping between
objects based on entailment in separation logic. We implement our method as a
domain specific language in Scala and apply it on the Scala standard library.
We have verified that 67% of mixins used in the Scala standard library do
indeed conform to subtyping between the traits that are used to build them.
</summary>
    <author>
      <name>Asankhaya Sharma</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.156.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.156.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings FSFMA 2014, arXiv:1407.1952</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 156, 2014, pp. 45-51</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1407.3892v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1407.3892v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1408.1458v1</id>
    <updated>2014-08-07T01:57:17Z</updated>
    <published>2014-08-07T01:57:17Z</published>
    <title>Distributive Laws and Decidable Properties of SOS Specifications</title>
    <summary>  Some formats of well-behaved operational specifications, correspond to
natural transformations of certain types (for example, GSOS and coGSOS laws).
These transformations have a common generalization: distributive laws of monads
over comonads. We prove that this elegant theoretical generalization has
limited practical benefits: it does not translate to any concrete rule format
that would be complete for specifications that contain both GSOS and coGSOS
rules. This is shown for the case of labeled transition systems and
deterministic stream systems.
</summary>
    <author>
      <name>Bartek Klin</name>
    </author>
    <author>
      <name>Beata Nachyła</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.160.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.160.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings EXPRESS/SOS 2014, arXiv:1408.1271</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 160, 2014, pp. 79-93</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1408.1458v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1408.1458v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1408.1754v1</id>
    <updated>2014-08-08T03:11:41Z</updated>
    <published>2014-08-08T03:11:41Z</published>
    <title>A Partial-Order Approach to Array Content Analysis</title>
    <summary>  We present a parametric abstract domain for array content analysis. The
method maintains invariants for contiguous regions of the array, similar to the
methods of Gopan, Reps and Sagiv, and of Halbwachs and Peron. However, it
introduces a novel concept of an array content graph, avoiding the need for an
up-front factorial partitioning step. The resulting analysis can be used with
arbitrary numeric relational abstract domains; we evaluate the domain on a
range of array manipulating program fragments.
</summary>
    <author>
      <name>Graeme Gange</name>
    </author>
    <author>
      <name>Jorge A. Navas</name>
    </author>
    <author>
      <name>Peter Schachte</name>
    </author>
    <author>
      <name>Harald Sondergaard</name>
    </author>
    <author>
      <name>Peter J. Stuckey</name>
    </author>
    <link href="http://arxiv.org/abs/1408.1754v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1408.1754v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; D.3.1; F.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1408.5564v1</id>
    <updated>2014-08-24T05:47:04Z</updated>
    <published>2014-08-24T05:47:04Z</published>
    <title>Proceedings Third Workshop on Behavioural Types</title>
    <summary>  This volume contains the proceedings of BEAT 2014, the third Workshop on
Behavioural Types. The workshop took place in Rome, Italy, on September 1st
2014, as a satellite even of CONCUR 2014, the 25th International Conference on
Concurrency Theory.
  The aim of this workshop is to bring together researchers in all aspects of
behavioural type theory and its applications, in order to share results,
consolidate the community, and discover opportunities for new collaborations
and future directions.
</summary>
    <author>
      <name>Marco Carbone</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IT University of Copenhagen</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.162</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.162" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 162, 2014</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1408.5564v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1408.5564v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.0757v3</id>
    <updated>2015-05-19T16:17:07Z</updated>
    <published>2014-09-02T15:29:23Z</published>
    <title>Approaches to Interpreter Composition</title>
    <summary>  In this paper, we compose six different Python and Prolog VMs into 4 pairwise
compositions: one using C interpreters; one running on the JVM; one using
meta-tracing interpreters; and one using a C interpreter and a meta-tracing
interpreter. We show that programs that cross the language barrier frequently
execute faster in a meta-tracing composition, and that meta-tracing imposes a
significantly lower overhead on composed programs relative to mono-language
programs.
</summary>
    <author>
      <name>Edd Barrett</name>
    </author>
    <author>
      <name>Carl Friedrich Bolz</name>
    </author>
    <author>
      <name>Laurence Tratt</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/j.cl.2015.03.001</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/j.cl.2015.03.001" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">33 pages, 1 figure, 9 tables</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Computer Languages, Systems and Structures (COMLAN). Volume 44C,
  December 2015, Pages 199-217</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1409.0757v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.0757v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.2089v1</id>
    <updated>2014-09-07T06:42:09Z</updated>
    <published>2014-09-07T06:42:09Z</published>
    <title>Perfrewrite -- Program Complexity Analysis via Source Code
  Instrumentation</title>
    <summary>  Most program profiling methods output the execution time of one specific
program execution, but not its computational complexity class in terms of the
big-O notation. Perfrewrite is a tool based on LLVM's Clang compiler to rewrite
a program such that it tracks semantic information while the program executes
and uses it to guess memory usage, communication and computational complexity.
While source code instrumentation is a standard technique for profiling, using
it for deriving formulas is an uncommon approach.
</summary>
    <author>
      <name>Michael Kruse</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LRI, INRIA Saclay - Ile de France</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">ACACES 2012 summer school (2012)</arxiv:comment>
    <link href="http://arxiv.org/abs/1409.2089v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.2089v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.2764v1</id>
    <updated>2014-09-09T14:56:12Z</updated>
    <published>2014-09-09T14:56:12Z</published>
    <title>Innocent Strategies are Sheaves over Plays---Deterministic,
  Non-deterministic and Probabilistic Innocence</title>
    <summary>  Although the HO/N games are fully abstract for PCF, the traditional notion of
innocence (which underpins these games) is not satisfactory for such language
features as non-determinism and probabilistic branching, in that there are
stateless terms that are not innocent. Based on a category of P-visible plays
with a notion of embedding as morphisms, we propose a natural generalisation by
viewing innocent strategies as sheaves over (a site of) plays, echoing a slogan
of Hirschowitz and Pous. Our approach gives rise to fully complete game models
in each of the three cases of deterministic, nondeterministic and probabilistic
branching. To our knowledge, in the second and third cases, ours are the first
such factorisation-free constructions.
</summary>
    <author>
      <name>Takeshi Tsukada</name>
    </author>
    <author>
      <name>C. -H. Luke Ong</name>
    </author>
    <link href="http://arxiv.org/abs/1409.2764v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.2764v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.7628v1</id>
    <updated>2014-09-26T16:32:07Z</updated>
    <published>2014-09-26T16:32:07Z</published>
    <title>Survey on Combinatorial Register Allocation and Instruction Scheduling</title>
    <summary>  Register allocation and instruction scheduling are two central compiler
back-end problems that are critical for quality. In the last two decades,
combinatorial optimization has emerged as an alternative approach to
traditional, heuristic algorithms for these problems. Combinatorial approaches
are generally slower but more flexible than their heuristic counterparts and
have the potential to generate optimal code. This paper surveys existing
literature on combinatorial register allocation and instruction scheduling. The
survey covers approaches that solve each problem in isolation as well as
approaches that integrate both problems. The latter have the potential to
generate code that is globally optimal by capturing the trade-off between
conflicting register allocation and instruction scheduling decisions.
</summary>
    <author>
      <name>Roberto Castañeda Lozano</name>
    </author>
    <author>
      <name>Christian Schulte</name>
    </author>
    <link href="http://arxiv.org/abs/1409.7628v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.7628v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.7841v1</id>
    <updated>2014-09-27T21:05:38Z</updated>
    <published>2014-09-27T21:05:38Z</published>
    <title>Abstracting an operational semantics to finite automata</title>
    <summary>  There is an apparent similarity between the descriptions of small-step
operational semantics of imperative programs and the semantics of finite
automata, so defining an abstraction mapping from semantics to automata and
proving a simulation property seems to be easy. This paper aims at identifying
the reasons why simple proofs break, among them artifacts in the semantics that
lead to stuttering steps in the simulation. We then present a semantics based
on the zipper data structure, with a direct interpretation of evaluation as
navigation in the syntax tree. The abstraction function is then defined by
equivalence class construction.
</summary>
    <author>
      <name>Nadezhda Baklanova</name>
    </author>
    <author>
      <name>Wilmer Ricciotti</name>
    </author>
    <author>
      <name>Jan-Georg Smaus</name>
    </author>
    <author>
      <name>Martin Strecker</name>
    </author>
    <link href="http://arxiv.org/abs/1409.7841v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.7841v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1410.3735v1</id>
    <updated>2014-10-14T15:34:39Z</updated>
    <published>2014-10-14T15:34:39Z</published>
    <title>The Foundational Cryptography Framework</title>
    <summary>  We present the Foundational Cryptography Framework (FCF) for developing and
checking complete proofs of security for cryptographic schemes within a proof
assistant. This is a general-purpose framework that is capable of modeling and
reasoning about a wide range of cryptographic schemes, security definitions,
and assumptions. Security is proven in the computational model, and the proof
provides concrete bounds as well as asymptotic conclusions. FCF provides a
language for probabilistic programs, a theory that is used to reason about
programs, and a library of tactics and definitions that are useful in proofs
about cryptography. The framework is designed to leverage fully the existing
theory and capabilities of the Coq proof assistant in order to reduce the
effort required to develop proofs.
</summary>
    <author>
      <name>Adam Petcher</name>
    </author>
    <author>
      <name>Greg Morrisett</name>
    </author>
    <link href="http://arxiv.org/abs/1410.3735v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1410.3735v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CR" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1410.3772v1</id>
    <updated>2014-10-12T15:16:55Z</updated>
    <published>2014-10-12T15:16:55Z</published>
    <title>Optimizing the For loop: Comparison of For loop and micro For loop</title>
    <summary>  Looping is one of the fundamental logical instructions used for repeating a
block of code. It is used in programs across all programming languages.
Traditionally, in languages like C, the for loop is used extensively for
repeated execution of a block of code, due to its ease for use and simplified
representation. This paper proposes a new way of representing the for loop to
improve its runtime efficiency and compares the experimental statistics with
the traditional for loop representation. It is found that for small number of
iterations, the difference in computational time may not be considerable. But
given any large number of iterations, the difference is noticeable.
</summary>
    <author>
      <name>Rishabh Jain</name>
    </author>
    <author>
      <name>Sakshi Gupta</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">3 pages, 2 figures, 2 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/1410.3772v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1410.3772v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68-02" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1410.6449v2</id>
    <updated>2014-11-06T19:27:27Z</updated>
    <published>2014-10-23T18:42:57Z</published>
    <title>Parallel Prefix Polymorphism Permits Parallelization, Presentation &amp;
  Proof</title>
    <summary>  Polymorphism in programming languages enables code reuse. Here, we show that
polymorphism has broad applicability far beyond computations for technical
computing: parallelism in distributed computing, presentation of visualizations
of runtime data flow, and proofs for formal verification of correctness. The
ability to reuse a single codebase for all these purposes provides new ways to
understand and verify parallel programs.
</summary>
    <author>
      <name>Jiahao Chen</name>
    </author>
    <author>
      <name>Alan Edelman</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages, 3 figures. Proceedings of HPTCDL, the 1st Workshop on High
  Performance Technical Computing in Dynamic Languages, November 17, 2014, New
  Orleans, Louisiana, USA. Supporting Information available at
  http://jiahao.github.io/parallel-prefix</arxiv:comment>
    <link href="http://arxiv.org/abs/1410.6449v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1410.6449v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.3; D.3.2; G.1.0" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1410.7467v1</id>
    <updated>2014-10-28T00:40:55Z</updated>
    <published>2014-10-28T00:40:55Z</published>
    <title>Toward Sequentializing Overparallelized Protocol Code</title>
    <summary>  In our ongoing work, we use constraint automata to compile protocol
specifications expressed as Reo connectors into efficient executable code,
e.g., in C. We have by now studied this automata based compilation approach
rather well, and have devised effective solutions to some of its problems.
Because our approach is based on constraint automata, the approach, its
problems, and our solutions are in fact useful and relevant well beyond the
specific case of compiling Reo. In this short paper, we identify and analyze
two such rather unexpected problems.
</summary>
    <author>
      <name>Sung-Shik T. Q. Jongmans</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CWI</arxiv:affiliation>
    </author>
    <author>
      <name>Farhad Arbab</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CWI</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.166.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.166.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2014, arXiv:1410.7013</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 166, 2014, pp. 38-44</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1410.7467v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1410.7467v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.0625v1</id>
    <updated>2014-12-01T20:20:04Z</updated>
    <published>2014-12-01T20:20:04Z</published>
    <title>Quipper: Concrete Resource Estimation in Quantum Algorithms</title>
    <summary>  Despite the rich literature on quantum algorithms, there is a surprisingly
small amount of coverage of their concrete logical design and implementation.
Most resource estimation is done at the level of complexity analysis, but
actual concrete numbers (of quantum gates, qubits, etc.) can differ by orders
of magnitude. The line of work we present here is a formal framework to write,
and reason about, quantum algorithms. Specifically, we designed a language,
Quipper, with scalability in mind, and we are able to report actual resource
counts for seven non-trivial algorithms found in the quantum computer science
literature.
</summary>
    <author>
      <name>Jonathan M. Smith</name>
    </author>
    <author>
      <name>Neil J. Ross</name>
    </author>
    <author>
      <name>Peter Selinger</name>
    </author>
    <author>
      <name>Benoît Valiron</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended abstract for a talk given at QAPL 2014</arxiv:comment>
    <link href="http://arxiv.org/abs/1412.0625v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.0625v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.ET" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.4395v1</id>
    <updated>2014-12-14T19:04:47Z</updated>
    <published>2014-12-14T19:04:47Z</published>
    <title>Dafny: Statically Verifying Functional Correctness</title>
    <summary>  This report presents the Dafny language and verifier, with a focus on
describing the main features of the language, including pre- and
postconditions, assertions, loop invariants, termination metrics, quantifiers,
predicates and frames. Examples of Dafny code are provided to illustrate the
use of each feature, and an overview of how Dafny translates programming code
into a mathematical proof of functional verification is presented. The report
also includes references to useful resources on Dafny, with mentions of related
works in the domain of specification languages.
</summary>
    <author>
      <name>Rachel Gauci</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 1 figure</arxiv:comment>
    <link href="http://arxiv.org/abs/1412.4395v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.4395v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.4882v1</id>
    <updated>2014-12-16T05:14:44Z</updated>
    <published>2014-12-16T05:14:44Z</published>
    <title>Simple Balanced Binary Search Trees</title>
    <summary>  Efficient implementations of sets and maps (dictionaries) are important in
computer science, and balanced binary search trees are the basis of the best
practical implementations. Pedagogically, however, they are often quite
complicated, especially with respect to deletion. I present complete code (with
justification and analysis not previously available in the literature) for a
purely-functional implementation based on AA trees, which is the simplest
treatment of the subject of which I am aware.
</summary>
    <author>
      <name>Prabhakar Ragde</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Waterloo, Waterloo, Ontario, Canada</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.170.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.170.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TFPIE 2014, arXiv:1412.4738</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 170, 2014, pp. 78-87</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1412.4882v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.4882v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1501.05338v2</id>
    <updated>2015-11-15T15:34:03Z</updated>
    <published>2015-01-21T21:56:06Z</published>
    <title>Semantics for Locking Specifications</title>
    <summary>  To prevent concurrency errors, programmers need to obey a locking discipline.
Annotations that specify that discipline, such as Java's @GuardedBy, are
already widely used. Unfortunately, their semantics is expressed informally and
is consequently ambiguous. This article highlights such ambiguities and
formalizes the semantics of @GuardedBy in two alternative ways, building on an
operational semantics for a small concurrent fragment of a Java-like language.
It also identifies when such annotations are actual guarantees against data
races. Our work aids in understanding the annotations and supports the
development of sound formal tools that verify or infer such annotations.
</summary>
    <author>
      <name>Michael Ernst</name>
    </author>
    <author>
      <name>Damiano Macedonio</name>
    </author>
    <author>
      <name>Massimo Merro</name>
    </author>
    <author>
      <name>Fausto Spoto</name>
    </author>
    <link href="http://arxiv.org/abs/1501.05338v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1501.05338v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1501.05425v1</id>
    <updated>2015-01-22T08:45:10Z</updated>
    <published>2015-01-22T08:45:10Z</published>
    <title>Foundational Extensible Corecursion</title>
    <summary>  This paper presents a formalized framework for defining corecursive functions
safely in a total setting, based on corecursion up-to and relational
parametricity. The end product is a general corecursor that allows corecursive
(and even recursive) calls under well-behaved operations, including
constructors. Corecursive functions that are well behaved can be registered as
such, thereby increasing the corecursor's expressiveness. The metatheory is
formalized in the Isabelle proof assistant and forms the core of a prototype
tool. The corecursor is derived from first principles, without requiring new
axioms or extensions of the logic.
</summary>
    <author>
      <name>Jasmin Christian Blanchette</name>
    </author>
    <author>
      <name>Andrei Popescu</name>
    </author>
    <author>
      <name>Dmitriy Traytel</name>
    </author>
    <link href="http://arxiv.org/abs/1501.05425v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1501.05425v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1502.00138v1</id>
    <updated>2015-01-31T16:43:46Z</updated>
    <published>2015-01-31T16:43:46Z</published>
    <title>Compositional Invariant Generation via Linear Recurrence Analysis</title>
    <summary>  This paper presents a new method for automatically generating numerical
invariants for imperative programs. Given a program, our procedure computes a
binary input/output relation on program states which over-approximates the
behaviour of the program. It is compositional in the sense that it operates by
decomposing the program into parts, computing an abstract meaning of each part,
and then composing the meanings. Our method for approximating loop behaviour is
based on first approximating the meaning of the loop body, extracting
recurrence relations from that approximation, and then using the closed forms
to approximate the loop. Our experiments demonstrate that on verification
tasks, our method is competitive with leading invariant generation and
verification tools.
</summary>
    <author>
      <name>Azadeh Farzan</name>
    </author>
    <author>
      <name>Zachary Kincaid</name>
    </author>
    <link href="http://arxiv.org/abs/1502.00138v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1502.00138v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1503.04908v1</id>
    <updated>2015-03-17T03:58:44Z</updated>
    <published>2015-03-17T03:58:44Z</published>
    <title>Liquid Intersection Types</title>
    <summary>  We present a new type system combining refinement types and the
expressiveness of intersection type discipline. The use of such features makes
it possible to derive more precise types than in the original refinement
system. We have been able to prove several interesting properties for our
system (including subject reduction) and developed an inference algorithm,
which we proved to be sound.
</summary>
    <author>
      <name>Mário Pereira</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Porto, Department of Computer Science &amp; LIACC</arxiv:affiliation>
    </author>
    <author>
      <name>Sandra Alves</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Porto, Department of Computer Science &amp; LIACC</arxiv:affiliation>
    </author>
    <author>
      <name>Mário Florido</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Porto, Department of Computer Science &amp; LIACC</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.177.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.177.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ITRS 2014, arXiv:1503.04377</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 177, 2015, pp. 24-42</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1503.04908v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1503.04908v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1503.09097v1</id>
    <updated>2015-03-31T15:49:55Z</updated>
    <published>2015-03-31T15:49:55Z</published>
    <title>Open Transactions on Shared Memory</title>
    <summary>  Transactional memory has arisen as a good way for solving many of the issues
of lock-based programming. However, most implementations admit isolated
transactions only, which are not adequate when we have to coordinate
communicating processes. To this end, in this paper we present OCTM, an
Haskell-like language with open transactions over shared transactional memory:
processes can join transactions at runtime just by accessing to shared
variables. Thus a transaction can co-operate with the environment through
shared variables, but if it is rolled-back, also all its effects on the
environment are retracted. For proving the expressive power of TCCS we give an
implementation of TCCS, a CCS-like calculus with open transactions.
</summary>
    <author>
      <name>Marino Miculan</name>
    </author>
    <author>
      <name>Marco Peressotti</name>
    </author>
    <author>
      <name>Andrea Toneguzzo</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-319-19282-6_14</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-319-19282-6_14" rel="related"/>
    <link href="http://arxiv.org/abs/1503.09097v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1503.09097v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.00693v1</id>
    <updated>2015-04-02T21:14:38Z</updated>
    <published>2015-04-02T21:14:38Z</published>
    <title>Comparative Studies of Six Programming Languages</title>
    <summary>  Comparison of programming languages is a common topic of discussion among
software engineers. Multiple programming languages are designed, specified, and
implemented every year in order to keep up with the changing programming
paradigms, hardware evolution, etc. In this paper we present a comparative
study between six programming languages: C++, PHP, C#, Java, Python, VB ; These
languages are compared under the characteristics of reusability, reliability,
portability, availability of compilers and tools, readability, efficiency,
familiarity and expressiveness.
</summary>
    <author>
      <name>Zakaria Alomari</name>
    </author>
    <author>
      <name>Oualid El Halimi</name>
    </author>
    <author>
      <name>Kaushik Sivaprasad</name>
    </author>
    <author>
      <name>Chitrang Pandit</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: text overlap with arXiv:1008.3434 by other authors</arxiv:comment>
    <link href="http://arxiv.org/abs/1504.00693v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.00693v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.02621v1</id>
    <updated>2015-04-10T09:50:23Z</updated>
    <published>2015-04-10T09:50:23Z</published>
    <title>A Reference Interpreter for the Graph Programming Language GP 2</title>
    <summary>  GP 2 is an experimental programming language for computing by graph
transformation. An initial interpreter for GP 2, written in the functional
language Haskell, provides a concise and simply structured reference
implementation. Despite its simplicity, the performance of the interpreter is
sufficient for the comparative investigation of a range of test programs. It
also provides a platform for the development of more sophisticated
implementations.
</summary>
    <author>
      <name>Christopher Bak</name>
    </author>
    <author>
      <name>Glyn Faulkner</name>
    </author>
    <author>
      <name>Detlef Plump</name>
    </author>
    <author>
      <name>Colin Runciman</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.181.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.181.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings GaM 2015, arXiv:1504.02448</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 181, 2015, pp. 48-64</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1504.02621v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.02621v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.03239v1</id>
    <updated>2015-04-13T16:14:43Z</updated>
    <published>2015-04-13T16:14:43Z</published>
    <title>Global Value Numbering: A Precise and Efficient Algorithm</title>
    <summary>  Global Value Numbering (GVN) is an important static analysis to detect
equivalent expressions in a program. We present an iterative data-flow analysis
GVN algorithm in SSA for the purpose of detecting total redundancies. The
central challenge is defining a join operation to detect equivalences at a join
point in polynomial time such that later occurrences of redundant expressions
could be detected. For this purpose, we introduce the novel concept of value
$\phi$-function. We claim the algorithm is precise and takes only polynomial
time.
</summary>
    <author>
      <name>Rekha R Pai</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages, 3 figures, an extended version to be submitted to journal</arxiv:comment>
    <link href="http://arxiv.org/abs/1504.03239v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.03239v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.05372v1</id>
    <updated>2015-04-21T10:19:57Z</updated>
    <published>2015-04-21T10:19:57Z</published>
    <title>Inferring Program Transformations from Type Transformations for
  Partitioning of Ordered Sets</title>
    <summary>  In this paper I introduce a mechanism to derive program transforma- tions
from order-preserving transformations of vector types. The purpose of this work
is to allow automatic generation of correct-by-construction instances of
programs in a streaming data processing paradigm suitable for FPGA processing.
We show that for it is possible to automatically derive instances for programs
based on combinations of opaque element- processing functions combined using
foldl and map, purely from the type transformations.
</summary>
    <author>
      <name>Wim Vanderbauwhede</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This work is supported by the EPSRC through the TyTra project
  (EP/L00058X/1)</arxiv:comment>
    <link href="http://arxiv.org/abs/1504.05372v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.05372v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1505.00017v1</id>
    <updated>2015-04-30T20:16:47Z</updated>
    <published>2015-04-30T20:16:47Z</published>
    <title>Comparative Analysis of Classic Garbage-Collection Algorithms for a
  Lisp-like Language</title>
    <summary>  In this paper, we demonstrate the effectiveness of Cheney's Copy Algorithm
for a Lisp-like system and experimentally show the infeasability of developing
an optimal garbage collector for general use. We summarize and compare several
garbage-collection algorithms including Cheney's Algorithm, the canonical Mark
and Sweep Algorithm, and Knuth's Classical Lisp 2 Algorithm. We implement and
analyze these three algorithms in the context of a custom MicroLisp
environment. We conclude and present the core considerations behind the
development of a garbage collector---specifically for Lisp---and make an
attempt to investigate these issues in depth. We also discuss experimental
results that imply the effectiveness of Cheney's algorithm over Mark-Sweep for
Lisp-like languages.
</summary>
    <author>
      <name>Tyler Hannan</name>
    </author>
    <author>
      <name>Chester Holtz</name>
    </author>
    <author>
      <name>Jonathan Liao</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages, 6 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1505.00017v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1505.00017v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1505.06003v1</id>
    <updated>2015-05-22T09:29:05Z</updated>
    <published>2015-05-22T09:29:05Z</published>
    <title>Opportunities for a Truffle-based Golo Interpreter</title>
    <summary>  Golo is a simple dynamically-typed language for the Java Virtual Machine.
Initially implemented as a ahead-of-time compiler to JVM bytecode, it leverages
invokedy-namic and JSR 292 method handles to implement a reasonably efficient
runtime. Truffle is emerging as a framework for building interpreters for JVM
languages with self-specializing AST nodes. Combined with the Graal compiler,
Truffle offers a simple path towards writing efficient interpreters while
keeping the engineering efforts balanced. The Golo project is interested in
experimenting with a Truffle interpreter in the future, as it would provides
interesting comparison elements between invokedynamic versus Truffle for
building a language runtime.
</summary>
    <author>
      <name>Julien Ponge</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CITI</arxiv:affiliation>
    </author>
    <author>
      <name>Frédéric Le Mouël</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CITI</arxiv:affiliation>
    </author>
    <author>
      <name>Nicolas Stouls</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CITI</arxiv:affiliation>
    </author>
    <author>
      <name>Yannick Loiseau</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIMOS</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1505.06003v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1505.06003v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1505.06299v1</id>
    <updated>2015-05-23T10:03:49Z</updated>
    <published>2015-05-23T10:03:49Z</published>
    <title>Tracking Causal Dependencies in Web Services Orchestrations Defined in
  ORC</title>
    <summary>  This article shows how the operational semantics of a language like ORC can
be instrumented so that the execution of a program produces information on the
causal dependencies between events. The concurrent semantics we obtain is based
on asymmetric labeled event structures. The approach is illustrated using a Web
service orchestration instance and the detection of race conditions.
</summary>
    <author>
      <name>Matthieu Perrin</name>
    </author>
    <author>
      <name>Claude Jard</name>
    </author>
    <author>
      <name>Achour Mostefaoui</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">NETYS - 3rd International Conference on NETwork sYStems, May 2015,
  Agadir, Morocco. 2015, Proceedings of the third international conference on
  network systems</arxiv:comment>
    <link href="http://arxiv.org/abs/1505.06299v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1505.06299v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1505.07375v1</id>
    <updated>2015-05-26T04:16:50Z</updated>
    <published>2015-05-26T04:16:50Z</published>
    <title>The Mysteries of Lisp -- I: The Way to S-expression Lisp</title>
    <summary>  Despite its old age, Lisp remains mysterious to many of its admirers. The
mysteries on one hand fascinate the language, on the other hand also obscure
it. Following Stoyan but paying attention to what he has neglected or omitted,
in this first essay of a series intended to unravel these mysteries, we trace
the development of Lisp back to its origin, revealing how the language has
evolved into its nowadays look and feel. The insights thus gained will not only
enhance existent understanding of the language but also inspires further
improvement of it.
</summary>
    <author>
      <name>Hong-Yi Dai</name>
    </author>
    <link href="http://arxiv.org/abs/1505.07375v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1505.07375v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1506.04161v1</id>
    <updated>2015-06-12T20:12:57Z</updated>
    <published>2015-06-12T20:12:57Z</published>
    <title>A simple abstraction of arrays and maps by program translation</title>
    <summary>  We present an approach for the static analysis of programs handling arrays,
with a Galois connection between the semantics of the array program and
semantics of purely scalar operations. The simplest way to implement it is by
automatic, syntactic transformation of the array program into a scalar program
followed analysis of the scalar program with any static analysis technique
(abstract interpretation, acceleration, predicate abstraction,.. .). The
scalars invariants thus obtained are translated back onto the original program
as universally quantified array invariants. We illustrate our approach on a
variety of examples, leading to the " Dutch flag " algorithm.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>Francesco Alberti</name>
    </author>
    <link href="http://arxiv.org/abs/1506.04161v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1506.04161v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1506.04498v1</id>
    <updated>2015-06-15T07:48:14Z</updated>
    <published>2015-06-15T07:48:14Z</published>
    <title>Egison: Non-Linear Pattern-Matching against Non-Free Data Types</title>
    <summary>  This paper introduces the Egison programming language whose feature is strong
pattern-matching facility against not only algebraic data types but also
non-free data types whose data have multiple ways of representation such as
sets and graphs. Our language supports multiple occurrences of the same
variables in a pattern, multiple results of pattern-matching, polymorphism of
pattern-constructors and loop-patterns, patterns that contain "and-so-forth"
whose repeat count can be changed by the parameter. This paper proposes the way
to design expressions that have all these features and demonstrates how these
features are useful to express programs concise. Egison has already implemented
in Haskell.
</summary>
    <author>
      <name>Satoshi Egi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages. arXiv admin note: text overlap with arXiv:1407.0729</arxiv:comment>
    <link href="http://arxiv.org/abs/1506.04498v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1506.04498v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1506.04857v1</id>
    <updated>2015-06-16T07:09:05Z</updated>
    <published>2015-06-16T07:09:05Z</published>
    <title>Mutually Exclusive Modules in Logic Programming</title>
    <summary>  Logic programming has traditionally lacked devices for expressing mutually
exclusive modules. We address this limitation by adopting choice-conjunctive
modules of the form $D_0 \&amp; D_1$ where $D_0, D_1$ are a conjunction of Horn
clauses and $\&amp;$ is a linear logic connective. Solving a goal $G$ using $D_0 \&amp;
D_1$ -- $exec(D_0 \&amp; D_1,G)$ -- has the following operational semantics:
$choose$ a successful one between $exec(D_0,G)$ and $exec(D_1,G)$. In other
words, if $D_0$ is chosen in the course of solving $G$, then $D_1$ will be
discarded and vice versa. Hence, the class of choice-conjunctive modules can
capture the notion of mutually exclusive modules.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1506.04857v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1506.04857v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1506.05270v1</id>
    <updated>2015-06-17T10:28:41Z</updated>
    <published>2015-06-17T10:28:41Z</published>
    <title>jUCM: Universal Class Morphing (position paper)</title>
    <summary>  We extend prior work on class-morphing to provide a more expressive
pattern-based compile-time reflection language. Our MorphJ language offers a
disciplined form of metaprogramming that produces types by statically iterating
over and pattern-matching on fields and methods of other types. We expand such
capabilities with "universal morphing", which also allows pattern-matching over
types (e.g., all classes nested in another, all supertypes of a class) while
maintaining modular type safety for our meta-programs. We present informal
examples of the functionality and discuss a design for adding universal
morphing to Java.
</summary>
    <author>
      <name>Aggelos Biboudis</name>
    </author>
    <author>
      <name>George Fourtounis</name>
    </author>
    <author>
      <name>Yannis Smaragdakis</name>
    </author>
    <link href="http://arxiv.org/abs/1506.05270v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1506.05270v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1506.07813v1</id>
    <updated>2015-06-25T16:59:52Z</updated>
    <published>2015-06-25T16:59:52Z</published>
    <title>ADsafety: Type-Based Verification of JavaScript Sandboxing</title>
    <summary>  Web sites routinely incorporate JavaScript programs from several sources into
a single page. These sources must be protected from one another, which requires
robust sandboxing. The many entry-points of sandboxes and the subtleties of
JavaScript demand robust verification of the actual sandbox source. We use a
novel type system for JavaScript to encode and verify sandboxing properties.
The resulting verifier is lightweight and efficient, and operates on actual
source. We demonstrate the effectiveness of our technique by applying it to
ADsafe, which revealed several bugs and other weaknesses.
</summary>
    <author>
      <name>Joe Gibbs Politz</name>
    </author>
    <author>
      <name>Spiridon Eliopoulos</name>
    </author>
    <author>
      <name>Arjun Guha</name>
    </author>
    <author>
      <name>Shriram Krishnamurthi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">in Proceedings of the USENIX Security Symposium (2011)</arxiv:comment>
    <link href="http://arxiv.org/abs/1506.07813v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1506.07813v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.00385v1</id>
    <updated>2015-07-01T22:14:45Z</updated>
    <published>2015-07-01T22:14:45Z</published>
    <title>Bounded Refinement Types</title>
    <summary>  We present a notion of bounded quantification for refinement types and show
how it expands the expressiveness of refinement typing by using it to develop
typed combinators for: (1) relational algebra and safe database access, (2)
Floyd-Hoare logic within a state transformer monad equipped with combinators
for branching and looping, and (3) using the above to implement a refined IO
monad that tracks capabilities and resource usage. This leap in expressiveness
comes via a translation to "ghost" functions, which lets us retain the
automated and decidable SMT based checking and inference that makes refinement
typing effective in practice.
</summary>
    <author>
      <name>Niki Vazou</name>
    </author>
    <author>
      <name>Alexander Bakst</name>
    </author>
    <author>
      <name>Ranjit Jhala</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages, International Conference on Functional Programming, ICFP
  2015</arxiv:comment>
    <link href="http://arxiv.org/abs/1507.00385v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.00385v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; D.3.3; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.01656v1</id>
    <updated>2015-07-07T01:47:31Z</updated>
    <published>2015-07-07T01:47:31Z</published>
    <title>Languages for Mobile Agents</title>
    <summary>  Mobile agents represent a new model for network computing. Many different
languages have been used to implement mobile agents. The characteristics that
make a language useful for writing mobile agents are: (1) their support of
agent migration, (2) their support for agent-to-agent communication, (3) how
they allow agents to interact with local resources, (4) security mechanisms,
(5) execution efficiency, (6) language implementation across multiple
platforms, and (7) the language's ease of programming of the tasks mobile
agents perform.
</summary>
    <author>
      <name>Steve Versteeg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Honours Thesis. Department of Computer Science and Sofware
  Engineering, University of Melbourne. 1997</arxiv:comment>
    <link href="http://arxiv.org/abs/1507.01656v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.01656v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.05454v1</id>
    <updated>2015-07-20T11:41:49Z</updated>
    <published>2015-07-20T11:41:49Z</published>
    <title>Concolic Testing in Logic Programming</title>
    <summary>  Software testing is one of the most popular validation techniques in the
software industry. Surprisingly, we can only find a few approaches to testing
in the context of logic programming. In this paper, we introduce a systematic
approach for dynamic testing that combines both concrete and symbolic
execution. Our approach is fully automatic and guarantees full path coverage
when it terminates. We prove some basic properties of our technique and
illustrate its practical usefulness through a prototype implementation.
</summary>
    <author>
      <name>Fred Mesnard</name>
    </author>
    <author>
      <name>Étienne Payet</name>
    </author>
    <author>
      <name>Germán Vidal</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068415000332</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068415000332" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Theory and Practice of Logic Programming (TPLP),
  Proceedings of ICLP 2015</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming 15 (2015) 711-725</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1507.05454v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.05454v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.06576v1</id>
    <updated>2015-07-23T17:26:57Z</updated>
    <published>2015-07-23T17:26:57Z</published>
    <title>Abstract Gringo</title>
    <summary>  This paper defines the syntax and semantics of the input language of the ASP
grounder GRINGO. The definition covers several constructs that were not
discussed in earlier work on the semantics of that language, including
intervals, pools, division of integers, aggregates with non-numeric values, and
lparse-style aggregate expressions. The definition is abstract in the sense
that it disregards some details related to representing programs by strings of
ASCII characters. It serves as a specification for GRINGO from Version 4.5 on.
</summary>
    <author>
      <name>Martin Gebser</name>
    </author>
    <author>
      <name>Amelia Harrison</name>
    </author>
    <author>
      <name>Roland Kaminski</name>
    </author>
    <author>
      <name>Vladimir Lifschitz</name>
    </author>
    <author>
      <name>Torsten Schaub</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068415000150</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068415000150" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming 15 (2015) 449-463</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1507.06576v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.06576v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.06988v1</id>
    <updated>2015-07-24T18:26:21Z</updated>
    <published>2015-07-24T18:26:21Z</published>
    <title>A Binary Data Stream Scripting Language</title>
    <summary>  Any file is fundamentally a binary data stream. A practical solution was
achieved to interpret binary data stream. A new scripting language named Data
Format Scripting Language (DFSL) was developed to describe the physical layout
of the data in a structural, more intelligible way. On the basis of the
solution, a generic software application was implemented; it parses various
binary data streams according to their respective DFSL scripts and generates
human-readable result and XML document for data sharing. Our solution helps
eliminate the error-prone low-level programming, especially in the hardware
devices or network protocol development/debugging processes.
</summary>
    <author>
      <name>Lihua Wang</name>
    </author>
    <author>
      <name>Luz Fernando Capretz</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Transactions on Information Science and Applications,
  3(2):291-298, 2006</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1507.06988v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.06988v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.08087v1</id>
    <updated>2015-07-29T10:01:22Z</updated>
    <published>2015-07-29T10:01:22Z</published>
    <title>Tabling as a Library with Delimited Control</title>
    <summary>  Tabling is probably the most widely studied extension of Prolog. But despite
its importance and practicality, tabling is not implemented by most Prolog
systems. Existing approaches require substantial changes to the Prolog engine,
which is an investment out of reach of most systems. To enable more widespread
adoption, we present a new implementation of tabling in under 600 lines of
Prolog code. Our lightweight approach relies on delimited control and provides
reasonable performance.
</summary>
    <author>
      <name>Benoit Desouter</name>
    </author>
    <author>
      <name>Tom Schrijvers</name>
    </author>
    <author>
      <name>Marko van Dooren</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages. To appear in Theory and Practice of Logic Programming
  (TPLP), Proceedings of ICLP 2015</arxiv:comment>
    <link href="http://arxiv.org/abs/1507.08087v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.08087v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.08610v1</id>
    <updated>2015-07-30T18:15:02Z</updated>
    <published>2015-07-30T18:15:02Z</published>
    <title>Fast, Flexible, and Declarative Construction of Abstract Syntax Trees
  with PEGs</title>
    <summary>  We address a declarative construction of abstract syntax trees with Parsing
Expression Grammars. AST operators (constructor, connector, and tagging) are
newly defined to specify flexible AST constructions. A new challenge coming
with PEGs is the consistency management of ASTs in backtracking and packrat
parsing. We make the transaction AST machine in order to perform AST operations
in the context of the speculative parsing of PEGs. All the consistency control
is automated by the analysis of AST operators. The proposed approach is
implemented in the Nez parser, written in Java. The performance study shows
that the transactional AST machine requires 25\% approximately more time in
CSV, XML, and C grammars.
</summary>
    <author>
      <name>Kimio Kuramitsu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Journal of Information Processing (2015)</arxiv:comment>
    <link href="http://arxiv.org/abs/1507.08610v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.08610v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.03536v1</id>
    <updated>2015-08-14T15:05:14Z</updated>
    <published>2015-08-14T15:05:14Z</published>
    <title>Proceedings of the 3rd Workshop on Domain-Specific Language Design and
  Implementation (DSLDI 2015)</title>
    <summary>  The goal of the DSLDI workshop is to bring together researchers and
practitioners interested in sharing ideas on how DSLs should be designed,
implemented, supported by tools, and applied in realistic application contexts.
We are both interested in discovering how already known domains such as graph
processing or machine learning can be best supported by DSLs, but also in
exploring new domains that could be targeted by DSLs. More generally, we are
interested in building a community that can drive forward the development of
modern DSLs. These informal post-proceedings contain the submitted talk
abstracts to the 3rd DSLDI workshop (DSLDI'15), and a summary of the panel
discussion on Language Composition.
</summary>
    <author>
      <name>Tijs van der Storm</name>
    </author>
    <author>
      <name>Sebastian Erdweg</name>
    </author>
    <link href="http://arxiv.org/abs/1508.03536v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.03536v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.03892v1</id>
    <updated>2015-08-17T01:36:36Z</updated>
    <published>2015-08-17T01:36:36Z</published>
    <title>Building an IDE for the Calculational Derivation of Imperative Programs</title>
    <summary>  In this paper, we describe an IDE called CAPS (Calculational Assistant for
Programming from Specifications) for the interactive, calculational derivation
of imperative programs. In building CAPS, our aim has been to make the IDE
accessible to non-experts while retaining the overall flavor of the
pen-and-paper calculational style. We discuss the overall architecture of the
CAPS system, the main features of the IDE, the GUI design, and the trade-offs
involved.
</summary>
    <author>
      <name>Dipak L. Chaudhari</name>
    </author>
    <author>
      <name>Om Damani</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.187.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.187.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings F-IDE 2015, arXiv:1508.03388</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 187, 2015, pp. 1-13</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1508.03892v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.03892v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.03901v1</id>
    <updated>2015-08-17T01:51:02Z</updated>
    <published>2015-08-17T01:51:02Z</published>
    <title>Unlocking Blocked Communicating Processes</title>
    <summary>  We study the problem of disentangling locked processes via code refactoring.
We identify and characterise a class of processes that is not lock-free; then
we formalise an algorithm that statically detects potential locks and propose
refactoring procedures that disentangle detected locks. Our development is cast
within a simple setting of a finite linear CCS variant \^a although it suffices
to illustrate the main concepts, we also discuss how our work extends to other
language extensions.
</summary>
    <author>
      <name>Adrian Francalanza</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CS, ICT, University of Malta</arxiv:affiliation>
    </author>
    <author>
      <name>Marco Giunti</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">RELEASE, DI, Universidade da Beira Interior &amp; NOVA LINCS, DI-FCT, Universidade NOVA de Lisboa</arxiv:affiliation>
    </author>
    <author>
      <name>António Ravara</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">NOVA LINCS, DI-FCT, Universidade NOVA de Lisboa</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.188.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.188.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings WWV 2015, arXiv:1508.03389</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 188, 2015, pp. 23-32</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1508.03901v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.03901v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.07547v2</id>
    <updated>2016-03-22T00:50:14Z</updated>
    <published>2015-08-30T09:11:14Z</published>
    <title>Protocol Programming: A Connection of the Digital World</title>
    <summary>  The current computer programmings encapsulate attributes and behaviours into
objects, but miss the mechanism to support the connection among objects. A
programming paradigm is presented to connect all objects. The connection
supports communications. Protocols are defined to coordinate the behaviours
between objects, which enable the interaction of objects across different
platforms. The connection also provides an efficient mechanism to support the
concurrency, parallelism, distribution, pipeline and adaptability, etc. They
can be governed transparently, autonomously, even adaptively. In this paper, an
implementation is also discussed to show the effectiveness of protocol
programming.
</summary>
    <author>
      <name>Yanping Chen</name>
    </author>
    <author>
      <name>Qinghua Zheng</name>
    </author>
    <author>
      <name>Ping Chen</name>
    </author>
    <link href="http://arxiv.org/abs/1508.07547v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.07547v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1509.04040v1</id>
    <updated>2015-09-14T11:37:06Z</updated>
    <published>2015-09-14T11:37:06Z</published>
    <title>Programs as proofs</title>
    <summary>  The Curry-Howard correspondence is about a relationship between types and
programs on the one hand and propositions and proofs on the other. The
implications for programming language design and program verification is an
active field of research.
  Transformer-like semantics of internal definitions that combine a defining
computation and an application will be presented. By specialisation for a given
defining computation one can derive inference rules for applications of defined
operations.
  With semantics of that kind for every operation, each application identifies
an axiom in a logic defined by the programming language, so a language can be
considered a theory.
</summary>
    <author>
      <name>Jørgen Steensgaard-Madsen</name>
    </author>
    <link href="http://arxiv.org/abs/1509.04040v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1509.04040v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; D.3.3; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1510.00925v1</id>
    <updated>2015-10-04T11:23:12Z</updated>
    <published>2015-10-04T11:23:12Z</published>
    <title>The Essence of JavaScript</title>
    <summary>  We reduce JavaScript to a core calculus structured as a small-step
operational semantics. We present several peculiarities of the language and
show that our calculus models them. We explicate the desugaring process that
turns JavaScript programs into ones in the core. We demonstrate faithfulness to
JavaScript using real-world test suites. Finally, we illustrate utility by
defining a security property, implementing it as a type system on the core, and
extending it to the full language.
</summary>
    <author>
      <name>Arjun Guha</name>
    </author>
    <author>
      <name>Claudiu Saftoiu</name>
    </author>
    <author>
      <name>Shriram Krishnamurthi</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-642-14107-2_7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-642-14107-2_7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">European Conference on Object-Oriented Programming (ECOOP) 2010</arxiv:comment>
    <link href="http://arxiv.org/abs/1510.00925v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1510.00925v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1510.01752v2</id>
    <updated>2015-12-20T15:33:51Z</updated>
    <published>2015-10-06T20:37:11Z</published>
    <title>Type Reconstruction for the Linear π-Calculus with Composite Regular
  Types</title>
    <summary>  We extend the linear {\pi}-calculus with composite regular types in such a
way that data containing linear values can be shared among several processes,
if there is no overlapping access to such values. We describe a type
reconstruction algorithm for the extended type system and discuss some
practical aspects of its implementation.
</summary>
    <author>
      <name>Luca Padovani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Universitá di Torino</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">45 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 11, Issue 4 (December
  22, 2015) lmcs:1614</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1510.01752v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1510.01752v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1510.03929v4</id>
    <updated>2016-04-13T15:13:53Z</updated>
    <published>2015-10-13T23:35:13Z</published>
    <title>Type-Based Analysis for Session Inference</title>
    <summary>  We propose a type-based analysis to infer the session protocols of channels
in an ML-like concurrent functional language. Combining and extending
well-known techniques, we develop a type-checking system that separates the
underlying ML type system from the typing of sessions. Without using linearity,
our system guarantees communication safety and partial lock freedom. It also
supports provably complete session inference for finite sessions with no
programmer annotations. We exhibit the usefulness of our system with
interesting examples, including one which is not typable in substructural type
systems.
</summary>
    <author>
      <name>Carlo Spaccasassi</name>
    </author>
    <author>
      <name>Vasileios Koutavas</name>
    </author>
    <link href="http://arxiv.org/abs/1510.03929v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1510.03929v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.00928v1</id>
    <updated>2015-11-03T14:40:57Z</updated>
    <published>2015-11-03T14:40:57Z</published>
    <title>Visualising interactive inferences with IDPD3</title>
    <summary>  A large part of the use of knowledge base systems is the interpretation of
the output by the end-users and the interaction with these users. Even during
the development process visualisations can be a great help to the developer. We
created IDPD3 as a library to visualise models of logic theories. IDPD3 is a
new version of $ID^{P}_{Draw}$ and adds support for visualised interactive
simulations.
</summary>
    <author>
      <name>Ruben Lapauw</name>
    </author>
    <author>
      <name>Ingmar Dasseville</name>
    </author>
    <author>
      <name>Marc Denecker</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">International Workshop on User-Oriented Logic Programming (IULP
  2015), co-located with the 31st International Conference on Logic Programming
  (ICLP 2015), Proceedings of the International Workshop on User-Oriented Logic
  Programming (IULP 2015), Editors: Stefan Ellmauthaler and Claudia Schulz,
  pages 67-81, August 2015</arxiv:comment>
    <link href="http://arxiv.org/abs/1511.00928v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.00928v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.01838v1</id>
    <updated>2015-11-05T18:05:10Z</updated>
    <published>2015-11-05T18:05:10Z</published>
    <title>The Complexity of Interaction (Long Version)</title>
    <summary>  In this paper, we analyze the complexity of functional programs written in
the interaction-net computation model, an asynchronous, parallel and confluent
model that generalizes linear-logic proof nets. Employing user-defined sized
and scheduled types, we certify concrete time, space and space-time complexity
bounds for both sequential and parallel reductions of interaction-net programs
by suitably assigning complexity potentials to typed nodes. The relevance of
this approach is illustrated on archetypal programming examples. The provided
analysis is precise, compositional and is, in theory, not restricted to
particular complexity classes.
</summary>
    <author>
      <name>Stéphane Gimenez</name>
    </author>
    <author>
      <name>Georg Moser</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/2837614.2837646</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/2837614.2837646" rel="related"/>
    <link href="http://arxiv.org/abs/1511.01838v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.01838v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.02415v1</id>
    <updated>2015-11-08T00:25:07Z</updated>
    <published>2015-11-08T00:25:07Z</published>
    <title>Anonymous On-line Communication Between Program Analyses</title>
    <summary>  We propose a light-weight client-server model of communication between
program analyses. Clients are individual analyses and the server mediates their
communication. A client cannot see properties of any other and the
communication is anonymous. There is no central algorithm standing above
clients which would tell them when to communicate what information. Clients
communicate with others spontaneously, according to their actual personal
needs. The model is based on our observation that a piece of information
provided to an analysis at a right place may (substantially) improve its
result. We evaluated the proposed communication model for all possible
combinations of three clients on more than 400 benchmarks and the results show
that the communication model performs well in practice.
</summary>
    <author>
      <name>Marek Trtik</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Regular paper, 20 pages. arXiv admin note: text overlap with
  arXiv:1504.07862</arxiv:comment>
    <link href="http://arxiv.org/abs/1511.02415v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.02415v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.02629v1</id>
    <updated>2015-11-09T10:51:06Z</updated>
    <published>2015-11-09T10:51:06Z</published>
    <title>Normalisation by Traversals</title>
    <summary>  We present a novel method of computing the beta-normal eta-long form of a
simply-typed lambda-term by constructing traversals over a variant abstract
syntax tree of the term. In contrast to beta-reduction, which changes the term
by substitution, this method of normalisation by traversals leaves the original
term intact. We prove the correctness of the normalisation procedure by game
semantics. As an application, we establish a path-traversal correspondence
theorem which is the basis of a key decidability result in higher-order model
checking.
</summary>
    <author>
      <name>C. -H. Luke Ong</name>
    </author>
    <link href="http://arxiv.org/abs/1511.02629v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.02629v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1; I.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.03406v1</id>
    <updated>2015-11-11T07:44:04Z</updated>
    <published>2015-11-11T07:44:04Z</published>
    <title>Implementing a Small Parsing Virtual Machine on Embedded Systems</title>
    <summary>  PEGs are a formal grammar foundation for describing syntax, and are not hard
to generate parsers with a plain recursive decent parsing. However, the large
amount of C-stack consumption in the recursive parsing is not acceptable
especially in resource-restricted embedded systems. Alternatively, we have
attempted the machine virtualization approach to PEG-based parsing. MiniNez,
our implemented virtual machine, is presented in this paper with several
downsizing techniques, including instruction specialization, inline expansion
and static flow analysis. As a result, the MiniNez machine achieves both a very
small footprint and competitive performance to generated C parsers. We have
demonstrated the experimental results by comparing on two major embedded
platforms: Cortex-A7 and Intel Atom processor.
</summary>
    <author>
      <name>Shun Honda</name>
    </author>
    <author>
      <name>Kimio Kuramitsu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">An earlier draft for future submission</arxiv:comment>
    <link href="http://arxiv.org/abs/1511.03406v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.03406v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.05104v1</id>
    <updated>2015-11-16T19:48:48Z</updated>
    <published>2015-11-16T19:48:48Z</published>
    <title>Time complexity of concurrent programs</title>
    <summary>  We study the problem of automatically computing the time complexity of
concurrent object-oriented programs. To determine this complexity we use
intermediate abstract descriptions that record relevant information for the
time analysis (cost of statements, creations of objects, and concurrent
operations), called behavioural types. Then, we define a translation function
that takes behavioural types and makes the parallelism explicit into so-called
cost equations, which are fed to an automatic off-the-shelf solver for
obtaining the time complexity.
</summary>
    <author>
      <name>Elena Giachino</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">DISI, FOCUS</arxiv:affiliation>
    </author>
    <author>
      <name>Einar Broch Johnsen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">DISI, FOCUS</arxiv:affiliation>
    </author>
    <author>
      <name>Cosimo Laneve</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">DISI, FOCUS</arxiv:affiliation>
    </author>
    <author>
      <name>Ka I Pun</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">FACS 2015, Oct 2015, Niter\'oi, Rio de Janeiro, Brazil</arxiv:comment>
    <link href="http://arxiv.org/abs/1511.05104v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.05104v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1512.01895v1</id>
    <updated>2015-12-07T03:16:36Z</updated>
    <published>2015-12-07T03:16:36Z</published>
    <title>Modular implicits</title>
    <summary>  We present modular implicits, an extension to the OCaml language for ad-hoc
polymorphism inspired by Scala implicits and modular type classes. Modular
implicits are based on type-directed implicit module parameters, and elaborate
straightforwardly into OCaml's first-class functors. Basing the design on
OCaml's modules leads to a system that naturally supports many features from
other languages with systematic ad-hoc overloading, including inheritance,
instance constraints, constructor classes and associated types.
</summary>
    <author>
      <name>Leo White</name>
    </author>
    <author>
      <name>Frédéric Bour</name>
    </author>
    <author>
      <name>Jeremy Yallop</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.198.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.198.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ML/OCaml 2014, arXiv:1512.01438</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 198, 2015, pp. 22-63</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1512.01895v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1512.01895v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1512.07681v1</id>
    <updated>2015-12-24T01:39:47Z</updated>
    <published>2015-12-24T01:39:47Z</published>
    <title>A Context-Oriented Extension of F#</title>
    <summary>  Context-Oriented programming languages provide us with primitive constructs
to adapt program behaviour depending on the evolution of their operational
environment, namely the context. In previous work we proposed ML_CoDa, a
context-oriented language with two-components: a declarative constituent for
programming the context and a functional one for computing. This paper
describes the implementation of ML_CoDa as an extension of F#.
</summary>
    <author>
      <name>Andrea Canciani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Pisa, Pisa, Italy</arxiv:affiliation>
    </author>
    <author>
      <name>Pierpaolo Degano</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Pisa, Pisa, Italy</arxiv:affiliation>
    </author>
    <author>
      <name>Gian-Luigi Ferrari</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Pisa, Pisa, Italy</arxiv:affiliation>
    </author>
    <author>
      <name>Letterio Galletta</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Pisa, Pisa, Italy</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.201.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.201.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings FOCLASA 2015, arXiv:1512.06947</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 201, 2015, pp. 18-32</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1512.07681v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1512.07681v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.1.6; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1601.00713v1</id>
    <updated>2016-01-05T01:44:35Z</updated>
    <published>2016-01-05T01:44:35Z</published>
    <title>Almost Continuous Transformations of Software and Higher-order Dataflow
  Programming</title>
    <summary>  We consider two classes of stream-based computations which admit taking
linear combinations of execution runs: probabilistic sampling and generalized
animation. The dataflow architecture is a natural platform for programming with
streams. The presence of linear combinations allows us to introduce the notion
of almost continuous transformation of dataflow graphs. We introduce a new
approach to higher-order dataflow programming: a dynamic dataflow program is a
stream of dataflow graphs evolving by almost continuous transformations. A
dynamic dataflow program would typically run while it evolves. We introduce
Fluid, an experimental open source system for programming with dataflow graphs
and almost continuous transformations.
</summary>
    <author>
      <name>Michael Bukatin</name>
    </author>
    <author>
      <name>Steve Matthews</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, July 9, 2015 preprint</arxiv:comment>
    <link href="http://arxiv.org/abs/1601.00713v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1601.00713v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1601.02059v1</id>
    <updated>2016-01-09T01:05:03Z</updated>
    <published>2016-01-09T01:05:03Z</published>
    <title>The Essence of Inheritance</title>
    <summary>  Programming languages serve a dual purpose: to communicate programs to
computers, and to communicate programs to humans. Indeed, it is this dual
purpose that makes programming language design a constrained and challenging
problem. Inheritance is an essential aspect of that second purpose: it is a
tool to improve communication. Humans understand new concepts most readily by
first looking at a number of concrete examples, and later abstracting over
those examples. The essence of inheritance is that it mirrors this process: it
provides a formal mechanism for moving from the concrete to the abstract.
</summary>
    <author>
      <name>Andrew P. Black</name>
    </author>
    <author>
      <name>Kim B. Bruce</name>
    </author>
    <author>
      <name>James Noble</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This paper was submitted for inclusion in a Festschrift entitled "A
  list of successes that can change the world", to be published by Springer</arxiv:comment>
    <link href="http://arxiv.org/abs/1601.02059v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1601.02059v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1601.06517v2</id>
    <updated>2016-02-04T09:34:54Z</updated>
    <published>2016-01-25T08:56:27Z</published>
    <title>Programmable Restoration Granularity in Constraint Programming</title>
    <summary>  In most constraint programming systems, a limited number of search engines is
offered while the programming of user-customized search algorithms requires
low-level efforts, which complicates the deployment of such algorithms. To
alleviate this limitation, concepts such as computation spaces have been
developed. Computation spaces provide a coarse-grained restoration mechanism,
because they store all information contained in a search tree node. Other
granularities are possible, and in this paper we make the case for dynamically
adapting the restoration granularity during search. In order to elucidate
programmable restoration granularity, we present restoration as an aspect of a
constraint programming system, using the model of aspect-oriented programming.
A proof-of-concept implementation using Gecode shows promising results.
</summary>
    <author>
      <name>Yong Lin</name>
    </author>
    <author>
      <name>Martin Henz</name>
    </author>
    <link href="http://arxiv.org/abs/1601.06517v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1601.06517v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1602.06568v2</id>
    <updated>2017-04-23T18:35:46Z</updated>
    <published>2016-02-21T19:18:58Z</published>
    <title>Modelling homogeneous generative meta-programming</title>
    <summary>  Homogeneous generative meta-programming (HGMP) enables the generation of
program fragments at compile-time or run-time. We present the first
foundational calculus which can model powerful HGMP languages such as Template
Haskell. The calculus is designed such that we can gradually enhance it with
the features needed to model many of the advanced features of real languages.
As a demonstration of the flexibility of our approach, we also provide a simple
type system for the calculus.
</summary>
    <author>
      <name>Martin Berger</name>
    </author>
    <author>
      <name>Laurence Tratt</name>
    </author>
    <author>
      <name>Christian Urban</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">ECOOP 2017, to appear</arxiv:comment>
    <link href="http://arxiv.org/abs/1602.06568v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1602.06568v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1602.07285v1</id>
    <updated>2016-02-23T20:09:33Z</updated>
    <published>2016-02-23T20:09:33Z</published>
    <title>Automatic Generation of Formula Simplifiers based on Conditional Rewrite
  Rules</title>
    <summary>  This paper addresses the problem of creating simplifiers for logic formulas
based on conditional term rewriting. In particular, the paper focuses on a
program synthesis application where formula simplifications have been shown to
have a significant impact. We show that by combining machine learning
techniques with constraint-based synthesis, it is possible to synthesize a
formula simplifier fully automatically from a corpus of representative
problems, making it possible to create formula simplifiers tailored to specific
problem domains. We demonstrate the benefits of our approach for synthesis
benchmarks from the SyGuS competition and automated grading.
</summary>
    <author>
      <name>Rohit Singh</name>
    </author>
    <author>
      <name>Armando Solar-Lezama</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted for peer reviewed conference</arxiv:comment>
    <link href="http://arxiv.org/abs/1602.07285v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1602.07285v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1602.08406v2</id>
    <updated>2016-08-14T15:28:05Z</updated>
    <published>2016-02-26T17:14:18Z</published>
    <title>Trace semantics for polymorphic references</title>
    <summary>  We introduce a trace semantics for a call-by-value language with full
polymorphism and higher-order references. This is an operational game semantics
model based on a nominal interpretation of parametricity whereby polymorphic
values are abstracted with special kinds of names. The use of polymorphic
references leads to violations of parametricity which we counter by closely
recoding the disclosure of typing information in the semantics. We prove the
model sound for the full language and strengthen our result to full abstraction
for a large fragment where polymorphic references obey specific inhabitation
conditions.
</summary>
    <author>
      <name>Guilhem Jaber</name>
    </author>
    <author>
      <name>Nikos Tzevelekos</name>
    </author>
    <link href="http://arxiv.org/abs/1602.08406v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1602.08406v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1603.01520v3</id>
    <updated>2016-03-11T11:31:59Z</updated>
    <published>2016-03-04T16:13:24Z</published>
    <title>Optimized Polynomial Evaluation with Semantic Annotations</title>
    <summary>  In this paper we discuss how semantic annotations can be used to introduce
mathematical algorithmic information of the underlying imperative code to
enable compilers to produce code transformations that will enable better
performance. By using this approaches not only good performance is achieved,
but also better programmability, maintainability and portability across
different hardware architectures. To exemplify this we will use polynomial
equations of different degrees.
</summary>
    <author>
      <name>Daniel Rubio Bonilla</name>
    </author>
    <author>
      <name>Colin W. Glass</name>
    </author>
    <author>
      <name>Jan Kuper</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Part of the Program Transformation for Programmability in
  Heterogeneous Architectures (PROHA) workshop, Barcelona, Spain, 12th March
  2016, 7 pages, LaTeX, 4 PNG figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1603.01520v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1603.01520v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="B.1.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1603.08648v2</id>
    <updated>2016-05-01T02:25:18Z</updated>
    <published>2016-03-29T05:35:34Z</published>
    <title>A Comparison of NOOP to Structural Domain-Theoretic Models of
  Object-Oriented Programming</title>
    <summary>  Mainstream object-oriented programming languages such as Java, C#, C++ and
Scala are all almost entirely nominally-typed. NOOP is a recently developed
domain-theoretic model of OOP that was designed to include full nominal
information found in nominally-typed OOP. This paper compares NOOP to the most
widely known domain-theoretic models of OOP, namely, the models developed by
Cardelli and Cook, which were structurally-typed models. Leveraging the
development of NOOP, the comparison presented in this paper provides a clear
and precise mathematical account for the relation between nominal and
structural OO type systems.
</summary>
    <author>
      <name>Moez A. AbdelGawad</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1603.08648v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1603.08648v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; D.1.5" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1604.01184v1</id>
    <updated>2016-04-05T09:03:53Z</updated>
    <published>2016-04-05T09:03:53Z</published>
    <title>Eilenberg--Moore Monoids and Backtracking Monad Transformers</title>
    <summary>  We develop an algebraic underpinning of backtracking monad transformers in
the general setting of monoidal categories. As our main technical device, we
introduce Eilenberg--Moore monoids, which combine monoids with algebras for
strong monads. We show that Eilenberg--Moore monoids coincide with algebras for
the list monad transformer ('done right') known from Haskell libraries.
  From this, we obtain a number of results, including the facts that the list
monad transformer is indeed a monad, a transformer, and an instance of the
MonadPlus class. Finally, we construct an Eilenberg--Moore monoid of
endomorphisms, which, via the codensity monad construction, yields a
continuation-based implementation a la Hinze.
</summary>
    <author>
      <name>Maciej Piróg</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, KU Leuven, Belgium</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.207.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.207.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MSFP 2016, arXiv:1604.00384</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 207, 2016, pp. 23-56</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1604.01184v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1604.01184v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1604.01185v1</id>
    <updated>2016-04-05T09:04:03Z</updated>
    <published>2016-04-05T09:04:03Z</published>
    <title>SMT Solving for Functional Programming over Infinite Structures</title>
    <summary>  We develop a simple functional programming language aimed at manipulating
infinite, but first-order definable structures, such as the countably infinite
clique graph or the set of all intervals with rational endpoints. Internally,
such sets are represented by logical formulas that define them, and an external
satisfiability modulo theories (SMT) solver is regularly run by the interpreter
to check their basic properties.
  The language is implemented as a Haskell module.
</summary>
    <author>
      <name>Bartek Klin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Warsaw</arxiv:affiliation>
    </author>
    <author>
      <name>Michał Szynwelski</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Warsaw</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.207.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.207.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MSFP 2016, arXiv:1604.00384</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 207, 2016, pp. 57-75</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1604.01185v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1604.01185v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1604.06245v4</id>
    <updated>2016-09-22T10:15:47Z</updated>
    <published>2016-04-21T10:24:17Z</published>
    <title>A Revision of the Mool Language</title>
    <summary>  We present here in a thorough analysis of the Mool language, covering not
only its implementation but also the formalisation (syntax, operational
semantics, and type system). The objective is to detect glitches in both the
implementation and in the formal definitions, proposing as well new features
and added expressiveness. To test our proposals we implemented the revision
developed in the Racket platform.
</summary>
    <author>
      <name>Cláudio Vasconcelos</name>
    </author>
    <author>
      <name>António Ravara</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">34 pages, 15 figures, 11 listings</arxiv:comment>
    <link href="http://arxiv.org/abs/1604.06245v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1604.06245v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
</feed>
